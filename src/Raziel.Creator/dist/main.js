/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./index.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./index.js":
/*!******************!*\
  !*** ./index.js ***!
  \******************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var tide_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! tide-js */ \"./node_modules/tide-js/index.js\");\n/* harmony import */ var _src_assets_js_config__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./src/assets/js/config */ \"./src/assets/js/config.js\");\n/* \r\n * Tide Protocol - Infrastructure for the Personal Data economy\r\n * Copyright (C) 2019 Tide Foundation Ltd\r\n * \r\n * This program is free software and is subject to the terms of \r\n * the Tide Community Open Source License as published by the \r\n * Tide Foundation Limited. You may modify it and redistribute \r\n * it in accordance with and subject to the terms of that License.\r\n * This program is distributed WITHOUT WARRANTY of any kind, \r\n * including without any implied warranty of MERCHANTABILITY or \r\n * FITNESS FOR A PARTICULAR PURPOSE.\r\n * See the Tide Community Open Source License for more details.\r\n * You should have received a copy of the Tide Community Open \r\n * Source License along with this program.\r\n * If not, see https://tide.org/licenses_tcosl-1-0-en\r\n */\r\n\r\n\r\n\r\n\r\ndocument.getElementById('submit-btn').onclick = async function () {\r\n    try {\r\n        console.log(await new tide_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"](_src_assets_js_config__WEBPACK_IMPORTED_MODULE_1__[\"default\"].nodes).postCredentials(document.getElementById(\"username\").value, document.getElementById(\"password\").value));\r\n        console.log(`Account created successfully`);\r\n    } catch (error) {\r\n        console.log(error);\r\n    }\r\n};\n\n//# sourceURL=webpack:///./index.js?");

/***/ }),

/***/ "./node_modules/tide-js/index.js":
/*!***************************************!*\
  !*** ./node_modules/tide-js/index.js ***!
  \***************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return Tide; });\n/* harmony import */ var _src_cryptide_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./src/cryptide.js */ \"./node_modules/tide-js/src/cryptide.js\");\n/* harmony import */ var _src_cryptide_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_src_cryptide_js__WEBPACK_IMPORTED_MODULE_0__);\n/* \r\n * Tide Protocol - Infrastructure for the Personal Data economy\r\n * Copyright (C) 2019 Tide Foundation Ltd\r\n *\t\r\n * This program is free software and is subject to the terms of\r\n * the Tide Community Open Source Licence as published by the \r\n * Tide Foundation Limited. You may modify it and redistribute \r\n * it in accordance with and subject to the terms of that licence.\r\n * This program is distributed WITHOUT WARRANTY of any kind, \r\n * including without any implied warranty of MERCHANTABILITY or \r\n * FITNESS FOR A PARTICULAR PURPOSE.  \r\n * See the Tide Community Open Source Licence for more details.\r\n * You should have received a copy of the Tide Community Open \r\n * Source Licence along with this program.  \r\n * If not, see https://tide.org/licenses/tcosl-1.0.en.html\r\n */\r\n\r\n\r\nclass Tide {\r\n    constructor(orkNodes) {\r\n        this.nodeArray = orkNodes;\r\n        this.threshold = orkNodes.length - 1;\r\n        this.hashes = [];\r\n    }\r\n\r\n    postCredentials(username, password) {\r\n        var self = this;\r\n        return new Promise(\r\n            async function (resolve, reject) {\r\n                try {\r\n                    const saltAndUser = self.hashUsername(username);\r\n\r\n                    // Create fragments\r\n                    const [cvkPrv, cvkPub] = _src_cryptide_js__WEBPACK_IMPORTED_MODULE_0___default.a.getKeys();\r\n                    const frags = _src_cryptide_js__WEBPACK_IMPORTED_MODULE_0___default.a.shareKey(cvkPrv, self.nodeArray.length, self.threshold);\r\n\r\n                    self.hashes = await _src_cryptide_js__WEBPACK_IMPORTED_MODULE_0___default.a.hashPasswords(password, saltAndUser.salt, self.nodeArray);\r\n\r\n                    await self.tideRequest(`${self.nodeArray[0]}/CreateAccount?publickey=notused&username=${saltAndUser.username}`)\r\n\r\n                    // Send fragments to ork nodes\r\n                    const sendFragmentsResult = await postFragments(self.nodeArray, cvkPub, frags, saltAndUser.username, self.hashes);\r\n\r\n                    return resolve({\r\n                        pub: cvkPub,\r\n                        priv: cvkPrv\r\n                    });\r\n                } catch (thrownError) {\r\n                    return reject(`Failed sending fragments to all selected orks with error: ${thrownError}`);\r\n                }\r\n            }\r\n        );\r\n    }\r\n\r\n    getCredentials(username, password) {\r\n        var self = this;\r\n        return new window.Promise(\r\n            async function (resolve, reject) {\r\n                const id = nextId();\r\n                log(id, `gathering user nodes...`)\r\n                try {\r\n                    const saltAndUser = self.hashUsername(username);\r\n\r\n                    // Gather the nodes the user used to register with Tide\r\n                    const userNodes = await tideRequest(`${self.nodeArray[0]}/nodes`, {\r\n                        username: saltAndUser.username\r\n                    });\r\n\r\n                    log(id, `Gathered user nodes. Count: ${userNodes.length}`)\r\n                    log(id, `Creating password fragments`)\r\n                    console.log(self.nodeArray)\r\n                    console.log(userNodes)\r\n                    self.hashes = await _src_cryptide_js__WEBPACK_IMPORTED_MODULE_0___default.a.hashPasswords(password, saltAndUser.salt, userNodes.map(n => n.ork_url));\r\n\r\n                    // Get the fragments from each node\r\n                    const fragmentResult = await getFragments(userNodes, saltAndUser.username, password, self.hashes, self.threshold);\r\n\r\n                    return resolve(fragmentResult);\r\n                } catch (thrownError) {\r\n                    log(nextId(), thrownError, 'error')\r\n                    return reject();\r\n                }\r\n            }\r\n        );\r\n    }\r\n\r\n    processEncryption(encrypt, data, key) {\r\n        return new window.Promise(\r\n            async function (resolve, reject) {\r\n                try {\r\n                    if (data == '' || data == null) return resolve('');\r\n                    return resolve(encrypt ? _src_cryptide_js__WEBPACK_IMPORTED_MODULE_0___default.a.encrypt(data, key) : _src_cryptide_js__WEBPACK_IMPORTED_MODULE_0___default.a.decrypt(data, key))\r\n                } catch (error) {\r\n                    return reject(\"Incorrect private key\");\r\n                }\r\n            });\r\n    }\r\n\r\n    hashUsername(data) {\r\n        var salt = _src_cryptide_js__WEBPACK_IMPORTED_MODULE_0___default.a.hashSha(data)\r\n        var username = _src_cryptide_js__WEBPACK_IMPORTED_MODULE_0___default.a.hashSha(salt)\r\n        return {\r\n            salt: salt,\r\n            username: username\r\n        };\r\n    }\r\n\r\n    tideRequest(url, data) {\r\n        return executeTideRequest(url, data)\r\n    }\r\n}\r\n\r\nfunction postFragments(nodes, cvkPublic, frags, username, hashes) {\r\n    return new Promise(\r\n        async function (resolve, reject) {\r\n            var complete = 0;\r\n\r\n            for (let i = 0; i < nodes.length; i++) {\r\n\r\n                const nodeIndex = i;\r\n                const model = {\r\n                    username: username,\r\n                    cvkPublic: cvkPublic,\r\n                    cvkPrivateFrag: frags[i],\r\n                    PasswordHash: hashes.find(h => h.server == nodes[nodeIndex]).pass\r\n                };\r\n\r\n                executeTideRequest(nodes[nodeIndex] + \"/PushFragment\", model).then((r) => {\r\n                    if (r.success) {\r\n                        complete++;\r\n                    } else {\r\n                        return reject(r.error);\r\n                    }\r\n\r\n                    if (complete == nodes.length) {\r\n                        return resolve();\r\n                    }\r\n                }).catch((e) => {\r\n                    log(nextId(), `Failed pushing fragments`)\r\n                });\r\n            }\r\n        });\r\n}\r\n\r\nfunction getFragments(nodes, username, password, hashes, threshold) {\r\n    return new window.Promise(\r\n        async function (resolve, reject) {\r\n            var frags = [];\r\n            var failedCount = 0;\r\n            const id = nextId();\r\n            const failId = nextId();\r\n\r\n            // Seed transient keys\r\n            log(nextId(), `Generating transient key-pair for transmission encryption`)\r\n            const [priv, pub] = _src_cryptide_js__WEBPACK_IMPORTED_MODULE_0___default.a.getKeys(32);\r\n\r\n            log(id, `Gathering fragments. ${frags.length}/${nodes.length}`)\r\n            const model = {\r\n                username: username,\r\n                publicKey: pub,\r\n                passwordHash: \"\"\r\n            };\r\n\r\n            const results = nodes.map((n) => tideRequest(`${n.ork_url}/login`, appendHash(model, n.ork_url, hashes)));\r\n\r\n            for (const r of results) {\r\n                await r.then((content) => {\r\n                    frags.push(content);\r\n                    log(id, `Gathering fragments. ${frags.length}/${nodes.length}`)\r\n                    if (frags.length == threshold) {\r\n\r\n                        log(id, `Finished gathering fragments`, 'success')\r\n\r\n                        return resolve({\r\n                            priv: _src_cryptide_js__WEBPACK_IMPORTED_MODULE_0___default.a.combineKeys(frags.map(f => _src_cryptide_js__WEBPACK_IMPORTED_MODULE_0___default.a.decrypt(f.vendorFragment.private_key_frag, priv))),\r\n                            pub: frags[0].vendorFragment.public_key\r\n                        });\r\n                    }\r\n                }).catch((e) => {\r\n                    log(failId, `Failed gathering ${failedCount++} fragments`)\r\n                    if (failedCount > nodes.length - threshold) return reject(e);\r\n                });\r\n            }\r\n        });\r\n}\r\n\r\nfunction tideRequest(url, data) {\r\n    return new window.Promise(\r\n        async function (resolve, reject) {\r\n            const http = new XMLHttpRequest();\r\n            http.onreadystatechange = function () {\r\n                if (this.readyState === 4) {\r\n                    if (this.status === 200) {\r\n                        const content = JSON.parse(this.responseText);\r\n                        if (content.success) return resolve(content.content);\r\n                        return reject(content.error);\r\n                    } else return reject(this.error);\r\n                }\r\n            };\r\n            http.open(data != null ? \"POST\" : \"GET\", url);\r\n            if (data != null) {\r\n                http.setRequestHeader(\"Content-type\", \"application/json; charset=utf-8\");\r\n                http.send(JSON.stringify(data));\r\n            } else {\r\n                http.send();\r\n            }\r\n        });\r\n}\r\n\r\nfunction appendHash(model, node, hashes) {\r\n    model.passwordHash = hashes.find(h => h.server == node).pass;\r\n    return model;\r\n}\r\n\r\nvar currentId = 0;\r\n\r\nfunction nextId() {\r\n    return currentId++;\r\n}\r\n\r\nfunction log(id, msg, type = 'log') {\r\n    document.dispatchEvent(new CustomEvent(\"tide-log\", {\r\n        detail: {\r\n            id: id,\r\n            msg: msg,\r\n            type: type,\r\n        }\r\n    }));\r\n}\r\n\r\nfunction executeTideRequest(url, data) {\r\n    return new window.Promise(\r\n        async function (resolve, reject) {\r\n            const http = new XMLHttpRequest();\r\n            http.onreadystatechange = function () {\r\n                if (this.readyState === 4) {\r\n                    if (this.status === 200) {\r\n                        const content = JSON.parse(this.responseText);\r\n                        if (content.success) return resolve(content);\r\n                        return reject(content.error);\r\n                    } else return reject(this.error);\r\n                }\r\n            };\r\n            http.open(data != null ? \"POST\" : \"GET\", url);\r\n            if (data != null) {\r\n                http.setRequestHeader(\"Content-type\", \"application/json; charset=utf-8\");\r\n                http.send(JSON.stringify(data));\r\n            } else {\r\n                http.send();\r\n            }\r\n        });\r\n}\n\n//# sourceURL=webpack:///./node_modules/tide-js/index.js?");

/***/ }),

/***/ "./node_modules/tide-js/src/cryptide.js":
/*!**********************************************!*\
  !*** ./node_modules/tide-js/src/cryptide.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/* WEBPACK VAR INJECTION */(function(global) {var require;var require;/* \r\n * Tide Protocol - Infrastructure for the Personal Data economy\r\n * Copyright (C) 2019 Tide Foundation Ltd\r\n * \r\n * This program is free software and is subject to the terms of \r\n * the Tide Community Open Source License as published by the \r\n * Tide Foundation Limited. You may modify it and redistribute \r\n * it in accordance with and subject to the terms of that License.\r\n * This program is distributed WITHOUT WARRANTY of any kind, \r\n * including without any implied warranty of MERCHANTABILITY or \r\n * FITNESS FOR A PARTICULAR PURPOSE.\r\n * See the Tide Community Open Source License for more details.\r\n * You should have received a copy of the Tide Community Open \r\n * Source License along with this program.\r\n * If not, see https://tide.org/licenses_tcosl-1-0-en\r\n */\r\n\r\n(function (f) {\r\n  if (true) {\r\n    module.exports = f()\r\n  } else { var g; }\r\n})(function () {\r\n  var define, module, exports;\r\n  return (function () {\r\n    function r(e, n, t) {\r\n      function o(i, f) {\r\n        if (!n[i]) {\r\n          if (!e[i]) {\r\n            var c = \"function\" == typeof require && require;\r\n            if (!f && c) return require(i, !0);\r\n            if (u) return u(i, !0);\r\n            var a = new Error(\"Cannot find module '\" + i + \"'\");\r\n            throw a.code = \"MODULE_NOT_FOUND\", a\r\n          }\r\n          var p = n[i] = {\r\n            exports: {}\r\n          };\r\n          e[i][0].call(p.exports, function (r) {\r\n            var n = e[i][1][r];\r\n            return o(n || r)\r\n          }, p, p.exports, r, e, n, t)\r\n        }\r\n        return n[i].exports\r\n      }\r\n      for (var u = \"function\" == typeof require && require, i = 0; i < t.length; i++) o(t[i]);\r\n      return o\r\n    }\r\n    return r\r\n  })()({\r\n    1: [function (require, module, exports) {\r\n      \"use strict\";\r\n\r\n      Object.defineProperty(exports, \"__esModule\", {\r\n        value: true\r\n      });\r\n      exports.setAsmPath = exports.getAsmPath = exports.hashPasswords = exports.hashSha = exports.hashArgon2 = exports.combineTexts = exports.combineDeciphers = exports.combineKeys = exports.decryptPartial = exports.decrypt = exports.encrypt = exports.shareText = exports.shareKey = exports.seedKeys = exports.getKeys = exports.default = void 0;\r\n\r\n      var _elGamal = _interopRequireDefault(require(\"./src/elGamal.js\"));\r\n\r\n      var _elGamalKey = _interopRequireDefault(require(\"./src/elGamalKey.js\"));\r\n\r\n      var _secretShare = _interopRequireDefault(require(\"./src/secretShare.js\"));\r\n\r\n      var _hash = _interopRequireDefault(require(\"./src/hash.js\"));\r\n\r\n      var _bigInteger = _interopRequireDefault(require(\"big-integer\"));\r\n\r\n      function _interopRequireDefault(obj) {\r\n        return obj && obj.__esModule ? obj : {\r\n          default: obj\r\n        };\r\n      }\r\n\r\n      function _classCallCheck(instance, Constructor) {\r\n        if (!(instance instanceof Constructor)) {\r\n          throw new TypeError(\"Cannot call a class as a function\");\r\n        }\r\n      }\r\n\r\n      function _defineProperties(target, props) {\r\n        for (var i = 0; i < props.length; i++) {\r\n          var descriptor = props[i];\r\n          descriptor.enumerable = descriptor.enumerable || false;\r\n          descriptor.configurable = true;\r\n          if (\"value\" in descriptor) descriptor.writable = true;\r\n          Object.defineProperty(target, descriptor.key, descriptor);\r\n        }\r\n      }\r\n\r\n      function _createClass(Constructor, protoProps, staticProps) {\r\n        if (protoProps) _defineProperties(Constructor.prototype, protoProps);\r\n        if (staticProps) _defineProperties(Constructor, staticProps);\r\n        return Constructor;\r\n      }\r\n\r\n      var p = (0, _bigInteger.default)('9d39f4f7fc915aded17550bccab12560edf43e03daaaf55847b91b35dcd07bb3', 16);\r\n\r\n      var Index =\r\n        /*#__PURE__*/\r\n        function () {\r\n          function Index() {\r\n            _classCallCheck(this, Index);\r\n          }\r\n\r\n          _createClass(Index, null, [{\r\n            key: \"getKeys\",\r\n            value: function getKeys() {\r\n              var bits = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 256;\r\n              var confidence = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 32;\r\n              return _elGamalKey.default.generate(bits, confidence).map(function (k) {\r\n                return k.toString();\r\n              });\r\n            }\r\n          }, {\r\n            key: \"getAsmPath\",\r\n            value: function getAsmPath() {\r\n              return _hash.default.asmUrl;\r\n            }\r\n          }, {\r\n            key: \"setAsmPath\",\r\n            value: function setAsmPath(value) {\r\n              _hash.default.asmUrl = value;\r\n            }\r\n          }, {\r\n            key: \"seedKeys\",\r\n            value: function seedKeys(pwd) {\r\n              return _elGamalKey.default.seed(pwd).map(function (k) {\r\n                return k.toString();\r\n              });\r\n            }\r\n          }, {\r\n            key: \"shareKey\",\r\n            value: function shareKey(key, number, threshold) {\r\n              return _elGamalKey.default.from(key).share(number, threshold).map(function (k) {\r\n                return k.toString();\r\n              });\r\n            }\r\n          }, {\r\n            key: \"shareText\",\r\n            value: function shareText(secret, number, threshold) {\r\n              return _secretShare.default.shareText(secret, number, threshold, p);\r\n            }\r\n          }, {\r\n            key: \"shareBuffer\",\r\n            value: function shareBuffer(secret, number, threshold) {\r\n              return _secretShare.default.shareBuffer(secret, number, threshold, p);\r\n            }\r\n          }, {\r\n            key: \"encrypt\",\r\n            value: function encrypt(text, pub) {\r\n              return _elGamal.default.encrypt(text, _elGamalKey.default.from(pub));\r\n            }\r\n          }, {\r\n            key: \"encryptBuffer\",\r\n            value: function encryptBuffer(text, pub) {\r\n              return _elGamal.default.encryptBuffer(text, _elGamalKey.default.from(pub));\r\n            }\r\n          }, {\r\n            key: \"decrypt\",\r\n            value: function decrypt(cypher, prv) {\r\n              return _elGamal.default.decrypt(cypher, _elGamalKey.default.from(prv));\r\n            }\r\n          }, {\r\n            key: \"decryptBuffer\",\r\n            value: function decryptBuffer(cypher, prv) {\r\n              return _elGamal.default.decryptBuffer(cypher, _elGamalKey.default.from(prv));\r\n            }\r\n          }, {\r\n            key: \"decryptPartial\",\r\n            value: function decryptPartial(cypher, prv) {\r\n              return _elGamal.default.decryptPartial(cypher, _elGamalKey.default.from(prv));\r\n            }\r\n          }, {\r\n            key: \"decryptPartialBuffer\",\r\n            value: function decryptPartialBuffer(cypher, prv) {\r\n              return _elGamal.default.decryptPartialBuffer(cypher, _elGamalKey.default.from(prv));\r\n            }\r\n          }, {\r\n            key: \"combineKeys\",\r\n            value: function combineKeys(partials) {\r\n              var keys = partials.map(function (k) {\r\n                return _elGamalKey.default.from(k);\r\n              });\r\n              return _elGamalKey.default.combine(keys).toString();\r\n            }\r\n          }, {\r\n            key: \"combineDeciphers\",\r\n            value: function combineDeciphers(partials, pub) {\r\n              return _elGamal.default.combinePartial(partials, _elGamalKey.default.from(pub));\r\n            }\r\n          }, {\r\n            key: \"combinePartialBuffer\",\r\n            value: function combinePartialBuffer(partials, pub) {\r\n              return _elGamal.default.combinePartialBuffer(partials, _elGamalKey.default.from(pub));\r\n            }\r\n          }, {\r\n            key: \"combineTexts\",\r\n            value: function combineTexts(partials) {\r\n              return _secretShare.default.interpolateText(partials, p);\r\n            }\r\n          }, {\r\n            key: \"interpolateBuffer\",\r\n            value: function interpolateBuffer(partials) {\r\n              return _secretShare.default.interpolateBuffer(partials, p);\r\n            }\r\n          }, {\r\n            key: \"hashArgon2\",\r\n            value: function hashArgon2(pass, salt) {\r\n              return _hash.default.argon2(pass, salt);\r\n            }\r\n          }, {\r\n            key: \"hashSha\",\r\n            value: function hashSha(data) {\r\n              return _hash.default.sha(data);\r\n            }\r\n          }, {\r\n            key: \"hashPasswords\",\r\n            value: function hashPasswords(pass, salt, servers) {\r\n              return _hash.default.passwords(pass, salt, servers);\r\n            }\r\n          }]);\r\n\r\n          return Index;\r\n        }();\r\n\r\n      exports.default = Index;\r\n      var getKeys = Index.getKeys;\r\n      exports.getKeys = getKeys;\r\n      var seedKeys = Index.seedKeys;\r\n      exports.seedKeys = seedKeys;\r\n      var shareKey = Index.shareKey;\r\n      exports.shareKey = shareKey;\r\n      var shareText = Index.shareText;\r\n      exports.shareText = shareText;\r\n      var encrypt = Index.encrypt;\r\n      exports.encrypt = encrypt;\r\n      var decrypt = Index.decrypt;\r\n      exports.decrypt = decrypt;\r\n      var decryptPartial = Index.decryptPartial;\r\n      exports.decryptPartial = decryptPartial;\r\n      var combineKeys = Index.combineKeys;\r\n      exports.combineKeys = combineKeys;\r\n      var combineDeciphers = Index.combineDeciphers;\r\n      exports.combineDeciphers = combineDeciphers;\r\n      var combineTexts = Index.combineTexts;\r\n      exports.combineTexts = combineTexts;\r\n      var hashArgon2 = Index.hashArgon2;\r\n      exports.hashArgon2 = hashArgon2;\r\n      var hashSha = Index.hashSha;\r\n      exports.hashSha = hashSha;\r\n      var hashPasswords = Index.hashPasswords;\r\n      exports.hashPasswords = hashPasswords;\r\n      var getAsmPath = Index.getAsmPath;\r\n      exports.getAsmPath = getAsmPath;\r\n      var setAsmPath = Index.setAsmPath;\r\n      exports.setAsmPath = setAsmPath;\r\n\r\n    }, {\r\n      \"./src/elGamal.js\": 161,\r\n      \"./src/elGamalKey.js\": 162,\r\n      \"./src/hash.js\": 163,\r\n      \"./src/secretShare.js\": 164,\r\n      \"big-integer\": 22\r\n    }],\r\n    2: [function (require, module, exports) {\r\n      (function (root, factory) {\r\n        if (typeof define === 'function' && define.amd) {\r\n          define([], function () {\r\n            return (root.argon2 = factory());\r\n          });\r\n        } else {\r\n          root.argon2 = factory();\r\n        }\r\n      }(this, function () {\r\n        'use strict';\r\n\r\n        var defaultDistPath = '/node_modules/argon2-browser/dist';\r\n\r\n        /**\r\n         * @enum\r\n         */\r\n        var ArgonType = {\r\n          Argon2d: 0,\r\n          Argon2i: 1,\r\n          Argon2id: 2\r\n        };\r\n\r\n        var scriptLoadedPromise;\r\n\r\n        function loadScript(src) {\r\n          return new Promise(function (resolve, reject) {\r\n            if (typeof importScripts === 'function') {\r\n              importScripts(src);\r\n              resolve();\r\n            } else {\r\n              var el = document.createElement(\"script\");\r\n              el.src = src;\r\n              el.onload = function () {\r\n                resolve();\r\n              };\r\n              el.onerror = function () {\r\n                reject('Error loading script');\r\n              };\r\n              document.body.appendChild(el);\r\n            }\r\n          });\r\n        }\r\n\r\n        function allocateArray(strOrArr) {\r\n          var arr = strOrArr instanceof Uint8Array || strOrArr instanceof Array ? strOrArr :\r\n            Module.intArrayFromString(strOrArr);\r\n          return Module.allocate(arr, 'i8', Module.ALLOC_NORMAL);\r\n        }\r\n\r\n        /**\r\n         * Argon2 hash\r\n         * @param {string|Uint8Array} params.pass - password string\r\n         * @param {string|Uint8Array} params.salt - salt string\r\n         * @param {number} [params.time=1] - the number of iterations\r\n         * @param {number} [params.mem=1024] - used memory, in KiB\r\n         * @param {number} [params.hashLen=24] - desired hash length\r\n         * @param {number} [params.parallelism=1] - desired parallelism\r\n         * @param {number} [params.type=argon2.ArgonType.Argon2d] - hash type:\r\n         *      argon2.ArgonType.Argon2d\r\n         *      argon2.ArgonType.Argon2i\r\n         *      argon2.ArgonType.Argon2id\r\n         * @param {number} [params.distPath=.] - asm.js script location, without trailing slash\r\n         *\r\n         * @return Promise\r\n         *\r\n         * @example\r\n         *  argon2.hash({ pass: 'password', salt: 'somesalt' })\r\n         *      .then(h => console.log(h.hash, h.hashHex, h.encoded))\r\n         *      .catch(e => console.error(e.message, e.code))\r\n         */\r\n        function argon2Hash(params) {\r\n          if (!scriptLoadedPromise) {\r\n            var distPath = params.distPath || defaultDistPath;\r\n            scriptLoadedPromise = loadScript(distPath + '/argon2-asm.min.js');\r\n          }\r\n          return scriptLoadedPromise.then(function () {\r\n            var tCost = params.time || 1;\r\n            var mCost = params.mem || 1024;\r\n            var parallelism = params.parallelism || 1;\r\n            var pwd = allocateArray(params.pass);\r\n            var pwdlen = params.pass.length;\r\n            var salt = allocateArray(params.salt);\r\n            var saltlen = params.salt.length;\r\n            var hash = Module.allocate(new Array(params.hashLen || 24), 'i8', Module.ALLOC_NORMAL);\r\n            var hashlen = params.hashLen || 24;\r\n            var encoded = Module.allocate(new Array(512), 'i8', Module.ALLOC_NORMAL);\r\n            var encodedlen = 512;\r\n            var argon2Type = params.type || ArgonType.Argon2d;\r\n            var version = 0x13;\r\n            var err;\r\n            try {\r\n              var res = Module._argon2_hash(tCost, mCost, parallelism, pwd, pwdlen, salt, saltlen,\r\n                hash, hashlen, encoded, encodedlen, argon2Type, version);\r\n            } catch (e) {\r\n              err = e;\r\n            }\r\n            var result;\r\n            if (res === 0 && !err) {\r\n              var hashStr = '';\r\n              var hashArr = new Uint8Array(hashlen);\r\n              for (var i = 0; i < hashlen; i++) {\r\n                var byte = Module.HEAP8[hash + i];\r\n                hashArr[i] = byte;\r\n                hashStr += ('0' + (0xFF & byte).toString(16)).slice(-2);\r\n              }\r\n              var encodedStr = Module.Pointer_stringify(encoded);\r\n              result = {\r\n                hash: hashArr,\r\n                hashHex: hashStr,\r\n                encoded: encodedStr\r\n              };\r\n            } else {\r\n              try {\r\n                if (!err) {\r\n                  err = Module.Pointer_stringify(Module._argon2_error_message(res))\r\n                }\r\n              } catch (e) {}\r\n              result = {\r\n                message: err,\r\n                code: res\r\n              };\r\n            }\r\n            try {\r\n              Module._free(pwd);\r\n              Module._free(salt);\r\n              Module._free(hash);\r\n              Module._free(encoded);\r\n            } catch (e) {}\r\n            if (err) {\r\n              throw result;\r\n            } else {\r\n              return result;\r\n            }\r\n          });\r\n        }\r\n\r\n        /**\r\n         * Argon2 verify function\r\n         * @param {string} params.pass - password string\r\n         * @param {string|Uint8Array} params.encoded - encoded hash\r\n         * @param {number} [params.type=argon2.ArgonType.Argon2d] - hash type:\r\n         *      argon2.ArgonType.Argon2d\r\n         *      argon2.ArgonType.Argon2i\r\n         *      argon2.ArgonType.Argon2id\r\n         *\r\n         * @returns Promise\r\n         *\r\n         * @example\r\n         *  argon2.verify({ pass: 'password', encoded: 'encoded-hash' })\r\n         *      .then(() => console.log('OK'))\r\n         *      .catch(e => console.error(e.message, e.code))\r\n         */\r\n        function argon2Verify(params) {\r\n          if (!scriptLoadedPromise) {\r\n            var distPath = params.distPath || defaultDistPath;\r\n            scriptLoadedPromise = loadScript(distPath + '/argon2-asm.min.js');\r\n          }\r\n          return scriptLoadedPromise.then(function () {\r\n            var pwd = allocateArray(params.pass);\r\n            var pwdlen = params.pass.length;\r\n            var enc = allocateArray(params.encoded);\r\n            var argon2Type = params.type;\r\n            if (argon2Type === undefined) {\r\n              var typeStr = params.encoded.split('$')[1];\r\n              if (typeStr) {\r\n                typeStr = typeStr.replace('a', 'A');\r\n                argon2Type = ArgonType[typeStr] || ArgonType.Argon2d;\r\n              }\r\n            }\r\n            var err;\r\n            try {\r\n              var res = Module._argon2_verify(enc, pwd, pwdlen, argon2Type);\r\n            } catch (e) {\r\n              err = e;\r\n            }\r\n            var result;\r\n            if (res || err) {\r\n              try {\r\n                if (!err) {\r\n                  err = Module.Pointer_stringify(Module._argon2_error_message(res))\r\n                }\r\n              } catch (e) {}\r\n              result = {\r\n                message: err,\r\n                code: res\r\n              };\r\n            }\r\n            try {\r\n              Module._free(pwd);\r\n              Module._free(enc);\r\n            } catch (e) {}\r\n            if (err) {\r\n              throw result;\r\n            } else {\r\n              return result;\r\n            }\r\n          });\r\n        }\r\n\r\n        return {\r\n          ArgonType: ArgonType,\r\n          hash: argon2Hash,\r\n          verify: argon2Verify\r\n        };\r\n      }));\r\n\r\n\r\n    }, {}],\r\n    3: [function (require, module, exports) {\r\n      var asn1 = exports;\r\n\r\n      asn1.bignum = require('bn.js');\r\n\r\n      asn1.define = require('./asn1/api').define;\r\n      asn1.base = require('./asn1/base');\r\n      asn1.constants = require('./asn1/constants');\r\n      asn1.decoders = require('./asn1/decoders');\r\n      asn1.encoders = require('./asn1/encoders');\r\n\r\n    }, {\r\n      \"./asn1/api\": 4,\r\n      \"./asn1/base\": 6,\r\n      \"./asn1/constants\": 10,\r\n      \"./asn1/decoders\": 12,\r\n      \"./asn1/encoders\": 15,\r\n      \"bn.js\": 23\r\n    }],\r\n    4: [function (require, module, exports) {\r\n      var asn1 = require('../asn1');\r\n      var inherits = require('inherits');\r\n\r\n      var api = exports;\r\n\r\n      api.define = function define(name, body) {\r\n        return new Entity(name, body);\r\n      };\r\n\r\n      function Entity(name, body) {\r\n        this.name = name;\r\n        this.body = body;\r\n\r\n        this.decoders = {};\r\n        this.encoders = {};\r\n      };\r\n\r\n      Entity.prototype._createNamed = function createNamed(base) {\r\n        var named;\r\n        try {\r\n          named = require('vm').runInThisContext(\r\n            '(function ' + this.name + '(entity) {\\n' +\r\n            '  this._initNamed(entity);\\n' +\r\n            '})'\r\n          );\r\n        } catch (e) {\r\n          named = function (entity) {\r\n            this._initNamed(entity);\r\n          };\r\n        }\r\n        inherits(named, base);\r\n        named.prototype._initNamed = function initnamed(entity) {\r\n          base.call(this, entity);\r\n        };\r\n\r\n        return new named(this);\r\n      };\r\n\r\n      Entity.prototype._getDecoder = function _getDecoder(enc) {\r\n        enc = enc || 'der';\r\n        // Lazily create decoder\r\n        if (!this.decoders.hasOwnProperty(enc))\r\n          this.decoders[enc] = this._createNamed(asn1.decoders[enc]);\r\n        return this.decoders[enc];\r\n      };\r\n\r\n      Entity.prototype.decode = function decode(data, enc, options) {\r\n        return this._getDecoder(enc).decode(data, options);\r\n      };\r\n\r\n      Entity.prototype._getEncoder = function _getEncoder(enc) {\r\n        enc = enc || 'der';\r\n        // Lazily create encoder\r\n        if (!this.encoders.hasOwnProperty(enc))\r\n          this.encoders[enc] = this._createNamed(asn1.encoders[enc]);\r\n        return this.encoders[enc];\r\n      };\r\n\r\n      Entity.prototype.encode = function encode(data, enc, /* internal */ reporter) {\r\n        return this._getEncoder(enc).encode(data, reporter);\r\n      };\r\n\r\n    }, {\r\n      \"../asn1\": 3,\r\n      \"inherits\": 106,\r\n      \"vm\": 160\r\n    }],\r\n    5: [function (require, module, exports) {\r\n      var inherits = require('inherits');\r\n      var Reporter = require('../base').Reporter;\r\n      var Buffer = require('buffer').Buffer;\r\n\r\n      function DecoderBuffer(base, options) {\r\n        Reporter.call(this, options);\r\n        if (!Buffer.isBuffer(base)) {\r\n          this.error('Input not Buffer');\r\n          return;\r\n        }\r\n\r\n        this.base = base;\r\n        this.offset = 0;\r\n        this.length = base.length;\r\n      }\r\n      inherits(DecoderBuffer, Reporter);\r\n      exports.DecoderBuffer = DecoderBuffer;\r\n\r\n      DecoderBuffer.prototype.save = function save() {\r\n        return {\r\n          offset: this.offset,\r\n          reporter: Reporter.prototype.save.call(this)\r\n        };\r\n      };\r\n\r\n      DecoderBuffer.prototype.restore = function restore(save) {\r\n        // Return skipped data\r\n        var res = new DecoderBuffer(this.base);\r\n        res.offset = save.offset;\r\n        res.length = this.offset;\r\n\r\n        this.offset = save.offset;\r\n        Reporter.prototype.restore.call(this, save.reporter);\r\n\r\n        return res;\r\n      };\r\n\r\n      DecoderBuffer.prototype.isEmpty = function isEmpty() {\r\n        return this.offset === this.length;\r\n      };\r\n\r\n      DecoderBuffer.prototype.readUInt8 = function readUInt8(fail) {\r\n        if (this.offset + 1 <= this.length)\r\n          return this.base.readUInt8(this.offset++, true);\r\n        else\r\n          return this.error(fail || 'DecoderBuffer overrun');\r\n      }\r\n\r\n      DecoderBuffer.prototype.skip = function skip(bytes, fail) {\r\n        if (!(this.offset + bytes <= this.length))\r\n          return this.error(fail || 'DecoderBuffer overrun');\r\n\r\n        var res = new DecoderBuffer(this.base);\r\n\r\n        // Share reporter state\r\n        res._reporterState = this._reporterState;\r\n\r\n        res.offset = this.offset;\r\n        res.length = this.offset + bytes;\r\n        this.offset += bytes;\r\n        return res;\r\n      }\r\n\r\n      DecoderBuffer.prototype.raw = function raw(save) {\r\n        return this.base.slice(save ? save.offset : this.offset, this.length);\r\n      }\r\n\r\n      function EncoderBuffer(value, reporter) {\r\n        if (Array.isArray(value)) {\r\n          this.length = 0;\r\n          this.value = value.map(function (item) {\r\n            if (!(item instanceof EncoderBuffer))\r\n              item = new EncoderBuffer(item, reporter);\r\n            this.length += item.length;\r\n            return item;\r\n          }, this);\r\n        } else if (typeof value === 'number') {\r\n          if (!(0 <= value && value <= 0xff))\r\n            return reporter.error('non-byte EncoderBuffer value');\r\n          this.value = value;\r\n          this.length = 1;\r\n        } else if (typeof value === 'string') {\r\n          this.value = value;\r\n          this.length = Buffer.byteLength(value);\r\n        } else if (Buffer.isBuffer(value)) {\r\n          this.value = value;\r\n          this.length = value.length;\r\n        } else {\r\n          return reporter.error('Unsupported type: ' + typeof value);\r\n        }\r\n      }\r\n      exports.EncoderBuffer = EncoderBuffer;\r\n\r\n      EncoderBuffer.prototype.join = function join(out, offset) {\r\n        if (!out)\r\n          out = new Buffer(this.length);\r\n        if (!offset)\r\n          offset = 0;\r\n\r\n        if (this.length === 0)\r\n          return out;\r\n\r\n        if (Array.isArray(this.value)) {\r\n          this.value.forEach(function (item) {\r\n            item.join(out, offset);\r\n            offset += item.length;\r\n          });\r\n        } else {\r\n          if (typeof this.value === 'number')\r\n            out[offset] = this.value;\r\n          else if (typeof this.value === 'string')\r\n            out.write(this.value, offset);\r\n          else if (Buffer.isBuffer(this.value))\r\n            this.value.copy(out, offset);\r\n          offset += this.length;\r\n        }\r\n\r\n        return out;\r\n      };\r\n\r\n    }, {\r\n      \"../base\": 6,\r\n      \"buffer\": 54,\r\n      \"inherits\": 106\r\n    }],\r\n    6: [function (require, module, exports) {\r\n      var base = exports;\r\n\r\n      base.Reporter = require('./reporter').Reporter;\r\n      base.DecoderBuffer = require('./buffer').DecoderBuffer;\r\n      base.EncoderBuffer = require('./buffer').EncoderBuffer;\r\n      base.Node = require('./node');\r\n\r\n    }, {\r\n      \"./buffer\": 5,\r\n      \"./node\": 7,\r\n      \"./reporter\": 8\r\n    }],\r\n    7: [function (require, module, exports) {\r\n      var Reporter = require('../base').Reporter;\r\n      var EncoderBuffer = require('../base').EncoderBuffer;\r\n      var DecoderBuffer = require('../base').DecoderBuffer;\r\n      var assert = require('minimalistic-assert');\r\n\r\n      // Supported tags\r\n      var tags = [\r\n        'seq', 'seqof', 'set', 'setof', 'objid', 'bool',\r\n        'gentime', 'utctime', 'null_', 'enum', 'int', 'objDesc',\r\n        'bitstr', 'bmpstr', 'charstr', 'genstr', 'graphstr', 'ia5str', 'iso646str',\r\n        'numstr', 'octstr', 'printstr', 't61str', 'unistr', 'utf8str', 'videostr'\r\n      ];\r\n\r\n      // Public methods list\r\n      var methods = [\r\n        'key', 'obj', 'use', 'optional', 'explicit', 'implicit', 'def', 'choice',\r\n        'any', 'contains'\r\n      ].concat(tags);\r\n\r\n      // Overrided methods list\r\n      var overrided = [\r\n        '_peekTag', '_decodeTag', '_use',\r\n        '_decodeStr', '_decodeObjid', '_decodeTime',\r\n        '_decodeNull', '_decodeInt', '_decodeBool', '_decodeList',\r\n\r\n        '_encodeComposite', '_encodeStr', '_encodeObjid', '_encodeTime',\r\n        '_encodeNull', '_encodeInt', '_encodeBool'\r\n      ];\r\n\r\n      function Node(enc, parent) {\r\n        var state = {};\r\n        this._baseState = state;\r\n\r\n        state.enc = enc;\r\n\r\n        state.parent = parent || null;\r\n        state.children = null;\r\n\r\n        // State\r\n        state.tag = null;\r\n        state.args = null;\r\n        state.reverseArgs = null;\r\n        state.choice = null;\r\n        state.optional = false;\r\n        state.any = false;\r\n        state.obj = false;\r\n        state.use = null;\r\n        state.useDecoder = null;\r\n        state.key = null;\r\n        state['default'] = null;\r\n        state.explicit = null;\r\n        state.implicit = null;\r\n        state.contains = null;\r\n\r\n        // Should create new instance on each method\r\n        if (!state.parent) {\r\n          state.children = [];\r\n          this._wrap();\r\n        }\r\n      }\r\n      module.exports = Node;\r\n\r\n      var stateProps = [\r\n        'enc', 'parent', 'children', 'tag', 'args', 'reverseArgs', 'choice',\r\n        'optional', 'any', 'obj', 'use', 'alteredUse', 'key', 'default', 'explicit',\r\n        'implicit', 'contains'\r\n      ];\r\n\r\n      Node.prototype.clone = function clone() {\r\n        var state = this._baseState;\r\n        var cstate = {};\r\n        stateProps.forEach(function (prop) {\r\n          cstate[prop] = state[prop];\r\n        });\r\n        var res = new this.constructor(cstate.parent);\r\n        res._baseState = cstate;\r\n        return res;\r\n      };\r\n\r\n      Node.prototype._wrap = function wrap() {\r\n        var state = this._baseState;\r\n        methods.forEach(function (method) {\r\n          this[method] = function _wrappedMethod() {\r\n            var clone = new this.constructor(this);\r\n            state.children.push(clone);\r\n            return clone[method].apply(clone, arguments);\r\n          };\r\n        }, this);\r\n      };\r\n\r\n      Node.prototype._init = function init(body) {\r\n        var state = this._baseState;\r\n\r\n        assert(state.parent === null);\r\n        body.call(this);\r\n\r\n        // Filter children\r\n        state.children = state.children.filter(function (child) {\r\n          return child._baseState.parent === this;\r\n        }, this);\r\n        assert.equal(state.children.length, 1, 'Root node can have only one child');\r\n      };\r\n\r\n      Node.prototype._useArgs = function useArgs(args) {\r\n        var state = this._baseState;\r\n\r\n        // Filter children and args\r\n        var children = args.filter(function (arg) {\r\n          return arg instanceof this.constructor;\r\n        }, this);\r\n        args = args.filter(function (arg) {\r\n          return !(arg instanceof this.constructor);\r\n        }, this);\r\n\r\n        if (children.length !== 0) {\r\n          assert(state.children === null);\r\n          state.children = children;\r\n\r\n          // Replace parent to maintain backward link\r\n          children.forEach(function (child) {\r\n            child._baseState.parent = this;\r\n          }, this);\r\n        }\r\n        if (args.length !== 0) {\r\n          assert(state.args === null);\r\n          state.args = args;\r\n          state.reverseArgs = args.map(function (arg) {\r\n            if (typeof arg !== 'object' || arg.constructor !== Object)\r\n              return arg;\r\n\r\n            var res = {};\r\n            Object.keys(arg).forEach(function (key) {\r\n              if (key == (key | 0))\r\n                key |= 0;\r\n              var value = arg[key];\r\n              res[value] = key;\r\n            });\r\n            return res;\r\n          });\r\n        }\r\n      };\r\n\r\n      //\r\n      // Overrided methods\r\n      //\r\n\r\n      overrided.forEach(function (method) {\r\n        Node.prototype[method] = function _overrided() {\r\n          var state = this._baseState;\r\n          throw new Error(method + ' not implemented for encoding: ' + state.enc);\r\n        };\r\n      });\r\n\r\n      //\r\n      // Public methods\r\n      //\r\n\r\n      tags.forEach(function (tag) {\r\n        Node.prototype[tag] = function _tagMethod() {\r\n          var state = this._baseState;\r\n          var args = Array.prototype.slice.call(arguments);\r\n\r\n          assert(state.tag === null);\r\n          state.tag = tag;\r\n\r\n          this._useArgs(args);\r\n\r\n          return this;\r\n        };\r\n      });\r\n\r\n      Node.prototype.use = function use(item) {\r\n        assert(item);\r\n        var state = this._baseState;\r\n\r\n        assert(state.use === null);\r\n        state.use = item;\r\n\r\n        return this;\r\n      };\r\n\r\n      Node.prototype.optional = function optional() {\r\n        var state = this._baseState;\r\n\r\n        state.optional = true;\r\n\r\n        return this;\r\n      };\r\n\r\n      Node.prototype.def = function def(val) {\r\n        var state = this._baseState;\r\n\r\n        assert(state['default'] === null);\r\n        state['default'] = val;\r\n        state.optional = true;\r\n\r\n        return this;\r\n      };\r\n\r\n      Node.prototype.explicit = function explicit(num) {\r\n        var state = this._baseState;\r\n\r\n        assert(state.explicit === null && state.implicit === null);\r\n        state.explicit = num;\r\n\r\n        return this;\r\n      };\r\n\r\n      Node.prototype.implicit = function implicit(num) {\r\n        var state = this._baseState;\r\n\r\n        assert(state.explicit === null && state.implicit === null);\r\n        state.implicit = num;\r\n\r\n        return this;\r\n      };\r\n\r\n      Node.prototype.obj = function obj() {\r\n        var state = this._baseState;\r\n        var args = Array.prototype.slice.call(arguments);\r\n\r\n        state.obj = true;\r\n\r\n        if (args.length !== 0)\r\n          this._useArgs(args);\r\n\r\n        return this;\r\n      };\r\n\r\n      Node.prototype.key = function key(newKey) {\r\n        var state = this._baseState;\r\n\r\n        assert(state.key === null);\r\n        state.key = newKey;\r\n\r\n        return this;\r\n      };\r\n\r\n      Node.prototype.any = function any() {\r\n        var state = this._baseState;\r\n\r\n        state.any = true;\r\n\r\n        return this;\r\n      };\r\n\r\n      Node.prototype.choice = function choice(obj) {\r\n        var state = this._baseState;\r\n\r\n        assert(state.choice === null);\r\n        state.choice = obj;\r\n        this._useArgs(Object.keys(obj).map(function (key) {\r\n          return obj[key];\r\n        }));\r\n\r\n        return this;\r\n      };\r\n\r\n      Node.prototype.contains = function contains(item) {\r\n        var state = this._baseState;\r\n\r\n        assert(state.use === null);\r\n        state.contains = item;\r\n\r\n        return this;\r\n      };\r\n\r\n      //\r\n      // Decoding\r\n      //\r\n\r\n      Node.prototype._decode = function decode(input, options) {\r\n        var state = this._baseState;\r\n\r\n        // Decode root node\r\n        if (state.parent === null)\r\n          return input.wrapResult(state.children[0]._decode(input, options));\r\n\r\n        var result = state['default'];\r\n        var present = true;\r\n\r\n        var prevKey = null;\r\n        if (state.key !== null)\r\n          prevKey = input.enterKey(state.key);\r\n\r\n        // Check if tag is there\r\n        if (state.optional) {\r\n          var tag = null;\r\n          if (state.explicit !== null)\r\n            tag = state.explicit;\r\n          else if (state.implicit !== null)\r\n            tag = state.implicit;\r\n          else if (state.tag !== null)\r\n            tag = state.tag;\r\n\r\n          if (tag === null && !state.any) {\r\n            // Trial and Error\r\n            var save = input.save();\r\n            try {\r\n              if (state.choice === null)\r\n                this._decodeGeneric(state.tag, input, options);\r\n              else\r\n                this._decodeChoice(input, options);\r\n              present = true;\r\n            } catch (e) {\r\n              present = false;\r\n            }\r\n            input.restore(save);\r\n          } else {\r\n            present = this._peekTag(input, tag, state.any);\r\n\r\n            if (input.isError(present))\r\n              return present;\r\n          }\r\n        }\r\n\r\n        // Push object on stack\r\n        var prevObj;\r\n        if (state.obj && present)\r\n          prevObj = input.enterObject();\r\n\r\n        if (present) {\r\n          // Unwrap explicit values\r\n          if (state.explicit !== null) {\r\n            var explicit = this._decodeTag(input, state.explicit);\r\n            if (input.isError(explicit))\r\n              return explicit;\r\n            input = explicit;\r\n          }\r\n\r\n          var start = input.offset;\r\n\r\n          // Unwrap implicit and normal values\r\n          if (state.use === null && state.choice === null) {\r\n            if (state.any)\r\n              var save = input.save();\r\n            var body = this._decodeTag(\r\n              input,\r\n              state.implicit !== null ? state.implicit : state.tag,\r\n              state.any\r\n            );\r\n            if (input.isError(body))\r\n              return body;\r\n\r\n            if (state.any)\r\n              result = input.raw(save);\r\n            else\r\n              input = body;\r\n          }\r\n\r\n          if (options && options.track && state.tag !== null)\r\n            options.track(input.path(), start, input.length, 'tagged');\r\n\r\n          if (options && options.track && state.tag !== null)\r\n            options.track(input.path(), input.offset, input.length, 'content');\r\n\r\n          // Select proper method for tag\r\n          if (state.any)\r\n            result = result;\r\n          else if (state.choice === null)\r\n            result = this._decodeGeneric(state.tag, input, options);\r\n          else\r\n            result = this._decodeChoice(input, options);\r\n\r\n          if (input.isError(result))\r\n            return result;\r\n\r\n          // Decode children\r\n          if (!state.any && state.choice === null && state.children !== null) {\r\n            state.children.forEach(function decodeChildren(child) {\r\n              // NOTE: We are ignoring errors here, to let parser continue with other\r\n              // parts of encoded data\r\n              child._decode(input, options);\r\n            });\r\n          }\r\n\r\n          // Decode contained/encoded by schema, only in bit or octet strings\r\n          if (state.contains && (state.tag === 'octstr' || state.tag === 'bitstr')) {\r\n            var data = new DecoderBuffer(result);\r\n            result = this._getUse(state.contains, input._reporterState.obj)\r\n              ._decode(data, options);\r\n          }\r\n        }\r\n\r\n        // Pop object\r\n        if (state.obj && present)\r\n          result = input.leaveObject(prevObj);\r\n\r\n        // Set key\r\n        if (state.key !== null && (result !== null || present === true))\r\n          input.leaveKey(prevKey, state.key, result);\r\n        else if (prevKey !== null)\r\n          input.exitKey(prevKey);\r\n\r\n        return result;\r\n      };\r\n\r\n      Node.prototype._decodeGeneric = function decodeGeneric(tag, input, options) {\r\n        var state = this._baseState;\r\n\r\n        if (tag === 'seq' || tag === 'set')\r\n          return null;\r\n        if (tag === 'seqof' || tag === 'setof')\r\n          return this._decodeList(input, tag, state.args[0], options);\r\n        else if (/str$/.test(tag))\r\n          return this._decodeStr(input, tag, options);\r\n        else if (tag === 'objid' && state.args)\r\n          return this._decodeObjid(input, state.args[0], state.args[1], options);\r\n        else if (tag === 'objid')\r\n          return this._decodeObjid(input, null, null, options);\r\n        else if (tag === 'gentime' || tag === 'utctime')\r\n          return this._decodeTime(input, tag, options);\r\n        else if (tag === 'null_')\r\n          return this._decodeNull(input, options);\r\n        else if (tag === 'bool')\r\n          return this._decodeBool(input, options);\r\n        else if (tag === 'objDesc')\r\n          return this._decodeStr(input, tag, options);\r\n        else if (tag === 'int' || tag === 'enum')\r\n          return this._decodeInt(input, state.args && state.args[0], options);\r\n\r\n        if (state.use !== null) {\r\n          return this._getUse(state.use, input._reporterState.obj)\r\n            ._decode(input, options);\r\n        } else {\r\n          return input.error('unknown tag: ' + tag);\r\n        }\r\n      };\r\n\r\n      Node.prototype._getUse = function _getUse(entity, obj) {\r\n\r\n        var state = this._baseState;\r\n        // Create altered use decoder if implicit is set\r\n        state.useDecoder = this._use(entity, obj);\r\n        assert(state.useDecoder._baseState.parent === null);\r\n        state.useDecoder = state.useDecoder._baseState.children[0];\r\n        if (state.implicit !== state.useDecoder._baseState.implicit) {\r\n          state.useDecoder = state.useDecoder.clone();\r\n          state.useDecoder._baseState.implicit = state.implicit;\r\n        }\r\n        return state.useDecoder;\r\n      };\r\n\r\n      Node.prototype._decodeChoice = function decodeChoice(input, options) {\r\n        var state = this._baseState;\r\n        var result = null;\r\n        var match = false;\r\n\r\n        Object.keys(state.choice).some(function (key) {\r\n          var save = input.save();\r\n          var node = state.choice[key];\r\n          try {\r\n            var value = node._decode(input, options);\r\n            if (input.isError(value))\r\n              return false;\r\n\r\n            result = {\r\n              type: key,\r\n              value: value\r\n            };\r\n            match = true;\r\n          } catch (e) {\r\n            input.restore(save);\r\n            return false;\r\n          }\r\n          return true;\r\n        }, this);\r\n\r\n        if (!match)\r\n          return input.error('Choice not matched');\r\n\r\n        return result;\r\n      };\r\n\r\n      //\r\n      // Encoding\r\n      //\r\n\r\n      Node.prototype._createEncoderBuffer = function createEncoderBuffer(data) {\r\n        return new EncoderBuffer(data, this.reporter);\r\n      };\r\n\r\n      Node.prototype._encode = function encode(data, reporter, parent) {\r\n        var state = this._baseState;\r\n        if (state['default'] !== null && state['default'] === data)\r\n          return;\r\n\r\n        var result = this._encodeValue(data, reporter, parent);\r\n        if (result === undefined)\r\n          return;\r\n\r\n        if (this._skipDefault(result, reporter, parent))\r\n          return;\r\n\r\n        return result;\r\n      };\r\n\r\n      Node.prototype._encodeValue = function encode(data, reporter, parent) {\r\n        var state = this._baseState;\r\n\r\n        // Decode root node\r\n        if (state.parent === null)\r\n          return state.children[0]._encode(data, reporter || new Reporter());\r\n\r\n        var result = null;\r\n\r\n        // Set reporter to share it with a child class\r\n        this.reporter = reporter;\r\n\r\n        // Check if data is there\r\n        if (state.optional && data === undefined) {\r\n          if (state['default'] !== null)\r\n            data = state['default']\r\n          else\r\n            return;\r\n        }\r\n\r\n        // Encode children first\r\n        var content = null;\r\n        var primitive = false;\r\n        if (state.any) {\r\n          // Anything that was given is translated to buffer\r\n          result = this._createEncoderBuffer(data);\r\n        } else if (state.choice) {\r\n          result = this._encodeChoice(data, reporter);\r\n        } else if (state.contains) {\r\n          content = this._getUse(state.contains, parent)._encode(data, reporter);\r\n          primitive = true;\r\n        } else if (state.children) {\r\n          content = state.children.map(function (child) {\r\n            if (child._baseState.tag === 'null_')\r\n              return child._encode(null, reporter, data);\r\n\r\n            if (child._baseState.key === null)\r\n              return reporter.error('Child should have a key');\r\n            var prevKey = reporter.enterKey(child._baseState.key);\r\n\r\n            if (typeof data !== 'object')\r\n              return reporter.error('Child expected, but input is not object');\r\n\r\n            var res = child._encode(data[child._baseState.key], reporter, data);\r\n            reporter.leaveKey(prevKey);\r\n\r\n            return res;\r\n          }, this).filter(function (child) {\r\n            return child;\r\n          });\r\n          content = this._createEncoderBuffer(content);\r\n        } else {\r\n          if (state.tag === 'seqof' || state.tag === 'setof') {\r\n            // TODO(indutny): this should be thrown on DSL level\r\n            if (!(state.args && state.args.length === 1))\r\n              return reporter.error('Too many args for : ' + state.tag);\r\n\r\n            if (!Array.isArray(data))\r\n              return reporter.error('seqof/setof, but data is not Array');\r\n\r\n            var child = this.clone();\r\n            child._baseState.implicit = null;\r\n            content = this._createEncoderBuffer(data.map(function (item) {\r\n              var state = this._baseState;\r\n\r\n              return this._getUse(state.args[0], data)._encode(item, reporter);\r\n            }, child));\r\n          } else if (state.use !== null) {\r\n            result = this._getUse(state.use, parent)._encode(data, reporter);\r\n          } else {\r\n            content = this._encodePrimitive(state.tag, data);\r\n            primitive = true;\r\n          }\r\n        }\r\n\r\n        // Encode data itself\r\n        var result;\r\n        if (!state.any && state.choice === null) {\r\n          var tag = state.implicit !== null ? state.implicit : state.tag;\r\n          var cls = state.implicit === null ? 'universal' : 'context';\r\n\r\n          if (tag === null) {\r\n            if (state.use === null)\r\n              reporter.error('Tag could be omitted only for .use()');\r\n          } else {\r\n            if (state.use === null)\r\n              result = this._encodeComposite(tag, primitive, cls, content);\r\n          }\r\n        }\r\n\r\n        // Wrap in explicit\r\n        if (state.explicit !== null)\r\n          result = this._encodeComposite(state.explicit, false, 'context', result);\r\n\r\n        return result;\r\n      };\r\n\r\n      Node.prototype._encodeChoice = function encodeChoice(data, reporter) {\r\n        var state = this._baseState;\r\n\r\n        var node = state.choice[data.type];\r\n        if (!node) {\r\n          assert(\r\n            false,\r\n            data.type + ' not found in ' +\r\n            JSON.stringify(Object.keys(state.choice)));\r\n        }\r\n        return node._encode(data.value, reporter);\r\n      };\r\n\r\n      Node.prototype._encodePrimitive = function encodePrimitive(tag, data) {\r\n        var state = this._baseState;\r\n\r\n        if (/str$/.test(tag))\r\n          return this._encodeStr(data, tag);\r\n        else if (tag === 'objid' && state.args)\r\n          return this._encodeObjid(data, state.reverseArgs[0], state.args[1]);\r\n        else if (tag === 'objid')\r\n          return this._encodeObjid(data, null, null);\r\n        else if (tag === 'gentime' || tag === 'utctime')\r\n          return this._encodeTime(data, tag);\r\n        else if (tag === 'null_')\r\n          return this._encodeNull();\r\n        else if (tag === 'int' || tag === 'enum')\r\n          return this._encodeInt(data, state.args && state.reverseArgs[0]);\r\n        else if (tag === 'bool')\r\n          return this._encodeBool(data);\r\n        else if (tag === 'objDesc')\r\n          return this._encodeStr(data, tag);\r\n        else\r\n          throw new Error('Unsupported tag: ' + tag);\r\n      };\r\n\r\n      Node.prototype._isNumstr = function isNumstr(str) {\r\n        return /^[0-9 ]*$/.test(str);\r\n      };\r\n\r\n      Node.prototype._isPrintstr = function isPrintstr(str) {\r\n        return /^[A-Za-z0-9 '\\(\\)\\+,\\-\\.\\/:=\\?]*$/.test(str);\r\n      };\r\n\r\n    }, {\r\n      \"../base\": 6,\r\n      \"minimalistic-assert\": 111\r\n    }],\r\n    8: [function (require, module, exports) {\r\n      var inherits = require('inherits');\r\n\r\n      function Reporter(options) {\r\n        this._reporterState = {\r\n          obj: null,\r\n          path: [],\r\n          options: options || {},\r\n          errors: []\r\n        };\r\n      }\r\n      exports.Reporter = Reporter;\r\n\r\n      Reporter.prototype.isError = function isError(obj) {\r\n        return obj instanceof ReporterError;\r\n      };\r\n\r\n      Reporter.prototype.save = function save() {\r\n        var state = this._reporterState;\r\n\r\n        return {\r\n          obj: state.obj,\r\n          pathLen: state.path.length\r\n        };\r\n      };\r\n\r\n      Reporter.prototype.restore = function restore(data) {\r\n        var state = this._reporterState;\r\n\r\n        state.obj = data.obj;\r\n        state.path = state.path.slice(0, data.pathLen);\r\n      };\r\n\r\n      Reporter.prototype.enterKey = function enterKey(key) {\r\n        return this._reporterState.path.push(key);\r\n      };\r\n\r\n      Reporter.prototype.exitKey = function exitKey(index) {\r\n        var state = this._reporterState;\r\n\r\n        state.path = state.path.slice(0, index - 1);\r\n      };\r\n\r\n      Reporter.prototype.leaveKey = function leaveKey(index, key, value) {\r\n        var state = this._reporterState;\r\n\r\n        this.exitKey(index);\r\n        if (state.obj !== null)\r\n          state.obj[key] = value;\r\n      };\r\n\r\n      Reporter.prototype.path = function path() {\r\n        return this._reporterState.path.join('/');\r\n      };\r\n\r\n      Reporter.prototype.enterObject = function enterObject() {\r\n        var state = this._reporterState;\r\n\r\n        var prev = state.obj;\r\n        state.obj = {};\r\n        return prev;\r\n      };\r\n\r\n      Reporter.prototype.leaveObject = function leaveObject(prev) {\r\n        var state = this._reporterState;\r\n\r\n        var now = state.obj;\r\n        state.obj = prev;\r\n        return now;\r\n      };\r\n\r\n      Reporter.prototype.error = function error(msg) {\r\n        var err;\r\n        var state = this._reporterState;\r\n\r\n        var inherited = msg instanceof ReporterError;\r\n        if (inherited) {\r\n          err = msg;\r\n        } else {\r\n          err = new ReporterError(state.path.map(function (elem) {\r\n            return '[' + JSON.stringify(elem) + ']';\r\n          }).join(''), msg.message || msg, msg.stack);\r\n        }\r\n\r\n        if (!state.options.partial)\r\n          throw err;\r\n\r\n        if (!inherited)\r\n          state.errors.push(err);\r\n\r\n        return err;\r\n      };\r\n\r\n      Reporter.prototype.wrapResult = function wrapResult(result) {\r\n        var state = this._reporterState;\r\n        if (!state.options.partial)\r\n          return result;\r\n\r\n        return {\r\n          result: this.isError(result) ? null : result,\r\n          errors: state.errors\r\n        };\r\n      };\r\n\r\n      function ReporterError(path, msg) {\r\n        this.path = path;\r\n        this.rethrow(msg);\r\n      };\r\n      inherits(ReporterError, Error);\r\n\r\n      ReporterError.prototype.rethrow = function rethrow(msg) {\r\n        this.message = msg + ' at: ' + (this.path || '(shallow)');\r\n        if (Error.captureStackTrace)\r\n          Error.captureStackTrace(this, ReporterError);\r\n\r\n        if (!this.stack) {\r\n          try {\r\n            // IE only adds stack when thrown\r\n            throw new Error(this.message);\r\n          } catch (e) {\r\n            this.stack = e.stack;\r\n          }\r\n        }\r\n        return this;\r\n      };\r\n\r\n    }, {\r\n      \"inherits\": 106\r\n    }],\r\n    9: [function (require, module, exports) {\r\n      var constants = require('../constants');\r\n\r\n      exports.tagClass = {\r\n        0: 'universal',\r\n        1: 'application',\r\n        2: 'context',\r\n        3: 'private'\r\n      };\r\n      exports.tagClassByName = constants._reverse(exports.tagClass);\r\n\r\n      exports.tag = {\r\n        0x00: 'end',\r\n        0x01: 'bool',\r\n        0x02: 'int',\r\n        0x03: 'bitstr',\r\n        0x04: 'octstr',\r\n        0x05: 'null_',\r\n        0x06: 'objid',\r\n        0x07: 'objDesc',\r\n        0x08: 'external',\r\n        0x09: 'real',\r\n        0x0a: 'enum',\r\n        0x0b: 'embed',\r\n        0x0c: 'utf8str',\r\n        0x0d: 'relativeOid',\r\n        0x10: 'seq',\r\n        0x11: 'set',\r\n        0x12: 'numstr',\r\n        0x13: 'printstr',\r\n        0x14: 't61str',\r\n        0x15: 'videostr',\r\n        0x16: 'ia5str',\r\n        0x17: 'utctime',\r\n        0x18: 'gentime',\r\n        0x19: 'graphstr',\r\n        0x1a: 'iso646str',\r\n        0x1b: 'genstr',\r\n        0x1c: 'unistr',\r\n        0x1d: 'charstr',\r\n        0x1e: 'bmpstr'\r\n      };\r\n      exports.tagByName = constants._reverse(exports.tag);\r\n\r\n    }, {\r\n      \"../constants\": 10\r\n    }],\r\n    10: [function (require, module, exports) {\r\n      var constants = exports;\r\n\r\n      // Helper\r\n      constants._reverse = function reverse(map) {\r\n        var res = {};\r\n\r\n        Object.keys(map).forEach(function (key) {\r\n          // Convert key to integer if it is stringified\r\n          if ((key | 0) == key)\r\n            key = key | 0;\r\n\r\n          var value = map[key];\r\n          res[value] = key;\r\n        });\r\n\r\n        return res;\r\n      };\r\n\r\n      constants.der = require('./der');\r\n\r\n    }, {\r\n      \"./der\": 9\r\n    }],\r\n    11: [function (require, module, exports) {\r\n      var inherits = require('inherits');\r\n\r\n      var asn1 = require('../../asn1');\r\n      var base = asn1.base;\r\n      var bignum = asn1.bignum;\r\n\r\n      // Import DER constants\r\n      var der = asn1.constants.der;\r\n\r\n      function DERDecoder(entity) {\r\n        this.enc = 'der';\r\n        this.name = entity.name;\r\n        this.entity = entity;\r\n\r\n        // Construct base tree\r\n        this.tree = new DERNode();\r\n        this.tree._init(entity.body);\r\n      };\r\n      module.exports = DERDecoder;\r\n\r\n      DERDecoder.prototype.decode = function decode(data, options) {\r\n        if (!(data instanceof base.DecoderBuffer))\r\n          data = new base.DecoderBuffer(data, options);\r\n\r\n        return this.tree._decode(data, options);\r\n      };\r\n\r\n      // Tree methods\r\n\r\n      function DERNode(parent) {\r\n        base.Node.call(this, 'der', parent);\r\n      }\r\n      inherits(DERNode, base.Node);\r\n\r\n      DERNode.prototype._peekTag = function peekTag(buffer, tag, any) {\r\n        if (buffer.isEmpty())\r\n          return false;\r\n\r\n        var state = buffer.save();\r\n        var decodedTag = derDecodeTag(buffer, 'Failed to peek tag: \"' + tag + '\"');\r\n        if (buffer.isError(decodedTag))\r\n          return decodedTag;\r\n\r\n        buffer.restore(state);\r\n\r\n        return decodedTag.tag === tag || decodedTag.tagStr === tag ||\r\n          (decodedTag.tagStr + 'of') === tag || any;\r\n      };\r\n\r\n      DERNode.prototype._decodeTag = function decodeTag(buffer, tag, any) {\r\n        var decodedTag = derDecodeTag(buffer,\r\n          'Failed to decode tag of \"' + tag + '\"');\r\n        if (buffer.isError(decodedTag))\r\n          return decodedTag;\r\n\r\n        var len = derDecodeLen(buffer,\r\n          decodedTag.primitive,\r\n          'Failed to get length of \"' + tag + '\"');\r\n\r\n        // Failure\r\n        if (buffer.isError(len))\r\n          return len;\r\n\r\n        if (!any &&\r\n          decodedTag.tag !== tag &&\r\n          decodedTag.tagStr !== tag &&\r\n          decodedTag.tagStr + 'of' !== tag) {\r\n          return buffer.error('Failed to match tag: \"' + tag + '\"');\r\n        }\r\n\r\n        if (decodedTag.primitive || len !== null)\r\n          return buffer.skip(len, 'Failed to match body of: \"' + tag + '\"');\r\n\r\n        // Indefinite length... find END tag\r\n        var state = buffer.save();\r\n        var res = this._skipUntilEnd(\r\n          buffer,\r\n          'Failed to skip indefinite length body: \"' + this.tag + '\"');\r\n        if (buffer.isError(res))\r\n          return res;\r\n\r\n        len = buffer.offset - state.offset;\r\n        buffer.restore(state);\r\n        return buffer.skip(len, 'Failed to match body of: \"' + tag + '\"');\r\n      };\r\n\r\n      DERNode.prototype._skipUntilEnd = function skipUntilEnd(buffer, fail) {\r\n        while (true) {\r\n          var tag = derDecodeTag(buffer, fail);\r\n          if (buffer.isError(tag))\r\n            return tag;\r\n          var len = derDecodeLen(buffer, tag.primitive, fail);\r\n          if (buffer.isError(len))\r\n            return len;\r\n\r\n          var res;\r\n          if (tag.primitive || len !== null)\r\n            res = buffer.skip(len)\r\n          else\r\n            res = this._skipUntilEnd(buffer, fail);\r\n\r\n          // Failure\r\n          if (buffer.isError(res))\r\n            return res;\r\n\r\n          if (tag.tagStr === 'end')\r\n            break;\r\n        }\r\n      };\r\n\r\n      DERNode.prototype._decodeList = function decodeList(buffer, tag, decoder,\r\n        options) {\r\n        var result = [];\r\n        while (!buffer.isEmpty()) {\r\n          var possibleEnd = this._peekTag(buffer, 'end');\r\n          if (buffer.isError(possibleEnd))\r\n            return possibleEnd;\r\n\r\n          var res = decoder.decode(buffer, 'der', options);\r\n          if (buffer.isError(res) && possibleEnd)\r\n            break;\r\n          result.push(res);\r\n        }\r\n        return result;\r\n      };\r\n\r\n      DERNode.prototype._decodeStr = function decodeStr(buffer, tag) {\r\n        if (tag === 'bitstr') {\r\n          var unused = buffer.readUInt8();\r\n          if (buffer.isError(unused))\r\n            return unused;\r\n          return {\r\n            unused: unused,\r\n            data: buffer.raw()\r\n          };\r\n        } else if (tag === 'bmpstr') {\r\n          var raw = buffer.raw();\r\n          if (raw.length % 2 === 1)\r\n            return buffer.error('Decoding of string type: bmpstr length mismatch');\r\n\r\n          var str = '';\r\n          for (var i = 0; i < raw.length / 2; i++) {\r\n            str += String.fromCharCode(raw.readUInt16BE(i * 2));\r\n          }\r\n          return str;\r\n        } else if (tag === 'numstr') {\r\n          var numstr = buffer.raw().toString('ascii');\r\n          if (!this._isNumstr(numstr)) {\r\n            return buffer.error('Decoding of string type: ' +\r\n              'numstr unsupported characters');\r\n          }\r\n          return numstr;\r\n        } else if (tag === 'octstr') {\r\n          return buffer.raw();\r\n        } else if (tag === 'objDesc') {\r\n          return buffer.raw();\r\n        } else if (tag === 'printstr') {\r\n          var printstr = buffer.raw().toString('ascii');\r\n          if (!this._isPrintstr(printstr)) {\r\n            return buffer.error('Decoding of string type: ' +\r\n              'printstr unsupported characters');\r\n          }\r\n          return printstr;\r\n        } else if (/str$/.test(tag)) {\r\n          return buffer.raw().toString();\r\n        } else {\r\n          return buffer.error('Decoding of string type: ' + tag + ' unsupported');\r\n        }\r\n      };\r\n\r\n      DERNode.prototype._decodeObjid = function decodeObjid(buffer, values, relative) {\r\n        var result;\r\n        var identifiers = [];\r\n        var ident = 0;\r\n        while (!buffer.isEmpty()) {\r\n          var subident = buffer.readUInt8();\r\n          ident <<= 7;\r\n          ident |= subident & 0x7f;\r\n          if ((subident & 0x80) === 0) {\r\n            identifiers.push(ident);\r\n            ident = 0;\r\n          }\r\n        }\r\n        if (subident & 0x80)\r\n          identifiers.push(ident);\r\n\r\n        var first = (identifiers[0] / 40) | 0;\r\n        var second = identifiers[0] % 40;\r\n\r\n        if (relative)\r\n          result = identifiers;\r\n        else\r\n          result = [first, second].concat(identifiers.slice(1));\r\n\r\n        if (values) {\r\n          var tmp = values[result.join(' ')];\r\n          if (tmp === undefined)\r\n            tmp = values[result.join('.')];\r\n          if (tmp !== undefined)\r\n            result = tmp;\r\n        }\r\n\r\n        return result;\r\n      };\r\n\r\n      DERNode.prototype._decodeTime = function decodeTime(buffer, tag) {\r\n        var str = buffer.raw().toString();\r\n        if (tag === 'gentime') {\r\n          var year = str.slice(0, 4) | 0;\r\n          var mon = str.slice(4, 6) | 0;\r\n          var day = str.slice(6, 8) | 0;\r\n          var hour = str.slice(8, 10) | 0;\r\n          var min = str.slice(10, 12) | 0;\r\n          var sec = str.slice(12, 14) | 0;\r\n        } else if (tag === 'utctime') {\r\n          var year = str.slice(0, 2) | 0;\r\n          var mon = str.slice(2, 4) | 0;\r\n          var day = str.slice(4, 6) | 0;\r\n          var hour = str.slice(6, 8) | 0;\r\n          var min = str.slice(8, 10) | 0;\r\n          var sec = str.slice(10, 12) | 0;\r\n          if (year < 70)\r\n            year = 2000 + year;\r\n          else\r\n            year = 1900 + year;\r\n        } else {\r\n          return buffer.error('Decoding ' + tag + ' time is not supported yet');\r\n        }\r\n\r\n        return Date.UTC(year, mon - 1, day, hour, min, sec, 0);\r\n      };\r\n\r\n      DERNode.prototype._decodeNull = function decodeNull(buffer) {\r\n        return null;\r\n      };\r\n\r\n      DERNode.prototype._decodeBool = function decodeBool(buffer) {\r\n        var res = buffer.readUInt8();\r\n        if (buffer.isError(res))\r\n          return res;\r\n        else\r\n          return res !== 0;\r\n      };\r\n\r\n      DERNode.prototype._decodeInt = function decodeInt(buffer, values) {\r\n        // Bigint, return as it is (assume big endian)\r\n        var raw = buffer.raw();\r\n        var res = new bignum(raw);\r\n\r\n        if (values)\r\n          res = values[res.toString(10)] || res;\r\n\r\n        return res;\r\n      };\r\n\r\n      DERNode.prototype._use = function use(entity, obj) {\r\n        if (typeof entity === 'function')\r\n          entity = entity(obj);\r\n        return entity._getDecoder('der').tree;\r\n      };\r\n\r\n      // Utility methods\r\n\r\n      function derDecodeTag(buf, fail) {\r\n        var tag = buf.readUInt8(fail);\r\n        if (buf.isError(tag))\r\n          return tag;\r\n\r\n        var cls = der.tagClass[tag >> 6];\r\n        var primitive = (tag & 0x20) === 0;\r\n\r\n        // Multi-octet tag - load\r\n        if ((tag & 0x1f) === 0x1f) {\r\n          var oct = tag;\r\n          tag = 0;\r\n          while ((oct & 0x80) === 0x80) {\r\n            oct = buf.readUInt8(fail);\r\n            if (buf.isError(oct))\r\n              return oct;\r\n\r\n            tag <<= 7;\r\n            tag |= oct & 0x7f;\r\n          }\r\n        } else {\r\n          tag &= 0x1f;\r\n        }\r\n        var tagStr = der.tag[tag];\r\n\r\n        return {\r\n          cls: cls,\r\n          primitive: primitive,\r\n          tag: tag,\r\n          tagStr: tagStr\r\n        };\r\n      }\r\n\r\n      function derDecodeLen(buf, primitive, fail) {\r\n        var len = buf.readUInt8(fail);\r\n        if (buf.isError(len))\r\n          return len;\r\n\r\n        // Indefinite form\r\n        if (!primitive && len === 0x80)\r\n          return null;\r\n\r\n        // Definite form\r\n        if ((len & 0x80) === 0) {\r\n          // Short form\r\n          return len;\r\n        }\r\n\r\n        // Long form\r\n        var num = len & 0x7f;\r\n        if (num > 4)\r\n          return buf.error('length octect is too long');\r\n\r\n        len = 0;\r\n        for (var i = 0; i < num; i++) {\r\n          len <<= 8;\r\n          var j = buf.readUInt8(fail);\r\n          if (buf.isError(j))\r\n            return j;\r\n          len |= j;\r\n        }\r\n\r\n        return len;\r\n      }\r\n\r\n    }, {\r\n      \"../../asn1\": 3,\r\n      \"inherits\": 106\r\n    }],\r\n    12: [function (require, module, exports) {\r\n      var decoders = exports;\r\n\r\n      decoders.der = require('./der');\r\n      decoders.pem = require('./pem');\r\n\r\n    }, {\r\n      \"./der\": 11,\r\n      \"./pem\": 13\r\n    }],\r\n    13: [function (require, module, exports) {\r\n      var inherits = require('inherits');\r\n      var Buffer = require('buffer').Buffer;\r\n\r\n      var DERDecoder = require('./der');\r\n\r\n      function PEMDecoder(entity) {\r\n        DERDecoder.call(this, entity);\r\n        this.enc = 'pem';\r\n      };\r\n      inherits(PEMDecoder, DERDecoder);\r\n      module.exports = PEMDecoder;\r\n\r\n      PEMDecoder.prototype.decode = function decode(data, options) {\r\n        var lines = data.toString().split(/[\\r\\n]+/g);\r\n\r\n        var label = options.label.toUpperCase();\r\n\r\n        var re = /^-----(BEGIN|END) ([^-]+)-----$/;\r\n        var start = -1;\r\n        var end = -1;\r\n        for (var i = 0; i < lines.length; i++) {\r\n          var match = lines[i].match(re);\r\n          if (match === null)\r\n            continue;\r\n\r\n          if (match[2] !== label)\r\n            continue;\r\n\r\n          if (start === -1) {\r\n            if (match[1] !== 'BEGIN')\r\n              break;\r\n            start = i;\r\n          } else {\r\n            if (match[1] !== 'END')\r\n              break;\r\n            end = i;\r\n            break;\r\n          }\r\n        }\r\n        if (start === -1 || end === -1)\r\n          throw new Error('PEM section not found for: ' + label);\r\n\r\n        var base64 = lines.slice(start + 1, end).join('');\r\n        // Remove excessive symbols\r\n        base64.replace(/[^a-z0-9\\+\\/=]+/gi, '');\r\n\r\n        var input = new Buffer(base64, 'base64');\r\n        return DERDecoder.prototype.decode.call(this, input, options);\r\n      };\r\n\r\n    }, {\r\n      \"./der\": 11,\r\n      \"buffer\": 54,\r\n      \"inherits\": 106\r\n    }],\r\n    14: [function (require, module, exports) {\r\n      var inherits = require('inherits');\r\n      var Buffer = require('buffer').Buffer;\r\n\r\n      var asn1 = require('../../asn1');\r\n      var base = asn1.base;\r\n\r\n      // Import DER constants\r\n      var der = asn1.constants.der;\r\n\r\n      function DEREncoder(entity) {\r\n        this.enc = 'der';\r\n        this.name = entity.name;\r\n        this.entity = entity;\r\n\r\n        // Construct base tree\r\n        this.tree = new DERNode();\r\n        this.tree._init(entity.body);\r\n      };\r\n      module.exports = DEREncoder;\r\n\r\n      DEREncoder.prototype.encode = function encode(data, reporter) {\r\n        return this.tree._encode(data, reporter).join();\r\n      };\r\n\r\n      // Tree methods\r\n\r\n      function DERNode(parent) {\r\n        base.Node.call(this, 'der', parent);\r\n      }\r\n      inherits(DERNode, base.Node);\r\n\r\n      DERNode.prototype._encodeComposite = function encodeComposite(tag,\r\n        primitive,\r\n        cls,\r\n        content) {\r\n        var encodedTag = encodeTag(tag, primitive, cls, this.reporter);\r\n\r\n        // Short form\r\n        if (content.length < 0x80) {\r\n          var header = new Buffer(2);\r\n          header[0] = encodedTag;\r\n          header[1] = content.length;\r\n          return this._createEncoderBuffer([header, content]);\r\n        }\r\n\r\n        // Long form\r\n        // Count octets required to store length\r\n        var lenOctets = 1;\r\n        for (var i = content.length; i >= 0x100; i >>= 8)\r\n          lenOctets++;\r\n\r\n        var header = new Buffer(1 + 1 + lenOctets);\r\n        header[0] = encodedTag;\r\n        header[1] = 0x80 | lenOctets;\r\n\r\n        for (var i = 1 + lenOctets, j = content.length; j > 0; i--, j >>= 8)\r\n          header[i] = j & 0xff;\r\n\r\n        return this._createEncoderBuffer([header, content]);\r\n      };\r\n\r\n      DERNode.prototype._encodeStr = function encodeStr(str, tag) {\r\n        if (tag === 'bitstr') {\r\n          return this._createEncoderBuffer([str.unused | 0, str.data]);\r\n        } else if (tag === 'bmpstr') {\r\n          var buf = new Buffer(str.length * 2);\r\n          for (var i = 0; i < str.length; i++) {\r\n            buf.writeUInt16BE(str.charCodeAt(i), i * 2);\r\n          }\r\n          return this._createEncoderBuffer(buf);\r\n        } else if (tag === 'numstr') {\r\n          if (!this._isNumstr(str)) {\r\n            return this.reporter.error('Encoding of string type: numstr supports ' +\r\n              'only digits and space');\r\n          }\r\n          return this._createEncoderBuffer(str);\r\n        } else if (tag === 'printstr') {\r\n          if (!this._isPrintstr(str)) {\r\n            return this.reporter.error('Encoding of string type: printstr supports ' +\r\n              'only latin upper and lower case letters, ' +\r\n              'digits, space, apostrophe, left and rigth ' +\r\n              'parenthesis, plus sign, comma, hyphen, ' +\r\n              'dot, slash, colon, equal sign, ' +\r\n              'question mark');\r\n          }\r\n          return this._createEncoderBuffer(str);\r\n        } else if (/str$/.test(tag)) {\r\n          return this._createEncoderBuffer(str);\r\n        } else if (tag === 'objDesc') {\r\n          return this._createEncoderBuffer(str);\r\n        } else {\r\n          return this.reporter.error('Encoding of string type: ' + tag +\r\n            ' unsupported');\r\n        }\r\n      };\r\n\r\n      DERNode.prototype._encodeObjid = function encodeObjid(id, values, relative) {\r\n        if (typeof id === 'string') {\r\n          if (!values)\r\n            return this.reporter.error('string objid given, but no values map found');\r\n          if (!values.hasOwnProperty(id))\r\n            return this.reporter.error('objid not found in values map');\r\n          id = values[id].split(/[\\s\\.]+/g);\r\n          for (var i = 0; i < id.length; i++)\r\n            id[i] |= 0;\r\n        } else if (Array.isArray(id)) {\r\n          id = id.slice();\r\n          for (var i = 0; i < id.length; i++)\r\n            id[i] |= 0;\r\n        }\r\n\r\n        if (!Array.isArray(id)) {\r\n          return this.reporter.error('objid() should be either array or string, ' +\r\n            'got: ' + JSON.stringify(id));\r\n        }\r\n\r\n        if (!relative) {\r\n          if (id[1] >= 40)\r\n            return this.reporter.error('Second objid identifier OOB');\r\n          id.splice(0, 2, id[0] * 40 + id[1]);\r\n        }\r\n\r\n        // Count number of octets\r\n        var size = 0;\r\n        for (var i = 0; i < id.length; i++) {\r\n          var ident = id[i];\r\n          for (size++; ident >= 0x80; ident >>= 7)\r\n            size++;\r\n        }\r\n\r\n        var objid = new Buffer(size);\r\n        var offset = objid.length - 1;\r\n        for (var i = id.length - 1; i >= 0; i--) {\r\n          var ident = id[i];\r\n          objid[offset--] = ident & 0x7f;\r\n          while ((ident >>= 7) > 0)\r\n            objid[offset--] = 0x80 | (ident & 0x7f);\r\n        }\r\n\r\n        return this._createEncoderBuffer(objid);\r\n      };\r\n\r\n      function two(num) {\r\n        if (num < 10)\r\n          return '0' + num;\r\n        else\r\n          return num;\r\n      }\r\n\r\n      DERNode.prototype._encodeTime = function encodeTime(time, tag) {\r\n        var str;\r\n        var date = new Date(time);\r\n\r\n        if (tag === 'gentime') {\r\n          str = [\r\n            two(date.getFullYear()),\r\n            two(date.getUTCMonth() + 1),\r\n            two(date.getUTCDate()),\r\n            two(date.getUTCHours()),\r\n            two(date.getUTCMinutes()),\r\n            two(date.getUTCSeconds()),\r\n            'Z'\r\n          ].join('');\r\n        } else if (tag === 'utctime') {\r\n          str = [\r\n            two(date.getFullYear() % 100),\r\n            two(date.getUTCMonth() + 1),\r\n            two(date.getUTCDate()),\r\n            two(date.getUTCHours()),\r\n            two(date.getUTCMinutes()),\r\n            two(date.getUTCSeconds()),\r\n            'Z'\r\n          ].join('');\r\n        } else {\r\n          this.reporter.error('Encoding ' + tag + ' time is not supported yet');\r\n        }\r\n\r\n        return this._encodeStr(str, 'octstr');\r\n      };\r\n\r\n      DERNode.prototype._encodeNull = function encodeNull() {\r\n        return this._createEncoderBuffer('');\r\n      };\r\n\r\n      DERNode.prototype._encodeInt = function encodeInt(num, values) {\r\n        if (typeof num === 'string') {\r\n          if (!values)\r\n            return this.reporter.error('String int or enum given, but no values map');\r\n          if (!values.hasOwnProperty(num)) {\r\n            return this.reporter.error('Values map doesn\\'t contain: ' +\r\n              JSON.stringify(num));\r\n          }\r\n          num = values[num];\r\n        }\r\n\r\n        // Bignum, assume big endian\r\n        if (typeof num !== 'number' && !Buffer.isBuffer(num)) {\r\n          var numArray = num.toArray();\r\n          if (!num.sign && numArray[0] & 0x80) {\r\n            numArray.unshift(0);\r\n          }\r\n          num = new Buffer(numArray);\r\n        }\r\n\r\n        if (Buffer.isBuffer(num)) {\r\n          var size = num.length;\r\n          if (num.length === 0)\r\n            size++;\r\n\r\n          var out = new Buffer(size);\r\n          num.copy(out);\r\n          if (num.length === 0)\r\n            out[0] = 0\r\n          return this._createEncoderBuffer(out);\r\n        }\r\n\r\n        if (num < 0x80)\r\n          return this._createEncoderBuffer(num);\r\n\r\n        if (num < 0x100)\r\n          return this._createEncoderBuffer([0, num]);\r\n\r\n        var size = 1;\r\n        for (var i = num; i >= 0x100; i >>= 8)\r\n          size++;\r\n\r\n        var out = new Array(size);\r\n        for (var i = out.length - 1; i >= 0; i--) {\r\n          out[i] = num & 0xff;\r\n          num >>= 8;\r\n        }\r\n        if (out[0] & 0x80) {\r\n          out.unshift(0);\r\n        }\r\n\r\n        return this._createEncoderBuffer(new Buffer(out));\r\n      };\r\n\r\n      DERNode.prototype._encodeBool = function encodeBool(value) {\r\n        return this._createEncoderBuffer(value ? 0xff : 0);\r\n      };\r\n\r\n      DERNode.prototype._use = function use(entity, obj) {\r\n        if (typeof entity === 'function')\r\n          entity = entity(obj);\r\n        return entity._getEncoder('der').tree;\r\n      };\r\n\r\n      DERNode.prototype._skipDefault = function skipDefault(dataBuffer, reporter, parent) {\r\n        var state = this._baseState;\r\n        var i;\r\n        if (state['default'] === null)\r\n          return false;\r\n\r\n        var data = dataBuffer.join();\r\n        if (state.defaultBuffer === undefined)\r\n          state.defaultBuffer = this._encodeValue(state['default'], reporter, parent).join();\r\n\r\n        if (data.length !== state.defaultBuffer.length)\r\n          return false;\r\n\r\n        for (i = 0; i < data.length; i++)\r\n          if (data[i] !== state.defaultBuffer[i])\r\n            return false;\r\n\r\n        return true;\r\n      };\r\n\r\n      // Utility methods\r\n\r\n      function encodeTag(tag, primitive, cls, reporter) {\r\n        var res;\r\n\r\n        if (tag === 'seqof')\r\n          tag = 'seq';\r\n        else if (tag === 'setof')\r\n          tag = 'set';\r\n\r\n        if (der.tagByName.hasOwnProperty(tag))\r\n          res = der.tagByName[tag];\r\n        else if (typeof tag === 'number' && (tag | 0) === tag)\r\n          res = tag;\r\n        else\r\n          return reporter.error('Unknown tag: ' + tag);\r\n\r\n        if (res >= 0x1f)\r\n          return reporter.error('Multi-octet tag encoding unsupported');\r\n\r\n        if (!primitive)\r\n          res |= 0x20;\r\n\r\n        res |= (der.tagClassByName[cls || 'universal'] << 6);\r\n\r\n        return res;\r\n      }\r\n\r\n    }, {\r\n      \"../../asn1\": 3,\r\n      \"buffer\": 54,\r\n      \"inherits\": 106\r\n    }],\r\n    15: [function (require, module, exports) {\r\n      var encoders = exports;\r\n\r\n      encoders.der = require('./der');\r\n      encoders.pem = require('./pem');\r\n\r\n    }, {\r\n      \"./der\": 14,\r\n      \"./pem\": 16\r\n    }],\r\n    16: [function (require, module, exports) {\r\n      var inherits = require('inherits');\r\n\r\n      var DEREncoder = require('./der');\r\n\r\n      function PEMEncoder(entity) {\r\n        DEREncoder.call(this, entity);\r\n        this.enc = 'pem';\r\n      };\r\n      inherits(PEMEncoder, DEREncoder);\r\n      module.exports = PEMEncoder;\r\n\r\n      PEMEncoder.prototype.encode = function encode(data, options) {\r\n        var buf = DEREncoder.prototype.encode.call(this, data);\r\n\r\n        var p = buf.toString('base64');\r\n        var out = ['-----BEGIN ' + options.label + '-----'];\r\n        for (var i = 0; i < p.length; i += 64)\r\n          out.push(p.slice(i, i + 64));\r\n        out.push('-----END ' + options.label + '-----');\r\n        return out.join('\\n');\r\n      };\r\n\r\n    }, {\r\n      \"./der\": 14,\r\n      \"inherits\": 106\r\n    }],\r\n    17: [function (require, module, exports) {\r\n      (function (global) {\r\n        'use strict';\r\n\r\n        // compare and isBuffer taken from https://github.com/feross/buffer/blob/680e9e5e488f22aac27599a57dc844a6315928dd/index.js\r\n        // original notice:\r\n\r\n        /*!\r\n         * The buffer module from node.js, for the browser.\r\n         *\r\n         * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>\r\n         * @license  MIT\r\n         */\r\n        function compare(a, b) {\r\n          if (a === b) {\r\n            return 0;\r\n          }\r\n\r\n          var x = a.length;\r\n          var y = b.length;\r\n\r\n          for (var i = 0, len = Math.min(x, y); i < len; ++i) {\r\n            if (a[i] !== b[i]) {\r\n              x = a[i];\r\n              y = b[i];\r\n              break;\r\n            }\r\n          }\r\n\r\n          if (x < y) {\r\n            return -1;\r\n          }\r\n          if (y < x) {\r\n            return 1;\r\n          }\r\n          return 0;\r\n        }\r\n\r\n        function isBuffer(b) {\r\n          if (global.Buffer && typeof global.Buffer.isBuffer === 'function') {\r\n            return global.Buffer.isBuffer(b);\r\n          }\r\n          return !!(b != null && b._isBuffer);\r\n        }\r\n\r\n        // based on node assert, original notice:\r\n\r\n        // http://wiki.commonjs.org/wiki/Unit_Testing/1.0\r\n        //\r\n        // THIS IS NOT TESTED NOR LIKELY TO WORK OUTSIDE V8!\r\n        //\r\n        // Originally from narwhal.js (http://narwhaljs.org)\r\n        // Copyright (c) 2009 Thomas Robinson <280north.com>\r\n        //\r\n        // Permission is hereby granted, free of charge, to any person obtaining a copy\r\n        // of this software and associated documentation files (the 'Software'), to\r\n        // deal in the Software without restriction, including without limitation the\r\n        // rights to use, copy, modify, merge, publish, distribute, sublicense, and/or\r\n        // sell copies of the Software, and to permit persons to whom the Software is\r\n        // furnished to do so, subject to the following conditions:\r\n        //\r\n        // The above copyright notice and this permission notice shall be included in\r\n        // all copies or substantial portions of the Software.\r\n        //\r\n        // THE SOFTWARE IS PROVIDED 'AS IS', WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\n        // IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\r\n        // FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\n        // AUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN\r\n        // ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION\r\n        // WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\r\n\r\n        var util = require('util/');\r\n        var hasOwn = Object.prototype.hasOwnProperty;\r\n        var pSlice = Array.prototype.slice;\r\n        var functionsHaveNames = (function () {\r\n          return function foo() {}.name === 'foo';\r\n        }());\r\n\r\n        function pToString(obj) {\r\n          return Object.prototype.toString.call(obj);\r\n        }\r\n\r\n        function isView(arrbuf) {\r\n          if (isBuffer(arrbuf)) {\r\n            return false;\r\n          }\r\n          if (typeof global.ArrayBuffer !== 'function') {\r\n            return false;\r\n          }\r\n          if (typeof ArrayBuffer.isView === 'function') {\r\n            return ArrayBuffer.isView(arrbuf);\r\n          }\r\n          if (!arrbuf) {\r\n            return false;\r\n          }\r\n          if (arrbuf instanceof DataView) {\r\n            return true;\r\n          }\r\n          if (arrbuf.buffer && arrbuf.buffer instanceof ArrayBuffer) {\r\n            return true;\r\n          }\r\n          return false;\r\n        }\r\n        // 1. The assert module provides functions that throw\r\n        // AssertionError's when particular conditions are not met. The\r\n        // assert module must conform to the following interface.\r\n\r\n        var assert = module.exports = ok;\r\n\r\n        // 2. The AssertionError is defined in assert.\r\n        // new assert.AssertionError({ message: message,\r\n        //                             actual: actual,\r\n        //                             expected: expected })\r\n\r\n        var regex = /\\s*function\\s+([^\\(\\s]*)\\s*/;\r\n        // based on https://github.com/ljharb/function.prototype.name/blob/adeeeec8bfcc6068b187d7d9fb3d5bb1d3a30899/implementation.js\r\n        function getName(func) {\r\n          if (!util.isFunction(func)) {\r\n            return;\r\n          }\r\n          if (functionsHaveNames) {\r\n            return func.name;\r\n          }\r\n          var str = func.toString();\r\n          var match = str.match(regex);\r\n          return match && match[1];\r\n        }\r\n        assert.AssertionError = function AssertionError(options) {\r\n          this.name = 'AssertionError';\r\n          this.actual = options.actual;\r\n          this.expected = options.expected;\r\n          this.operator = options.operator;\r\n          if (options.message) {\r\n            this.message = options.message;\r\n            this.generatedMessage = false;\r\n          } else {\r\n            this.message = getMessage(this);\r\n            this.generatedMessage = true;\r\n          }\r\n          var stackStartFunction = options.stackStartFunction || fail;\r\n          if (Error.captureStackTrace) {\r\n            Error.captureStackTrace(this, stackStartFunction);\r\n          } else {\r\n            // non v8 browsers so we can have a stacktrace\r\n            var err = new Error();\r\n            if (err.stack) {\r\n              var out = err.stack;\r\n\r\n              // try to strip useless frames\r\n              var fn_name = getName(stackStartFunction);\r\n              var idx = out.indexOf('\\n' + fn_name);\r\n              if (idx >= 0) {\r\n                // once we have located the function frame\r\n                // we need to strip out everything before it (and its line)\r\n                var next_line = out.indexOf('\\n', idx + 1);\r\n                out = out.substring(next_line + 1);\r\n              }\r\n\r\n              this.stack = out;\r\n            }\r\n          }\r\n        };\r\n\r\n        // assert.AssertionError instanceof Error\r\n        util.inherits(assert.AssertionError, Error);\r\n\r\n        function truncate(s, n) {\r\n          if (typeof s === 'string') {\r\n            return s.length < n ? s : s.slice(0, n);\r\n          } else {\r\n            return s;\r\n          }\r\n        }\r\n\r\n        function inspect(something) {\r\n          if (functionsHaveNames || !util.isFunction(something)) {\r\n            return util.inspect(something);\r\n          }\r\n          var rawname = getName(something);\r\n          var name = rawname ? ': ' + rawname : '';\r\n          return '[Function' + name + ']';\r\n        }\r\n\r\n        function getMessage(self) {\r\n          return truncate(inspect(self.actual), 128) + ' ' +\r\n            self.operator + ' ' +\r\n            truncate(inspect(self.expected), 128);\r\n        }\r\n\r\n        // At present only the three keys mentioned above are used and\r\n        // understood by the spec. Implementations or sub modules can pass\r\n        // other keys to the AssertionError's constructor - they will be\r\n        // ignored.\r\n\r\n        // 3. All of the following functions must throw an AssertionError\r\n        // when a corresponding condition is not met, with a message that\r\n        // may be undefined if not provided.  All assertion methods provide\r\n        // both the actual and expected values to the assertion error for\r\n        // display purposes.\r\n\r\n        function fail(actual, expected, message, operator, stackStartFunction) {\r\n          throw new assert.AssertionError({\r\n            message: message,\r\n            actual: actual,\r\n            expected: expected,\r\n            operator: operator,\r\n            stackStartFunction: stackStartFunction\r\n          });\r\n        }\r\n\r\n        // EXTENSION! allows for well behaved errors defined elsewhere.\r\n        assert.fail = fail;\r\n\r\n        // 4. Pure assertion tests whether a value is truthy, as determined\r\n        // by !!guard.\r\n        // assert.ok(guard, message_opt);\r\n        // This statement is equivalent to assert.equal(true, !!guard,\r\n        // message_opt);. To test strictly for the value true, use\r\n        // assert.strictEqual(true, guard, message_opt);.\r\n\r\n        function ok(value, message) {\r\n          if (!value) fail(value, true, message, '==', assert.ok);\r\n        }\r\n        assert.ok = ok;\r\n\r\n        // 5. The equality assertion tests shallow, coercive equality with\r\n        // ==.\r\n        // assert.equal(actual, expected, message_opt);\r\n\r\n        assert.equal = function equal(actual, expected, message) {\r\n          if (actual != expected) fail(actual, expected, message, '==', assert.equal);\r\n        };\r\n\r\n        // 6. The non-equality assertion tests for whether two objects are not equal\r\n        // with != assert.notEqual(actual, expected, message_opt);\r\n\r\n        assert.notEqual = function notEqual(actual, expected, message) {\r\n          if (actual == expected) {\r\n            fail(actual, expected, message, '!=', assert.notEqual);\r\n          }\r\n        };\r\n\r\n        // 7. The equivalence assertion tests a deep equality relation.\r\n        // assert.deepEqual(actual, expected, message_opt);\r\n\r\n        assert.deepEqual = function deepEqual(actual, expected, message) {\r\n          if (!_deepEqual(actual, expected, false)) {\r\n            fail(actual, expected, message, 'deepEqual', assert.deepEqual);\r\n          }\r\n        };\r\n\r\n        assert.deepStrictEqual = function deepStrictEqual(actual, expected, message) {\r\n          if (!_deepEqual(actual, expected, true)) {\r\n            fail(actual, expected, message, 'deepStrictEqual', assert.deepStrictEqual);\r\n          }\r\n        };\r\n\r\n        function _deepEqual(actual, expected, strict, memos) {\r\n          // 7.1. All identical values are equivalent, as determined by ===.\r\n          if (actual === expected) {\r\n            return true;\r\n          } else if (isBuffer(actual) && isBuffer(expected)) {\r\n            return compare(actual, expected) === 0;\r\n\r\n            // 7.2. If the expected value is a Date object, the actual value is\r\n            // equivalent if it is also a Date object that refers to the same time.\r\n          } else if (util.isDate(actual) && util.isDate(expected)) {\r\n            return actual.getTime() === expected.getTime();\r\n\r\n            // 7.3 If the expected value is a RegExp object, the actual value is\r\n            // equivalent if it is also a RegExp object with the same source and\r\n            // properties (`global`, `multiline`, `lastIndex`, `ignoreCase`).\r\n          } else if (util.isRegExp(actual) && util.isRegExp(expected)) {\r\n            return actual.source === expected.source &&\r\n              actual.global === expected.global &&\r\n              actual.multiline === expected.multiline &&\r\n              actual.lastIndex === expected.lastIndex &&\r\n              actual.ignoreCase === expected.ignoreCase;\r\n\r\n            // 7.4. Other pairs that do not both pass typeof value == 'object',\r\n            // equivalence is determined by ==.\r\n          } else if ((actual === null || typeof actual !== 'object') &&\r\n            (expected === null || typeof expected !== 'object')) {\r\n            return strict ? actual === expected : actual == expected;\r\n\r\n            // If both values are instances of typed arrays, wrap their underlying\r\n            // ArrayBuffers in a Buffer each to increase performance\r\n            // This optimization requires the arrays to have the same type as checked by\r\n            // Object.prototype.toString (aka pToString). Never perform binary\r\n            // comparisons for Float*Arrays, though, since e.g. +0 === -0 but their\r\n            // bit patterns are not identical.\r\n          } else if (isView(actual) && isView(expected) &&\r\n            pToString(actual) === pToString(expected) &&\r\n            !(actual instanceof Float32Array ||\r\n              actual instanceof Float64Array)) {\r\n            return compare(new Uint8Array(actual.buffer),\r\n              new Uint8Array(expected.buffer)) === 0;\r\n\r\n            // 7.5 For all other Object pairs, including Array objects, equivalence is\r\n            // determined by having the same number of owned properties (as verified\r\n            // with Object.prototype.hasOwnProperty.call), the same set of keys\r\n            // (although not necessarily the same order), equivalent values for every\r\n            // corresponding key, and an identical 'prototype' property. Note: this\r\n            // accounts for both named and indexed properties on Arrays.\r\n          } else if (isBuffer(actual) !== isBuffer(expected)) {\r\n            return false;\r\n          } else {\r\n            memos = memos || {\r\n              actual: [],\r\n              expected: []\r\n            };\r\n\r\n            var actualIndex = memos.actual.indexOf(actual);\r\n            if (actualIndex !== -1) {\r\n              if (actualIndex === memos.expected.indexOf(expected)) {\r\n                return true;\r\n              }\r\n            }\r\n\r\n            memos.actual.push(actual);\r\n            memos.expected.push(expected);\r\n\r\n            return objEquiv(actual, expected, strict, memos);\r\n          }\r\n        }\r\n\r\n        function isArguments(object) {\r\n          return Object.prototype.toString.call(object) == '[object Arguments]';\r\n        }\r\n\r\n        function objEquiv(a, b, strict, actualVisitedObjects) {\r\n          if (a === null || a === undefined || b === null || b === undefined)\r\n            return false;\r\n          // if one is a primitive, the other must be same\r\n          if (util.isPrimitive(a) || util.isPrimitive(b))\r\n            return a === b;\r\n          if (strict && Object.getPrototypeOf(a) !== Object.getPrototypeOf(b))\r\n            return false;\r\n          var aIsArgs = isArguments(a);\r\n          var bIsArgs = isArguments(b);\r\n          if ((aIsArgs && !bIsArgs) || (!aIsArgs && bIsArgs))\r\n            return false;\r\n          if (aIsArgs) {\r\n            a = pSlice.call(a);\r\n            b = pSlice.call(b);\r\n            return _deepEqual(a, b, strict);\r\n          }\r\n          var ka = objectKeys(a);\r\n          var kb = objectKeys(b);\r\n          var key, i;\r\n          // having the same number of owned properties (keys incorporates\r\n          // hasOwnProperty)\r\n          if (ka.length !== kb.length)\r\n            return false;\r\n          //the same set of keys (although not necessarily the same order),\r\n          ka.sort();\r\n          kb.sort();\r\n          //~~~cheap key test\r\n          for (i = ka.length - 1; i >= 0; i--) {\r\n            if (ka[i] !== kb[i])\r\n              return false;\r\n          }\r\n          //equivalent values for every corresponding key, and\r\n          //~~~possibly expensive deep test\r\n          for (i = ka.length - 1; i >= 0; i--) {\r\n            key = ka[i];\r\n            if (!_deepEqual(a[key], b[key], strict, actualVisitedObjects))\r\n              return false;\r\n          }\r\n          return true;\r\n        }\r\n\r\n        // 8. The non-equivalence assertion tests for any deep inequality.\r\n        // assert.notDeepEqual(actual, expected, message_opt);\r\n\r\n        assert.notDeepEqual = function notDeepEqual(actual, expected, message) {\r\n          if (_deepEqual(actual, expected, false)) {\r\n            fail(actual, expected, message, 'notDeepEqual', assert.notDeepEqual);\r\n          }\r\n        };\r\n\r\n        assert.notDeepStrictEqual = notDeepStrictEqual;\r\n\r\n        function notDeepStrictEqual(actual, expected, message) {\r\n          if (_deepEqual(actual, expected, true)) {\r\n            fail(actual, expected, message, 'notDeepStrictEqual', notDeepStrictEqual);\r\n          }\r\n        }\r\n\r\n\r\n        // 9. The strict equality assertion tests strict equality, as determined by ===.\r\n        // assert.strictEqual(actual, expected, message_opt);\r\n\r\n        assert.strictEqual = function strictEqual(actual, expected, message) {\r\n          if (actual !== expected) {\r\n            fail(actual, expected, message, '===', assert.strictEqual);\r\n          }\r\n        };\r\n\r\n        // 10. The strict non-equality assertion tests for strict inequality, as\r\n        // determined by !==.  assert.notStrictEqual(actual, expected, message_opt);\r\n\r\n        assert.notStrictEqual = function notStrictEqual(actual, expected, message) {\r\n          if (actual === expected) {\r\n            fail(actual, expected, message, '!==', assert.notStrictEqual);\r\n          }\r\n        };\r\n\r\n        function expectedException(actual, expected) {\r\n          if (!actual || !expected) {\r\n            return false;\r\n          }\r\n\r\n          if (Object.prototype.toString.call(expected) == '[object RegExp]') {\r\n            return expected.test(actual);\r\n          }\r\n\r\n          try {\r\n            if (actual instanceof expected) {\r\n              return true;\r\n            }\r\n          } catch (e) {\r\n            // Ignore.  The instanceof check doesn't work for arrow functions.\r\n          }\r\n\r\n          if (Error.isPrototypeOf(expected)) {\r\n            return false;\r\n          }\r\n\r\n          return expected.call({}, actual) === true;\r\n        }\r\n\r\n        function _tryBlock(block) {\r\n          var error;\r\n          try {\r\n            block();\r\n          } catch (e) {\r\n            error = e;\r\n          }\r\n          return error;\r\n        }\r\n\r\n        function _throws(shouldThrow, block, expected, message) {\r\n          var actual;\r\n\r\n          if (typeof block !== 'function') {\r\n            throw new TypeError('\"block\" argument must be a function');\r\n          }\r\n\r\n          if (typeof expected === 'string') {\r\n            message = expected;\r\n            expected = null;\r\n          }\r\n\r\n          actual = _tryBlock(block);\r\n\r\n          message = (expected && expected.name ? ' (' + expected.name + ').' : '.') +\r\n            (message ? ' ' + message : '.');\r\n\r\n          if (shouldThrow && !actual) {\r\n            fail(actual, expected, 'Missing expected exception' + message);\r\n          }\r\n\r\n          var userProvidedMessage = typeof message === 'string';\r\n          var isUnwantedException = !shouldThrow && util.isError(actual);\r\n          var isUnexpectedException = !shouldThrow && actual && !expected;\r\n\r\n          if ((isUnwantedException &&\r\n              userProvidedMessage &&\r\n              expectedException(actual, expected)) ||\r\n            isUnexpectedException) {\r\n            fail(actual, expected, 'Got unwanted exception' + message);\r\n          }\r\n\r\n          if ((shouldThrow && actual && expected &&\r\n              !expectedException(actual, expected)) || (!shouldThrow && actual)) {\r\n            throw actual;\r\n          }\r\n        }\r\n\r\n        // 11. Expected to throw an error:\r\n        // assert.throws(block, Error_opt, message_opt);\r\n\r\n        assert.throws = function (block, /*optional*/ error, /*optional*/ message) {\r\n          _throws(true, block, error, message);\r\n        };\r\n\r\n        // EXTENSION! This is annoying to write outside this module.\r\n        assert.doesNotThrow = function (block, /*optional*/ error, /*optional*/ message) {\r\n          _throws(false, block, error, message);\r\n        };\r\n\r\n        assert.ifError = function (err) {\r\n          if (err) throw err;\r\n        };\r\n\r\n        var objectKeys = Object.keys || function (obj) {\r\n          var keys = [];\r\n          for (var key in obj) {\r\n            if (hasOwn.call(obj, key)) keys.push(key);\r\n          }\r\n          return keys;\r\n        };\r\n\r\n      }).call(this, typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {})\r\n    }, {\r\n      \"util/\": 20\r\n    }],\r\n    18: [function (require, module, exports) {\r\n      if (typeof Object.create === 'function') {\r\n        // implementation from standard node.js 'util' module\r\n        module.exports = function inherits(ctor, superCtor) {\r\n          ctor.super_ = superCtor\r\n          ctor.prototype = Object.create(superCtor.prototype, {\r\n            constructor: {\r\n              value: ctor,\r\n              enumerable: false,\r\n              writable: true,\r\n              configurable: true\r\n            }\r\n          });\r\n        };\r\n      } else {\r\n        // old school shim for old browsers\r\n        module.exports = function inherits(ctor, superCtor) {\r\n          ctor.super_ = superCtor\r\n          var TempCtor = function () {}\r\n          TempCtor.prototype = superCtor.prototype\r\n          ctor.prototype = new TempCtor()\r\n          ctor.prototype.constructor = ctor\r\n        }\r\n      }\r\n\r\n    }, {}],\r\n    19: [function (require, module, exports) {\r\n      module.exports = function isBuffer(arg) {\r\n        return arg && typeof arg === 'object' &&\r\n          typeof arg.copy === 'function' &&\r\n          typeof arg.fill === 'function' &&\r\n          typeof arg.readUInt8 === 'function';\r\n      }\r\n    }, {}],\r\n    20: [function (require, module, exports) {\r\n      (function (process, global) {\r\n        // Copyright Joyent, Inc. and other Node contributors.\r\n        //\r\n        // Permission is hereby granted, free of charge, to any person obtaining a\r\n        // copy of this software and associated documentation files (the\r\n        // \"Software\"), to deal in the Software without restriction, including\r\n        // without limitation the rights to use, copy, modify, merge, publish,\r\n        // distribute, sublicense, and/or sell copies of the Software, and to permit\r\n        // persons to whom the Software is furnished to do so, subject to the\r\n        // following conditions:\r\n        //\r\n        // The above copyright notice and this permission notice shall be included\r\n        // in all copies or substantial portions of the Software.\r\n        //\r\n        // THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\r\n        // OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\r\n        // MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\r\n        // NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\r\n        // DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\r\n        // OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\r\n        // USE OR OTHER DEALINGS IN THE SOFTWARE.\r\n\r\n        var formatRegExp = /%[sdj%]/g;\r\n        exports.format = function (f) {\r\n          if (!isString(f)) {\r\n            var objects = [];\r\n            for (var i = 0; i < arguments.length; i++) {\r\n              objects.push(inspect(arguments[i]));\r\n            }\r\n            return objects.join(' ');\r\n          }\r\n\r\n          var i = 1;\r\n          var args = arguments;\r\n          var len = args.length;\r\n          var str = String(f).replace(formatRegExp, function (x) {\r\n            if (x === '%%') return '%';\r\n            if (i >= len) return x;\r\n            switch (x) {\r\n              case '%s':\r\n                return String(args[i++]);\r\n              case '%d':\r\n                return Number(args[i++]);\r\n              case '%j':\r\n                try {\r\n                  return JSON.stringify(args[i++]);\r\n                } catch (_) {\r\n                  return '[Circular]';\r\n                }\r\n                default:\r\n                  return x;\r\n            }\r\n          });\r\n          for (var x = args[i]; i < len; x = args[++i]) {\r\n            if (isNull(x) || !isObject(x)) {\r\n              str += ' ' + x;\r\n            } else {\r\n              str += ' ' + inspect(x);\r\n            }\r\n          }\r\n          return str;\r\n        };\r\n\r\n\r\n        // Mark that a method should not be used.\r\n        // Returns a modified function which warns once by default.\r\n        // If --no-deprecation is set, then it is a no-op.\r\n        exports.deprecate = function (fn, msg) {\r\n          // Allow for deprecating things in the process of starting up.\r\n          if (isUndefined(global.process)) {\r\n            return function () {\r\n              return exports.deprecate(fn, msg).apply(this, arguments);\r\n            };\r\n          }\r\n\r\n          if (process.noDeprecation === true) {\r\n            return fn;\r\n          }\r\n\r\n          var warned = false;\r\n\r\n          function deprecated() {\r\n            if (!warned) {\r\n              if (process.throwDeprecation) {\r\n                throw new Error(msg);\r\n              } else if (process.traceDeprecation) {\r\n                console.trace(msg);\r\n              } else {\r\n                console.error(msg);\r\n              }\r\n              warned = true;\r\n            }\r\n            return fn.apply(this, arguments);\r\n          }\r\n\r\n          return deprecated;\r\n        };\r\n\r\n\r\n        var debugs = {};\r\n        var debugEnviron;\r\n        exports.debuglog = function (set) {\r\n          if (isUndefined(debugEnviron))\r\n            debugEnviron = process.env.NODE_DEBUG || '';\r\n          set = set.toUpperCase();\r\n          if (!debugs[set]) {\r\n            if (new RegExp('\\\\b' + set + '\\\\b', 'i').test(debugEnviron)) {\r\n              var pid = process.pid;\r\n              debugs[set] = function () {\r\n                var msg = exports.format.apply(exports, arguments);\r\n                console.error('%s %d: %s', set, pid, msg);\r\n              };\r\n            } else {\r\n              debugs[set] = function () {};\r\n            }\r\n          }\r\n          return debugs[set];\r\n        };\r\n\r\n\r\n        /**\r\n         * Echos the value of a value. Trys to print the value out\r\n         * in the best way possible given the different types.\r\n         *\r\n         * @param {Object} obj The object to print out.\r\n         * @param {Object} opts Optional options object that alters the output.\r\n         */\r\n        /* legacy: obj, showHidden, depth, colors*/\r\n        function inspect(obj, opts) {\r\n          // default options\r\n          var ctx = {\r\n            seen: [],\r\n            stylize: stylizeNoColor\r\n          };\r\n          // legacy...\r\n          if (arguments.length >= 3) ctx.depth = arguments[2];\r\n          if (arguments.length >= 4) ctx.colors = arguments[3];\r\n          if (isBoolean(opts)) {\r\n            // legacy...\r\n            ctx.showHidden = opts;\r\n          } else if (opts) {\r\n            // got an \"options\" object\r\n            exports._extend(ctx, opts);\r\n          }\r\n          // set default options\r\n          if (isUndefined(ctx.showHidden)) ctx.showHidden = false;\r\n          if (isUndefined(ctx.depth)) ctx.depth = 2;\r\n          if (isUndefined(ctx.colors)) ctx.colors = false;\r\n          if (isUndefined(ctx.customInspect)) ctx.customInspect = true;\r\n          if (ctx.colors) ctx.stylize = stylizeWithColor;\r\n          return formatValue(ctx, obj, ctx.depth);\r\n        }\r\n        exports.inspect = inspect;\r\n\r\n\r\n        // http://en.wikipedia.org/wiki/ANSI_escape_code#graphics\r\n        inspect.colors = {\r\n          'bold': [1, 22],\r\n          'italic': [3, 23],\r\n          'underline': [4, 24],\r\n          'inverse': [7, 27],\r\n          'white': [37, 39],\r\n          'grey': [90, 39],\r\n          'black': [30, 39],\r\n          'blue': [34, 39],\r\n          'cyan': [36, 39],\r\n          'green': [32, 39],\r\n          'magenta': [35, 39],\r\n          'red': [31, 39],\r\n          'yellow': [33, 39]\r\n        };\r\n\r\n        // Don't use 'blue' not visible on cmd.exe\r\n        inspect.styles = {\r\n          'special': 'cyan',\r\n          'number': 'yellow',\r\n          'boolean': 'yellow',\r\n          'undefined': 'grey',\r\n          'null': 'bold',\r\n          'string': 'green',\r\n          'date': 'magenta',\r\n          // \"name\": intentionally not styling\r\n          'regexp': 'red'\r\n        };\r\n\r\n\r\n        function stylizeWithColor(str, styleType) {\r\n          var style = inspect.styles[styleType];\r\n\r\n          if (style) {\r\n            return '\\u001b[' + inspect.colors[style][0] + 'm' + str +\r\n              '\\u001b[' + inspect.colors[style][1] + 'm';\r\n          } else {\r\n            return str;\r\n          }\r\n        }\r\n\r\n\r\n        function stylizeNoColor(str, styleType) {\r\n          return str;\r\n        }\r\n\r\n\r\n        function arrayToHash(array) {\r\n          var hash = {};\r\n\r\n          array.forEach(function (val, idx) {\r\n            hash[val] = true;\r\n          });\r\n\r\n          return hash;\r\n        }\r\n\r\n\r\n        function formatValue(ctx, value, recurseTimes) {\r\n          // Provide a hook for user-specified inspect functions.\r\n          // Check that value is an object with an inspect function on it\r\n          if (ctx.customInspect &&\r\n            value &&\r\n            isFunction(value.inspect) &&\r\n            // Filter out the util module, it's inspect function is special\r\n            value.inspect !== exports.inspect &&\r\n            // Also filter out any prototype objects using the circular check.\r\n            !(value.constructor && value.constructor.prototype === value)) {\r\n            var ret = value.inspect(recurseTimes, ctx);\r\n            if (!isString(ret)) {\r\n              ret = formatValue(ctx, ret, recurseTimes);\r\n            }\r\n            return ret;\r\n          }\r\n\r\n          // Primitive types cannot have properties\r\n          var primitive = formatPrimitive(ctx, value);\r\n          if (primitive) {\r\n            return primitive;\r\n          }\r\n\r\n          // Look up the keys of the object.\r\n          var keys = Object.keys(value);\r\n          var visibleKeys = arrayToHash(keys);\r\n\r\n          if (ctx.showHidden) {\r\n            keys = Object.getOwnPropertyNames(value);\r\n          }\r\n\r\n          // IE doesn't make error fields non-enumerable\r\n          // http://msdn.microsoft.com/en-us/library/ie/dww52sbt(v=vs.94).aspx\r\n          if (isError(value) &&\r\n            (keys.indexOf('message') >= 0 || keys.indexOf('description') >= 0)) {\r\n            return formatError(value);\r\n          }\r\n\r\n          // Some type of object without properties can be shortcutted.\r\n          if (keys.length === 0) {\r\n            if (isFunction(value)) {\r\n              var name = value.name ? ': ' + value.name : '';\r\n              return ctx.stylize('[Function' + name + ']', 'special');\r\n            }\r\n            if (isRegExp(value)) {\r\n              return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');\r\n            }\r\n            if (isDate(value)) {\r\n              return ctx.stylize(Date.prototype.toString.call(value), 'date');\r\n            }\r\n            if (isError(value)) {\r\n              return formatError(value);\r\n            }\r\n          }\r\n\r\n          var base = '',\r\n            array = false,\r\n            braces = ['{', '}'];\r\n\r\n          // Make Array say that they are Array\r\n          if (isArray(value)) {\r\n            array = true;\r\n            braces = ['[', ']'];\r\n          }\r\n\r\n          // Make functions say that they are functions\r\n          if (isFunction(value)) {\r\n            var n = value.name ? ': ' + value.name : '';\r\n            base = ' [Function' + n + ']';\r\n          }\r\n\r\n          // Make RegExps say that they are RegExps\r\n          if (isRegExp(value)) {\r\n            base = ' ' + RegExp.prototype.toString.call(value);\r\n          }\r\n\r\n          // Make dates with properties first say the date\r\n          if (isDate(value)) {\r\n            base = ' ' + Date.prototype.toUTCString.call(value);\r\n          }\r\n\r\n          // Make error with message first say the error\r\n          if (isError(value)) {\r\n            base = ' ' + formatError(value);\r\n          }\r\n\r\n          if (keys.length === 0 && (!array || value.length == 0)) {\r\n            return braces[0] + base + braces[1];\r\n          }\r\n\r\n          if (recurseTimes < 0) {\r\n            if (isRegExp(value)) {\r\n              return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');\r\n            } else {\r\n              return ctx.stylize('[Object]', 'special');\r\n            }\r\n          }\r\n\r\n          ctx.seen.push(value);\r\n\r\n          var output;\r\n          if (array) {\r\n            output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);\r\n          } else {\r\n            output = keys.map(function (key) {\r\n              return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);\r\n            });\r\n          }\r\n\r\n          ctx.seen.pop();\r\n\r\n          return reduceToSingleString(output, base, braces);\r\n        }\r\n\r\n\r\n        function formatPrimitive(ctx, value) {\r\n          if (isUndefined(value))\r\n            return ctx.stylize('undefined', 'undefined');\r\n          if (isString(value)) {\r\n            var simple = '\\'' + JSON.stringify(value).replace(/^\"|\"$/g, '')\r\n              .replace(/'/g, \"\\\\'\")\r\n              .replace(/\\\\\"/g, '\"') + '\\'';\r\n            return ctx.stylize(simple, 'string');\r\n          }\r\n          if (isNumber(value))\r\n            return ctx.stylize('' + value, 'number');\r\n          if (isBoolean(value))\r\n            return ctx.stylize('' + value, 'boolean');\r\n          // For some reason typeof null is \"object\", so special case here.\r\n          if (isNull(value))\r\n            return ctx.stylize('null', 'null');\r\n        }\r\n\r\n\r\n        function formatError(value) {\r\n          return '[' + Error.prototype.toString.call(value) + ']';\r\n        }\r\n\r\n\r\n        function formatArray(ctx, value, recurseTimes, visibleKeys, keys) {\r\n          var output = [];\r\n          for (var i = 0, l = value.length; i < l; ++i) {\r\n            if (hasOwnProperty(value, String(i))) {\r\n              output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,\r\n                String(i), true));\r\n            } else {\r\n              output.push('');\r\n            }\r\n          }\r\n          keys.forEach(function (key) {\r\n            if (!key.match(/^\\d+$/)) {\r\n              output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,\r\n                key, true));\r\n            }\r\n          });\r\n          return output;\r\n        }\r\n\r\n\r\n        function formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {\r\n          var name, str, desc;\r\n          desc = Object.getOwnPropertyDescriptor(value, key) || {\r\n            value: value[key]\r\n          };\r\n          if (desc.get) {\r\n            if (desc.set) {\r\n              str = ctx.stylize('[Getter/Setter]', 'special');\r\n            } else {\r\n              str = ctx.stylize('[Getter]', 'special');\r\n            }\r\n          } else {\r\n            if (desc.set) {\r\n              str = ctx.stylize('[Setter]', 'special');\r\n            }\r\n          }\r\n          if (!hasOwnProperty(visibleKeys, key)) {\r\n            name = '[' + key + ']';\r\n          }\r\n          if (!str) {\r\n            if (ctx.seen.indexOf(desc.value) < 0) {\r\n              if (isNull(recurseTimes)) {\r\n                str = formatValue(ctx, desc.value, null);\r\n              } else {\r\n                str = formatValue(ctx, desc.value, recurseTimes - 1);\r\n              }\r\n              if (str.indexOf('\\n') > -1) {\r\n                if (array) {\r\n                  str = str.split('\\n').map(function (line) {\r\n                    return '  ' + line;\r\n                  }).join('\\n').substr(2);\r\n                } else {\r\n                  str = '\\n' + str.split('\\n').map(function (line) {\r\n                    return '   ' + line;\r\n                  }).join('\\n');\r\n                }\r\n              }\r\n            } else {\r\n              str = ctx.stylize('[Circular]', 'special');\r\n            }\r\n          }\r\n          if (isUndefined(name)) {\r\n            if (array && key.match(/^\\d+$/)) {\r\n              return str;\r\n            }\r\n            name = JSON.stringify('' + key);\r\n            if (name.match(/^\"([a-zA-Z_][a-zA-Z_0-9]*)\"$/)) {\r\n              name = name.substr(1, name.length - 2);\r\n              name = ctx.stylize(name, 'name');\r\n            } else {\r\n              name = name.replace(/'/g, \"\\\\'\")\r\n                .replace(/\\\\\"/g, '\"')\r\n                .replace(/(^\"|\"$)/g, \"'\");\r\n              name = ctx.stylize(name, 'string');\r\n            }\r\n          }\r\n\r\n          return name + ': ' + str;\r\n        }\r\n\r\n\r\n        function reduceToSingleString(output, base, braces) {\r\n          var numLinesEst = 0;\r\n          var length = output.reduce(function (prev, cur) {\r\n            numLinesEst++;\r\n            if (cur.indexOf('\\n') >= 0) numLinesEst++;\r\n            return prev + cur.replace(/\\u001b\\[\\d\\d?m/g, '').length + 1;\r\n          }, 0);\r\n\r\n          if (length > 60) {\r\n            return braces[0] +\r\n              (base === '' ? '' : base + '\\n ') +\r\n              ' ' +\r\n              output.join(',\\n  ') +\r\n              ' ' +\r\n              braces[1];\r\n          }\r\n\r\n          return braces[0] + base + ' ' + output.join(', ') + ' ' + braces[1];\r\n        }\r\n\r\n\r\n        // NOTE: These type checking functions intentionally don't use `instanceof`\r\n        // because it is fragile and can be easily faked with `Object.create()`.\r\n        function isArray(ar) {\r\n          return Array.isArray(ar);\r\n        }\r\n        exports.isArray = isArray;\r\n\r\n        function isBoolean(arg) {\r\n          return typeof arg === 'boolean';\r\n        }\r\n        exports.isBoolean = isBoolean;\r\n\r\n        function isNull(arg) {\r\n          return arg === null;\r\n        }\r\n        exports.isNull = isNull;\r\n\r\n        function isNullOrUndefined(arg) {\r\n          return arg == null;\r\n        }\r\n        exports.isNullOrUndefined = isNullOrUndefined;\r\n\r\n        function isNumber(arg) {\r\n          return typeof arg === 'number';\r\n        }\r\n        exports.isNumber = isNumber;\r\n\r\n        function isString(arg) {\r\n          return typeof arg === 'string';\r\n        }\r\n        exports.isString = isString;\r\n\r\n        function isSymbol(arg) {\r\n          return typeof arg === 'symbol';\r\n        }\r\n        exports.isSymbol = isSymbol;\r\n\r\n        function isUndefined(arg) {\r\n          return arg === void 0;\r\n        }\r\n        exports.isUndefined = isUndefined;\r\n\r\n        function isRegExp(re) {\r\n          return isObject(re) && objectToString(re) === '[object RegExp]';\r\n        }\r\n        exports.isRegExp = isRegExp;\r\n\r\n        function isObject(arg) {\r\n          return typeof arg === 'object' && arg !== null;\r\n        }\r\n        exports.isObject = isObject;\r\n\r\n        function isDate(d) {\r\n          return isObject(d) && objectToString(d) === '[object Date]';\r\n        }\r\n        exports.isDate = isDate;\r\n\r\n        function isError(e) {\r\n          return isObject(e) &&\r\n            (objectToString(e) === '[object Error]' || e instanceof Error);\r\n        }\r\n        exports.isError = isError;\r\n\r\n        function isFunction(arg) {\r\n          return typeof arg === 'function';\r\n        }\r\n        exports.isFunction = isFunction;\r\n\r\n        function isPrimitive(arg) {\r\n          return arg === null ||\r\n            typeof arg === 'boolean' ||\r\n            typeof arg === 'number' ||\r\n            typeof arg === 'string' ||\r\n            typeof arg === 'symbol' || // ES6 symbol\r\n            typeof arg === 'undefined';\r\n        }\r\n        exports.isPrimitive = isPrimitive;\r\n\r\n        exports.isBuffer = require('./support/isBuffer');\r\n\r\n        function objectToString(o) {\r\n          return Object.prototype.toString.call(o);\r\n        }\r\n\r\n\r\n        function pad(n) {\r\n          return n < 10 ? '0' + n.toString(10) : n.toString(10);\r\n        }\r\n\r\n\r\n        var months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep',\r\n          'Oct', 'Nov', 'Dec'\r\n        ];\r\n\r\n        // 26 Feb 16:19:34\r\n        function timestamp() {\r\n          var d = new Date();\r\n          var time = [pad(d.getHours()),\r\n            pad(d.getMinutes()),\r\n            pad(d.getSeconds())\r\n          ].join(':');\r\n          return [d.getDate(), months[d.getMonth()], time].join(' ');\r\n        }\r\n\r\n\r\n        // log is just a thin wrapper to console.log that prepends a timestamp\r\n        exports.log = function () {\r\n          console.log('%s - %s', timestamp(), exports.format.apply(exports, arguments));\r\n        };\r\n\r\n\r\n        /**\r\n         * Inherit the prototype methods from one constructor into another.\r\n         *\r\n         * The Function.prototype.inherits from lang.js rewritten as a standalone\r\n         * function (not on Function.prototype). NOTE: If this file is to be loaded\r\n         * during bootstrapping this function needs to be rewritten using some native\r\n         * functions as prototype setup using normal JavaScript does not work as\r\n         * expected during bootstrapping (see mirror.js in r114903).\r\n         *\r\n         * @param {function} ctor Constructor function which needs to inherit the\r\n         *     prototype.\r\n         * @param {function} superCtor Constructor function to inherit prototype from.\r\n         */\r\n        exports.inherits = require('inherits');\r\n\r\n        exports._extend = function (origin, add) {\r\n          // Don't do anything if add isn't an object\r\n          if (!add || !isObject(add)) return origin;\r\n\r\n          var keys = Object.keys(add);\r\n          var i = keys.length;\r\n          while (i--) {\r\n            origin[keys[i]] = add[keys[i]];\r\n          }\r\n          return origin;\r\n        };\r\n\r\n        function hasOwnProperty(obj, prop) {\r\n          return Object.prototype.hasOwnProperty.call(obj, prop);\r\n        }\r\n\r\n      }).call(this, require('_process'), typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {})\r\n    }, {\r\n      \"./support/isBuffer\": 19,\r\n      \"_process\": 124,\r\n      \"inherits\": 18\r\n    }],\r\n    21: [function (require, module, exports) {\r\n      'use strict'\r\n\r\n      exports.byteLength = byteLength\r\n      exports.toByteArray = toByteArray\r\n      exports.fromByteArray = fromByteArray\r\n\r\n      var lookup = []\r\n      var revLookup = []\r\n      var Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array\r\n\r\n      var code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'\r\n      for (var i = 0, len = code.length; i < len; ++i) {\r\n        lookup[i] = code[i]\r\n        revLookup[code.charCodeAt(i)] = i\r\n      }\r\n\r\n      // Support decoding URL-safe base64 strings, as Node.js does.\r\n      // See: https://en.wikipedia.org/wiki/Base64#URL_applications\r\n      revLookup['-'.charCodeAt(0)] = 62\r\n      revLookup['_'.charCodeAt(0)] = 63\r\n\r\n      function getLens(b64) {\r\n        var len = b64.length\r\n\r\n        if (len % 4 > 0) {\r\n          throw new Error('Invalid string. Length must be a multiple of 4')\r\n        }\r\n\r\n        // Trim off extra bytes after placeholder bytes are found\r\n        // See: https://github.com/beatgammit/base64-js/issues/42\r\n        var validLen = b64.indexOf('=')\r\n        if (validLen === -1) validLen = len\r\n\r\n        var placeHoldersLen = validLen === len ?\r\n          0 :\r\n          4 - (validLen % 4)\r\n\r\n        return [validLen, placeHoldersLen]\r\n      }\r\n\r\n      // base64 is 4/3 + up to two characters of the original data\r\n      function byteLength(b64) {\r\n        var lens = getLens(b64)\r\n        var validLen = lens[0]\r\n        var placeHoldersLen = lens[1]\r\n        return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen\r\n      }\r\n\r\n      function _byteLength(b64, validLen, placeHoldersLen) {\r\n        return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen\r\n      }\r\n\r\n      function toByteArray(b64) {\r\n        var tmp\r\n        var lens = getLens(b64)\r\n        var validLen = lens[0]\r\n        var placeHoldersLen = lens[1]\r\n\r\n        var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen))\r\n\r\n        var curByte = 0\r\n\r\n        // if there are placeholders, only get up to the last complete 4 chars\r\n        var len = placeHoldersLen > 0 ?\r\n          validLen - 4 :\r\n          validLen\r\n\r\n        for (var i = 0; i < len; i += 4) {\r\n          tmp =\r\n            (revLookup[b64.charCodeAt(i)] << 18) |\r\n            (revLookup[b64.charCodeAt(i + 1)] << 12) |\r\n            (revLookup[b64.charCodeAt(i + 2)] << 6) |\r\n            revLookup[b64.charCodeAt(i + 3)]\r\n          arr[curByte++] = (tmp >> 16) & 0xFF\r\n          arr[curByte++] = (tmp >> 8) & 0xFF\r\n          arr[curByte++] = tmp & 0xFF\r\n        }\r\n\r\n        if (placeHoldersLen === 2) {\r\n          tmp =\r\n            (revLookup[b64.charCodeAt(i)] << 2) |\r\n            (revLookup[b64.charCodeAt(i + 1)] >> 4)\r\n          arr[curByte++] = tmp & 0xFF\r\n        }\r\n\r\n        if (placeHoldersLen === 1) {\r\n          tmp =\r\n            (revLookup[b64.charCodeAt(i)] << 10) |\r\n            (revLookup[b64.charCodeAt(i + 1)] << 4) |\r\n            (revLookup[b64.charCodeAt(i + 2)] >> 2)\r\n          arr[curByte++] = (tmp >> 8) & 0xFF\r\n          arr[curByte++] = tmp & 0xFF\r\n        }\r\n\r\n        return arr\r\n      }\r\n\r\n      function tripletToBase64(num) {\r\n        return lookup[num >> 18 & 0x3F] +\r\n          lookup[num >> 12 & 0x3F] +\r\n          lookup[num >> 6 & 0x3F] +\r\n          lookup[num & 0x3F]\r\n      }\r\n\r\n      function encodeChunk(uint8, start, end) {\r\n        var tmp\r\n        var output = []\r\n        for (var i = start; i < end; i += 3) {\r\n          tmp =\r\n            ((uint8[i] << 16) & 0xFF0000) +\r\n            ((uint8[i + 1] << 8) & 0xFF00) +\r\n            (uint8[i + 2] & 0xFF)\r\n          output.push(tripletToBase64(tmp))\r\n        }\r\n        return output.join('')\r\n      }\r\n\r\n      function fromByteArray(uint8) {\r\n        var tmp\r\n        var len = uint8.length\r\n        var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes\r\n        var parts = []\r\n        var maxChunkLength = 16383 // must be multiple of 3\r\n\r\n        // go through the array every three bytes, we'll deal with trailing stuff later\r\n        for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {\r\n          parts.push(encodeChunk(\r\n            uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)\r\n          ))\r\n        }\r\n\r\n        // pad the end with zeros, but make sure to not forget the extra bytes\r\n        if (extraBytes === 1) {\r\n          tmp = uint8[len - 1]\r\n          parts.push(\r\n            lookup[tmp >> 2] +\r\n            lookup[(tmp << 4) & 0x3F] +\r\n            '=='\r\n          )\r\n        } else if (extraBytes === 2) {\r\n          tmp = (uint8[len - 2] << 8) + uint8[len - 1]\r\n          parts.push(\r\n            lookup[tmp >> 10] +\r\n            lookup[(tmp >> 4) & 0x3F] +\r\n            lookup[(tmp << 2) & 0x3F] +\r\n            '='\r\n          )\r\n        }\r\n\r\n        return parts.join('')\r\n      }\r\n\r\n    }, {}],\r\n    22: [function (require, module, exports) {\r\n      var bigInt = (function (undefined) {\r\n        \"use strict\";\r\n\r\n        var BASE = 1e7,\r\n          LOG_BASE = 7,\r\n          MAX_INT = 9007199254740992,\r\n          MAX_INT_ARR = smallToArray(MAX_INT),\r\n          LOG_MAX_INT = Math.log(MAX_INT);\r\n\r\n        function Integer(v, radix) {\r\n          if (typeof v === \"undefined\") return Integer[0];\r\n          if (typeof radix !== \"undefined\") return +radix === 10 ? parseValue(v) : parseBase(v, radix);\r\n          return parseValue(v);\r\n        }\r\n\r\n        function BigInteger(value, sign) {\r\n          this.value = value;\r\n          this.sign = sign;\r\n          this.isSmall = false;\r\n        }\r\n        BigInteger.prototype = Object.create(Integer.prototype);\r\n\r\n        function SmallInteger(value) {\r\n          this.value = value;\r\n          this.sign = value < 0;\r\n          this.isSmall = true;\r\n        }\r\n        SmallInteger.prototype = Object.create(Integer.prototype);\r\n\r\n        function isPrecise(n) {\r\n          return -MAX_INT < n && n < MAX_INT;\r\n        }\r\n\r\n        function smallToArray(n) { // For performance reasons doesn't reference BASE, need to change this function if BASE changes\r\n          if (n < 1e7)\r\n            return [n];\r\n          if (n < 1e14)\r\n            return [n % 1e7, Math.floor(n / 1e7)];\r\n          return [n % 1e7, Math.floor(n / 1e7) % 1e7, Math.floor(n / 1e14)];\r\n        }\r\n\r\n        function arrayToSmall(arr) { // If BASE changes this function may need to change\r\n          trim(arr);\r\n          var length = arr.length;\r\n          if (length < 4 && compareAbs(arr, MAX_INT_ARR) < 0) {\r\n            switch (length) {\r\n              case 0:\r\n                return 0;\r\n              case 1:\r\n                return arr[0];\r\n              case 2:\r\n                return arr[0] + arr[1] * BASE;\r\n              default:\r\n                return arr[0] + (arr[1] + arr[2] * BASE) * BASE;\r\n            }\r\n          }\r\n          return arr;\r\n        }\r\n\r\n        function trim(v) {\r\n          var i = v.length;\r\n          while (v[--i] === 0);\r\n          v.length = i + 1;\r\n        }\r\n\r\n        function createArray(length) { // function shamelessly stolen from Yaffle's library https://github.com/Yaffle/BigInteger\r\n          var x = new Array(length);\r\n          var i = -1;\r\n          while (++i < length) {\r\n            x[i] = 0;\r\n          }\r\n          return x;\r\n        }\r\n\r\n        function truncate(n) {\r\n          if (n > 0) return Math.floor(n);\r\n          return Math.ceil(n);\r\n        }\r\n\r\n        function add(a, b) { // assumes a and b are arrays with a.length >= b.length\r\n          var l_a = a.length,\r\n            l_b = b.length,\r\n            r = new Array(l_a),\r\n            carry = 0,\r\n            base = BASE,\r\n            sum, i;\r\n          for (i = 0; i < l_b; i++) {\r\n            sum = a[i] + b[i] + carry;\r\n            carry = sum >= base ? 1 : 0;\r\n            r[i] = sum - carry * base;\r\n          }\r\n          while (i < l_a) {\r\n            sum = a[i] + carry;\r\n            carry = sum === base ? 1 : 0;\r\n            r[i++] = sum - carry * base;\r\n          }\r\n          if (carry > 0) r.push(carry);\r\n          return r;\r\n        }\r\n\r\n        function addAny(a, b) {\r\n          if (a.length >= b.length) return add(a, b);\r\n          return add(b, a);\r\n        }\r\n\r\n        function addSmall(a, carry) { // assumes a is array, carry is number with 0 <= carry < MAX_INT\r\n          var l = a.length,\r\n            r = new Array(l),\r\n            base = BASE,\r\n            sum, i;\r\n          for (i = 0; i < l; i++) {\r\n            sum = a[i] - base + carry;\r\n            carry = Math.floor(sum / base);\r\n            r[i] = sum - carry * base;\r\n            carry += 1;\r\n          }\r\n          while (carry > 0) {\r\n            r[i++] = carry % base;\r\n            carry = Math.floor(carry / base);\r\n          }\r\n          return r;\r\n        }\r\n\r\n        BigInteger.prototype.add = function (v) {\r\n          var n = parseValue(v);\r\n          if (this.sign !== n.sign) {\r\n            return this.subtract(n.negate());\r\n          }\r\n          var a = this.value,\r\n            b = n.value;\r\n          if (n.isSmall) {\r\n            return new BigInteger(addSmall(a, Math.abs(b)), this.sign);\r\n          }\r\n          return new BigInteger(addAny(a, b), this.sign);\r\n        };\r\n        BigInteger.prototype.plus = BigInteger.prototype.add;\r\n\r\n        SmallInteger.prototype.add = function (v) {\r\n          var n = parseValue(v);\r\n          var a = this.value;\r\n          if (a < 0 !== n.sign) {\r\n            return this.subtract(n.negate());\r\n          }\r\n          var b = n.value;\r\n          if (n.isSmall) {\r\n            if (isPrecise(a + b)) return new SmallInteger(a + b);\r\n            b = smallToArray(Math.abs(b));\r\n          }\r\n          return new BigInteger(addSmall(b, Math.abs(a)), a < 0);\r\n        };\r\n        SmallInteger.prototype.plus = SmallInteger.prototype.add;\r\n\r\n        function subtract(a, b) { // assumes a and b are arrays with a >= b\r\n          var a_l = a.length,\r\n            b_l = b.length,\r\n            r = new Array(a_l),\r\n            borrow = 0,\r\n            base = BASE,\r\n            i, difference;\r\n          for (i = 0; i < b_l; i++) {\r\n            difference = a[i] - borrow - b[i];\r\n            if (difference < 0) {\r\n              difference += base;\r\n              borrow = 1;\r\n            } else borrow = 0;\r\n            r[i] = difference;\r\n          }\r\n          for (i = b_l; i < a_l; i++) {\r\n            difference = a[i] - borrow;\r\n            if (difference < 0) difference += base;\r\n            else {\r\n              r[i++] = difference;\r\n              break;\r\n            }\r\n            r[i] = difference;\r\n          }\r\n          for (; i < a_l; i++) {\r\n            r[i] = a[i];\r\n          }\r\n          trim(r);\r\n          return r;\r\n        }\r\n\r\n        function subtractAny(a, b, sign) {\r\n          var value;\r\n          if (compareAbs(a, b) >= 0) {\r\n            value = subtract(a, b);\r\n          } else {\r\n            value = subtract(b, a);\r\n            sign = !sign;\r\n          }\r\n          value = arrayToSmall(value);\r\n          if (typeof value === \"number\") {\r\n            if (sign) value = -value;\r\n            return new SmallInteger(value);\r\n          }\r\n          return new BigInteger(value, sign);\r\n        }\r\n\r\n        function subtractSmall(a, b, sign) { // assumes a is array, b is number with 0 <= b < MAX_INT\r\n          var l = a.length,\r\n            r = new Array(l),\r\n            carry = -b,\r\n            base = BASE,\r\n            i, difference;\r\n          for (i = 0; i < l; i++) {\r\n            difference = a[i] + carry;\r\n            carry = Math.floor(difference / base);\r\n            difference %= base;\r\n            r[i] = difference < 0 ? difference + base : difference;\r\n          }\r\n          r = arrayToSmall(r);\r\n          if (typeof r === \"number\") {\r\n            if (sign) r = -r;\r\n            return new SmallInteger(r);\r\n          }\r\n          return new BigInteger(r, sign);\r\n        }\r\n\r\n        BigInteger.prototype.subtract = function (v) {\r\n          var n = parseValue(v);\r\n          if (this.sign !== n.sign) {\r\n            return this.add(n.negate());\r\n          }\r\n          var a = this.value,\r\n            b = n.value;\r\n          if (n.isSmall)\r\n            return subtractSmall(a, Math.abs(b), this.sign);\r\n          return subtractAny(a, b, this.sign);\r\n        };\r\n        BigInteger.prototype.minus = BigInteger.prototype.subtract;\r\n\r\n        SmallInteger.prototype.subtract = function (v) {\r\n          var n = parseValue(v);\r\n          var a = this.value;\r\n          if (a < 0 !== n.sign) {\r\n            return this.add(n.negate());\r\n          }\r\n          var b = n.value;\r\n          if (n.isSmall) {\r\n            return new SmallInteger(a - b);\r\n          }\r\n          return subtractSmall(b, Math.abs(a), a >= 0);\r\n        };\r\n        SmallInteger.prototype.minus = SmallInteger.prototype.subtract;\r\n\r\n        BigInteger.prototype.negate = function () {\r\n          return new BigInteger(this.value, !this.sign);\r\n        };\r\n        SmallInteger.prototype.negate = function () {\r\n          var sign = this.sign;\r\n          var small = new SmallInteger(-this.value);\r\n          small.sign = !sign;\r\n          return small;\r\n        };\r\n\r\n        BigInteger.prototype.abs = function () {\r\n          return new BigInteger(this.value, false);\r\n        };\r\n        SmallInteger.prototype.abs = function () {\r\n          return new SmallInteger(Math.abs(this.value));\r\n        };\r\n\r\n        function multiplyLong(a, b) {\r\n          var a_l = a.length,\r\n            b_l = b.length,\r\n            l = a_l + b_l,\r\n            r = createArray(l),\r\n            base = BASE,\r\n            product, carry, i, a_i, b_j;\r\n          for (i = 0; i < a_l; ++i) {\r\n            a_i = a[i];\r\n            for (var j = 0; j < b_l; ++j) {\r\n              b_j = b[j];\r\n              product = a_i * b_j + r[i + j];\r\n              carry = Math.floor(product / base);\r\n              r[i + j] = product - carry * base;\r\n              r[i + j + 1] += carry;\r\n            }\r\n          }\r\n          trim(r);\r\n          return r;\r\n        }\r\n\r\n        function multiplySmall(a, b) { // assumes a is array, b is number with |b| < BASE\r\n          var l = a.length,\r\n            r = new Array(l),\r\n            base = BASE,\r\n            carry = 0,\r\n            product, i;\r\n          for (i = 0; i < l; i++) {\r\n            product = a[i] * b + carry;\r\n            carry = Math.floor(product / base);\r\n            r[i] = product - carry * base;\r\n          }\r\n          while (carry > 0) {\r\n            r[i++] = carry % base;\r\n            carry = Math.floor(carry / base);\r\n          }\r\n          return r;\r\n        }\r\n\r\n        function shiftLeft(x, n) {\r\n          var r = [];\r\n          while (n-- > 0) r.push(0);\r\n          return r.concat(x);\r\n        }\r\n\r\n        function multiplyKaratsuba(x, y) {\r\n          var n = Math.max(x.length, y.length);\r\n\r\n          if (n <= 30) return multiplyLong(x, y);\r\n          n = Math.ceil(n / 2);\r\n\r\n          var b = x.slice(n),\r\n            a = x.slice(0, n),\r\n            d = y.slice(n),\r\n            c = y.slice(0, n);\r\n\r\n          var ac = multiplyKaratsuba(a, c),\r\n            bd = multiplyKaratsuba(b, d),\r\n            abcd = multiplyKaratsuba(addAny(a, b), addAny(c, d));\r\n\r\n          var product = addAny(addAny(ac, shiftLeft(subtract(subtract(abcd, ac), bd), n)), shiftLeft(bd, 2 * n));\r\n          trim(product);\r\n          return product;\r\n        }\r\n\r\n        // The following function is derived from a surface fit of a graph plotting the performance difference\r\n        // between long multiplication and karatsuba multiplication versus the lengths of the two arrays.\r\n        function useKaratsuba(l1, l2) {\r\n          return -0.012 * l1 - 0.012 * l2 + 0.000015 * l1 * l2 > 0;\r\n        }\r\n\r\n        BigInteger.prototype.multiply = function (v) {\r\n          var n = parseValue(v),\r\n            a = this.value,\r\n            b = n.value,\r\n            sign = this.sign !== n.sign,\r\n            abs;\r\n          if (n.isSmall) {\r\n            if (b === 0) return Integer[0];\r\n            if (b === 1) return this;\r\n            if (b === -1) return this.negate();\r\n            abs = Math.abs(b);\r\n            if (abs < BASE) {\r\n              return new BigInteger(multiplySmall(a, abs), sign);\r\n            }\r\n            b = smallToArray(abs);\r\n          }\r\n          if (useKaratsuba(a.length, b.length)) // Karatsuba is only faster for certain array sizes\r\n            return new BigInteger(multiplyKaratsuba(a, b), sign);\r\n          return new BigInteger(multiplyLong(a, b), sign);\r\n        };\r\n\r\n        BigInteger.prototype.times = BigInteger.prototype.multiply;\r\n\r\n        function multiplySmallAndArray(a, b, sign) { // a >= 0\r\n          if (a < BASE) {\r\n            return new BigInteger(multiplySmall(b, a), sign);\r\n          }\r\n          return new BigInteger(multiplyLong(b, smallToArray(a)), sign);\r\n        }\r\n        SmallInteger.prototype._multiplyBySmall = function (a) {\r\n          if (isPrecise(a.value * this.value)) {\r\n            return new SmallInteger(a.value * this.value);\r\n          }\r\n          return multiplySmallAndArray(Math.abs(a.value), smallToArray(Math.abs(this.value)), this.sign !== a.sign);\r\n        };\r\n        BigInteger.prototype._multiplyBySmall = function (a) {\r\n          if (a.value === 0) return Integer[0];\r\n          if (a.value === 1) return this;\r\n          if (a.value === -1) return this.negate();\r\n          return multiplySmallAndArray(Math.abs(a.value), this.value, this.sign !== a.sign);\r\n        };\r\n        SmallInteger.prototype.multiply = function (v) {\r\n          return parseValue(v)._multiplyBySmall(this);\r\n        };\r\n        SmallInteger.prototype.times = SmallInteger.prototype.multiply;\r\n\r\n        function square(a) {\r\n          //console.assert(2 * BASE * BASE < MAX_INT);\r\n          var l = a.length,\r\n            r = createArray(l + l),\r\n            base = BASE,\r\n            product, carry, i, a_i, a_j;\r\n          for (i = 0; i < l; i++) {\r\n            a_i = a[i];\r\n            carry = 0 - a_i * a_i;\r\n            for (var j = i; j < l; j++) {\r\n              a_j = a[j];\r\n              product = 2 * (a_i * a_j) + r[i + j] + carry;\r\n              carry = Math.floor(product / base);\r\n              r[i + j] = product - carry * base;\r\n            }\r\n            r[i + l] = carry;\r\n          }\r\n          trim(r);\r\n          return r;\r\n        }\r\n\r\n        BigInteger.prototype.square = function () {\r\n          return new BigInteger(square(this.value), false);\r\n        };\r\n\r\n        SmallInteger.prototype.square = function () {\r\n          var value = this.value * this.value;\r\n          if (isPrecise(value)) return new SmallInteger(value);\r\n          return new BigInteger(square(smallToArray(Math.abs(this.value))), false);\r\n        };\r\n\r\n        function divMod1(a, b) { // Left over from previous version. Performs faster than divMod2 on smaller input sizes.\r\n          var a_l = a.length,\r\n            b_l = b.length,\r\n            base = BASE,\r\n            result = createArray(b.length),\r\n            divisorMostSignificantDigit = b[b_l - 1],\r\n            // normalization\r\n            lambda = Math.ceil(base / (2 * divisorMostSignificantDigit)),\r\n            remainder = multiplySmall(a, lambda),\r\n            divisor = multiplySmall(b, lambda),\r\n            quotientDigit, shift, carry, borrow, i, l, q;\r\n          if (remainder.length <= a_l) remainder.push(0);\r\n          divisor.push(0);\r\n          divisorMostSignificantDigit = divisor[b_l - 1];\r\n          for (shift = a_l - b_l; shift >= 0; shift--) {\r\n            quotientDigit = base - 1;\r\n            if (remainder[shift + b_l] !== divisorMostSignificantDigit) {\r\n              quotientDigit = Math.floor((remainder[shift + b_l] * base + remainder[shift + b_l - 1]) / divisorMostSignificantDigit);\r\n            }\r\n            // quotientDigit <= base - 1\r\n            carry = 0;\r\n            borrow = 0;\r\n            l = divisor.length;\r\n            for (i = 0; i < l; i++) {\r\n              carry += quotientDigit * divisor[i];\r\n              q = Math.floor(carry / base);\r\n              borrow += remainder[shift + i] - (carry - q * base);\r\n              carry = q;\r\n              if (borrow < 0) {\r\n                remainder[shift + i] = borrow + base;\r\n                borrow = -1;\r\n              } else {\r\n                remainder[shift + i] = borrow;\r\n                borrow = 0;\r\n              }\r\n            }\r\n            while (borrow !== 0) {\r\n              quotientDigit -= 1;\r\n              carry = 0;\r\n              for (i = 0; i < l; i++) {\r\n                carry += remainder[shift + i] - base + divisor[i];\r\n                if (carry < 0) {\r\n                  remainder[shift + i] = carry + base;\r\n                  carry = 0;\r\n                } else {\r\n                  remainder[shift + i] = carry;\r\n                  carry = 1;\r\n                }\r\n              }\r\n              borrow += carry;\r\n            }\r\n            result[shift] = quotientDigit;\r\n          }\r\n          // denormalization\r\n          remainder = divModSmall(remainder, lambda)[0];\r\n          return [arrayToSmall(result), arrayToSmall(remainder)];\r\n        }\r\n\r\n        function divMod2(a, b) { // Implementation idea shamelessly stolen from Silent Matt's library http://silentmatt.com/biginteger/\r\n          // Performs faster than divMod1 on larger input sizes.\r\n          var a_l = a.length,\r\n            b_l = b.length,\r\n            result = [],\r\n            part = [],\r\n            base = BASE,\r\n            guess, xlen, highx, highy, check;\r\n          while (a_l) {\r\n            part.unshift(a[--a_l]);\r\n            trim(part);\r\n            if (compareAbs(part, b) < 0) {\r\n              result.push(0);\r\n              continue;\r\n            }\r\n            xlen = part.length;\r\n            highx = part[xlen - 1] * base + part[xlen - 2];\r\n            highy = b[b_l - 1] * base + b[b_l - 2];\r\n            if (xlen > b_l) {\r\n              highx = (highx + 1) * base;\r\n            }\r\n            guess = Math.ceil(highx / highy);\r\n            do {\r\n              check = multiplySmall(b, guess);\r\n              if (compareAbs(check, part) <= 0) break;\r\n              guess--;\r\n            } while (guess);\r\n            result.push(guess);\r\n            part = subtract(part, check);\r\n          }\r\n          result.reverse();\r\n          return [arrayToSmall(result), arrayToSmall(part)];\r\n        }\r\n\r\n        function divModSmall(value, lambda) {\r\n          var length = value.length,\r\n            quotient = createArray(length),\r\n            base = BASE,\r\n            i, q, remainder, divisor;\r\n          remainder = 0;\r\n          for (i = length - 1; i >= 0; --i) {\r\n            divisor = remainder * base + value[i];\r\n            q = truncate(divisor / lambda);\r\n            remainder = divisor - q * lambda;\r\n            quotient[i] = q | 0;\r\n          }\r\n          return [quotient, remainder | 0];\r\n        }\r\n\r\n        function divModAny(self, v) {\r\n          var value, n = parseValue(v);\r\n          var a = self.value,\r\n            b = n.value;\r\n          var quotient;\r\n          if (b === 0) throw new Error(\"Cannot divide by zero\");\r\n          if (self.isSmall) {\r\n            if (n.isSmall) {\r\n              return [new SmallInteger(truncate(a / b)), new SmallInteger(a % b)];\r\n            }\r\n            return [Integer[0], self];\r\n          }\r\n          if (n.isSmall) {\r\n            if (b === 1) return [self, Integer[0]];\r\n            if (b == -1) return [self.negate(), Integer[0]];\r\n            var abs = Math.abs(b);\r\n            if (abs < BASE) {\r\n              value = divModSmall(a, abs);\r\n              quotient = arrayToSmall(value[0]);\r\n              var remainder = value[1];\r\n              if (self.sign) remainder = -remainder;\r\n              if (typeof quotient === \"number\") {\r\n                if (self.sign !== n.sign) quotient = -quotient;\r\n                return [new SmallInteger(quotient), new SmallInteger(remainder)];\r\n              }\r\n              return [new BigInteger(quotient, self.sign !== n.sign), new SmallInteger(remainder)];\r\n            }\r\n            b = smallToArray(abs);\r\n          }\r\n          var comparison = compareAbs(a, b);\r\n          if (comparison === -1) return [Integer[0], self];\r\n          if (comparison === 0) return [Integer[self.sign === n.sign ? 1 : -1], Integer[0]];\r\n\r\n          // divMod1 is faster on smaller input sizes\r\n          if (a.length + b.length <= 200)\r\n            value = divMod1(a, b);\r\n          else value = divMod2(a, b);\r\n\r\n          quotient = value[0];\r\n          var qSign = self.sign !== n.sign,\r\n            mod = value[1],\r\n            mSign = self.sign;\r\n          if (typeof quotient === \"number\") {\r\n            if (qSign) quotient = -quotient;\r\n            quotient = new SmallInteger(quotient);\r\n          } else quotient = new BigInteger(quotient, qSign);\r\n          if (typeof mod === \"number\") {\r\n            if (mSign) mod = -mod;\r\n            mod = new SmallInteger(mod);\r\n          } else mod = new BigInteger(mod, mSign);\r\n          return [quotient, mod];\r\n        }\r\n\r\n        BigInteger.prototype.divmod = function (v) {\r\n          var result = divModAny(this, v);\r\n          return {\r\n            quotient: result[0],\r\n            remainder: result[1]\r\n          };\r\n        };\r\n        SmallInteger.prototype.divmod = BigInteger.prototype.divmod;\r\n\r\n        BigInteger.prototype.divide = function (v) {\r\n          return divModAny(this, v)[0];\r\n        };\r\n        SmallInteger.prototype.over = SmallInteger.prototype.divide = BigInteger.prototype.over = BigInteger.prototype.divide;\r\n\r\n        BigInteger.prototype.mod = function (v) {\r\n          return divModAny(this, v)[1];\r\n        };\r\n        SmallInteger.prototype.remainder = SmallInteger.prototype.mod = BigInteger.prototype.remainder = BigInteger.prototype.mod;\r\n\r\n        BigInteger.prototype.pow = function (v) {\r\n          var n = parseValue(v),\r\n            a = this.value,\r\n            b = n.value,\r\n            value, x, y;\r\n          if (b === 0) return Integer[1];\r\n          if (a === 0) return Integer[0];\r\n          if (a === 1) return Integer[1];\r\n          if (a === -1) return n.isEven() ? Integer[1] : Integer[-1];\r\n          if (n.sign) {\r\n            return Integer[0];\r\n          }\r\n          if (!n.isSmall) throw new Error(\"The exponent \" + n.toString() + \" is too large.\");\r\n          if (this.isSmall) {\r\n            if (isPrecise(value = Math.pow(a, b)))\r\n              return new SmallInteger(truncate(value));\r\n          }\r\n          x = this;\r\n          y = Integer[1];\r\n          while (true) {\r\n            if (b & 1 === 1) {\r\n              y = y.times(x);\r\n              --b;\r\n            }\r\n            if (b === 0) break;\r\n            b /= 2;\r\n            x = x.square();\r\n          }\r\n          return y;\r\n        };\r\n        SmallInteger.prototype.pow = BigInteger.prototype.pow;\r\n\r\n        BigInteger.prototype.modPow = function (exp, mod) {\r\n          exp = parseValue(exp);\r\n          mod = parseValue(mod);\r\n          if (mod.isZero()) throw new Error(\"Cannot take modPow with modulus 0\");\r\n          var r = Integer[1],\r\n            base = this.mod(mod);\r\n          while (exp.isPositive()) {\r\n            if (base.isZero()) return Integer[0];\r\n            if (exp.isOdd()) r = r.multiply(base).mod(mod);\r\n            exp = exp.divide(2);\r\n            base = base.square().mod(mod);\r\n          }\r\n          return r;\r\n        };\r\n        SmallInteger.prototype.modPow = BigInteger.prototype.modPow;\r\n\r\n        function compareAbs(a, b) {\r\n          if (a.length !== b.length) {\r\n            return a.length > b.length ? 1 : -1;\r\n          }\r\n          for (var i = a.length - 1; i >= 0; i--) {\r\n            if (a[i] !== b[i]) return a[i] > b[i] ? 1 : -1;\r\n          }\r\n          return 0;\r\n        }\r\n\r\n        BigInteger.prototype.compareAbs = function (v) {\r\n          var n = parseValue(v),\r\n            a = this.value,\r\n            b = n.value;\r\n          if (n.isSmall) return 1;\r\n          return compareAbs(a, b);\r\n        };\r\n        SmallInteger.prototype.compareAbs = function (v) {\r\n          var n = parseValue(v),\r\n            a = Math.abs(this.value),\r\n            b = n.value;\r\n          if (n.isSmall) {\r\n            b = Math.abs(b);\r\n            return a === b ? 0 : a > b ? 1 : -1;\r\n          }\r\n          return -1;\r\n        };\r\n\r\n        BigInteger.prototype.compare = function (v) {\r\n          // See discussion about comparison with Infinity:\r\n          // https://github.com/peterolson/BigInteger.js/issues/61\r\n          if (v === Infinity) {\r\n            return -1;\r\n          }\r\n          if (v === -Infinity) {\r\n            return 1;\r\n          }\r\n\r\n          var n = parseValue(v),\r\n            a = this.value,\r\n            b = n.value;\r\n          if (this.sign !== n.sign) {\r\n            return n.sign ? 1 : -1;\r\n          }\r\n          if (n.isSmall) {\r\n            return this.sign ? -1 : 1;\r\n          }\r\n          return compareAbs(a, b) * (this.sign ? -1 : 1);\r\n        };\r\n        BigInteger.prototype.compareTo = BigInteger.prototype.compare;\r\n\r\n        SmallInteger.prototype.compare = function (v) {\r\n          if (v === Infinity) {\r\n            return -1;\r\n          }\r\n          if (v === -Infinity) {\r\n            return 1;\r\n          }\r\n\r\n          var n = parseValue(v),\r\n            a = this.value,\r\n            b = n.value;\r\n          if (n.isSmall) {\r\n            return a == b ? 0 : a > b ? 1 : -1;\r\n          }\r\n          if (a < 0 !== n.sign) {\r\n            return a < 0 ? -1 : 1;\r\n          }\r\n          return a < 0 ? 1 : -1;\r\n        };\r\n        SmallInteger.prototype.compareTo = SmallInteger.prototype.compare;\r\n\r\n        BigInteger.prototype.equals = function (v) {\r\n          return this.compare(v) === 0;\r\n        };\r\n        SmallInteger.prototype.eq = SmallInteger.prototype.equals = BigInteger.prototype.eq = BigInteger.prototype.equals;\r\n\r\n        BigInteger.prototype.notEquals = function (v) {\r\n          return this.compare(v) !== 0;\r\n        };\r\n        SmallInteger.prototype.neq = SmallInteger.prototype.notEquals = BigInteger.prototype.neq = BigInteger.prototype.notEquals;\r\n\r\n        BigInteger.prototype.greater = function (v) {\r\n          return this.compare(v) > 0;\r\n        };\r\n        SmallInteger.prototype.gt = SmallInteger.prototype.greater = BigInteger.prototype.gt = BigInteger.prototype.greater;\r\n\r\n        BigInteger.prototype.lesser = function (v) {\r\n          return this.compare(v) < 0;\r\n        };\r\n        SmallInteger.prototype.lt = SmallInteger.prototype.lesser = BigInteger.prototype.lt = BigInteger.prototype.lesser;\r\n\r\n        BigInteger.prototype.greaterOrEquals = function (v) {\r\n          return this.compare(v) >= 0;\r\n        };\r\n        SmallInteger.prototype.geq = SmallInteger.prototype.greaterOrEquals = BigInteger.prototype.geq = BigInteger.prototype.greaterOrEquals;\r\n\r\n        BigInteger.prototype.lesserOrEquals = function (v) {\r\n          return this.compare(v) <= 0;\r\n        };\r\n        SmallInteger.prototype.leq = SmallInteger.prototype.lesserOrEquals = BigInteger.prototype.leq = BigInteger.prototype.lesserOrEquals;\r\n\r\n        BigInteger.prototype.isEven = function () {\r\n          return (this.value[0] & 1) === 0;\r\n        };\r\n        SmallInteger.prototype.isEven = function () {\r\n          return (this.value & 1) === 0;\r\n        };\r\n\r\n        BigInteger.prototype.isOdd = function () {\r\n          return (this.value[0] & 1) === 1;\r\n        };\r\n        SmallInteger.prototype.isOdd = function () {\r\n          return (this.value & 1) === 1;\r\n        };\r\n\r\n        BigInteger.prototype.isPositive = function () {\r\n          return !this.sign;\r\n        };\r\n        SmallInteger.prototype.isPositive = function () {\r\n          return this.value > 0;\r\n        };\r\n\r\n        BigInteger.prototype.isNegative = function () {\r\n          return this.sign;\r\n        };\r\n        SmallInteger.prototype.isNegative = function () {\r\n          return this.value < 0;\r\n        };\r\n\r\n        BigInteger.prototype.isUnit = function () {\r\n          return false;\r\n        };\r\n        SmallInteger.prototype.isUnit = function () {\r\n          return Math.abs(this.value) === 1;\r\n        };\r\n\r\n        BigInteger.prototype.isZero = function () {\r\n          return false;\r\n        };\r\n        SmallInteger.prototype.isZero = function () {\r\n          return this.value === 0;\r\n        };\r\n        BigInteger.prototype.isDivisibleBy = function (v) {\r\n          var n = parseValue(v);\r\n          var value = n.value;\r\n          if (value === 0) return false;\r\n          if (value === 1) return true;\r\n          if (value === 2) return this.isEven();\r\n          return this.mod(n).equals(Integer[0]);\r\n        };\r\n        SmallInteger.prototype.isDivisibleBy = BigInteger.prototype.isDivisibleBy;\r\n\r\n        function isBasicPrime(v) {\r\n          var n = v.abs();\r\n          if (n.isUnit()) return false;\r\n          if (n.equals(2) || n.equals(3) || n.equals(5)) return true;\r\n          if (n.isEven() || n.isDivisibleBy(3) || n.isDivisibleBy(5)) return false;\r\n          if (n.lesser(49)) return true;\r\n          // we don't know if it's prime: let the other functions figure it out\r\n        }\r\n\r\n        function millerRabinTest(n, a) {\r\n          var nPrev = n.prev(),\r\n            b = nPrev,\r\n            r = 0,\r\n            d, t, i, x;\r\n          while (b.isEven()) b = b.divide(2), r++;\r\n          next: for (i = 0; i < a.length; i++) {\r\n            if (n.lesser(a[i])) continue;\r\n            x = bigInt(a[i]).modPow(b, n);\r\n            if (x.equals(Integer[1]) || x.equals(nPrev)) continue;\r\n            for (d = r - 1; d != 0; d--) {\r\n              x = x.square().mod(n);\r\n              if (x.isUnit()) return false;\r\n              if (x.equals(nPrev)) continue next;\r\n            }\r\n            return false;\r\n          }\r\n          return true;\r\n        }\r\n\r\n        // Set \"strict\" to true to force GRH-supported lower bound of 2*log(N)^2\r\n        BigInteger.prototype.isPrime = function (strict) {\r\n          var isPrime = isBasicPrime(this);\r\n          if (isPrime !== undefined) return isPrime;\r\n          var n = this.abs();\r\n          var bits = n.bitLength();\r\n          if (bits <= 64)\r\n            return millerRabinTest(n, [2, 325, 9375, 28178, 450775, 9780504, 1795265022]);\r\n          var logN = Math.log(2) * bits;\r\n          var t = Math.ceil((strict === true) ? (2 * Math.pow(logN, 2)) : logN);\r\n          for (var a = [], i = 0; i < t; i++) {\r\n            a.push(bigInt(i + 2));\r\n          }\r\n          return millerRabinTest(n, a);\r\n        };\r\n        SmallInteger.prototype.isPrime = BigInteger.prototype.isPrime;\r\n\r\n        BigInteger.prototype.isProbablePrime = function (iterations) {\r\n          var isPrime = isBasicPrime(this);\r\n          if (isPrime !== undefined) return isPrime;\r\n          var n = this.abs();\r\n          var t = iterations === undefined ? 5 : iterations;\r\n          for (var a = [], i = 0; i < t; i++) {\r\n            a.push(bigInt.randBetween(2, n.minus(2)));\r\n          }\r\n          return millerRabinTest(n, a);\r\n        };\r\n        SmallInteger.prototype.isProbablePrime = BigInteger.prototype.isProbablePrime;\r\n\r\n        BigInteger.prototype.modInv = function (n) {\r\n          var t = bigInt.zero,\r\n            newT = bigInt.one,\r\n            r = parseValue(n),\r\n            newR = this.abs(),\r\n            q, lastT, lastR;\r\n          while (!newR.equals(bigInt.zero)) {\r\n            q = r.divide(newR);\r\n            lastT = t;\r\n            lastR = r;\r\n            t = newT;\r\n            r = newR;\r\n            newT = lastT.subtract(q.multiply(newT));\r\n            newR = lastR.subtract(q.multiply(newR));\r\n          }\r\n          if (!r.equals(1)) throw new Error(this.toString() + \" and \" + n.toString() + \" are not co-prime\");\r\n          if (t.compare(0) === -1) {\r\n            t = t.add(n);\r\n          }\r\n          if (this.isNegative()) {\r\n            return t.negate();\r\n          }\r\n          return t;\r\n        };\r\n\r\n        SmallInteger.prototype.modInv = BigInteger.prototype.modInv;\r\n\r\n        BigInteger.prototype.next = function () {\r\n          var value = this.value;\r\n          if (this.sign) {\r\n            return subtractSmall(value, 1, this.sign);\r\n          }\r\n          return new BigInteger(addSmall(value, 1), this.sign);\r\n        };\r\n        SmallInteger.prototype.next = function () {\r\n          var value = this.value;\r\n          if (value + 1 < MAX_INT) return new SmallInteger(value + 1);\r\n          return new BigInteger(MAX_INT_ARR, false);\r\n        };\r\n\r\n        BigInteger.prototype.prev = function () {\r\n          var value = this.value;\r\n          if (this.sign) {\r\n            return new BigInteger(addSmall(value, 1), true);\r\n          }\r\n          return subtractSmall(value, 1, this.sign);\r\n        };\r\n        SmallInteger.prototype.prev = function () {\r\n          var value = this.value;\r\n          if (value - 1 > -MAX_INT) return new SmallInteger(value - 1);\r\n          return new BigInteger(MAX_INT_ARR, true);\r\n        };\r\n\r\n        var powersOfTwo = [1];\r\n        while (2 * powersOfTwo[powersOfTwo.length - 1] <= BASE) powersOfTwo.push(2 * powersOfTwo[powersOfTwo.length - 1]);\r\n        var powers2Length = powersOfTwo.length,\r\n          highestPower2 = powersOfTwo[powers2Length - 1];\r\n\r\n        function shift_isSmall(n) {\r\n          return ((typeof n === \"number\" || typeof n === \"string\") && +Math.abs(n) <= BASE) ||\r\n            (n instanceof BigInteger && n.value.length <= 1);\r\n        }\r\n\r\n        BigInteger.prototype.shiftLeft = function (n) {\r\n          if (!shift_isSmall(n)) {\r\n            throw new Error(String(n) + \" is too large for shifting.\");\r\n          }\r\n          n = +n;\r\n          if (n < 0) return this.shiftRight(-n);\r\n          var result = this;\r\n          if (result.isZero()) return result;\r\n          while (n >= powers2Length) {\r\n            result = result.multiply(highestPower2);\r\n            n -= powers2Length - 1;\r\n          }\r\n          return result.multiply(powersOfTwo[n]);\r\n        };\r\n        SmallInteger.prototype.shiftLeft = BigInteger.prototype.shiftLeft;\r\n\r\n        BigInteger.prototype.shiftRight = function (n) {\r\n          var remQuo;\r\n          if (!shift_isSmall(n)) {\r\n            throw new Error(String(n) + \" is too large for shifting.\");\r\n          }\r\n          n = +n;\r\n          if (n < 0) return this.shiftLeft(-n);\r\n          var result = this;\r\n          while (n >= powers2Length) {\r\n            if (result.isZero() || (result.isNegative() && result.isUnit())) return result;\r\n            remQuo = divModAny(result, highestPower2);\r\n            result = remQuo[1].isNegative() ? remQuo[0].prev() : remQuo[0];\r\n            n -= powers2Length - 1;\r\n          }\r\n          remQuo = divModAny(result, powersOfTwo[n]);\r\n          return remQuo[1].isNegative() ? remQuo[0].prev() : remQuo[0];\r\n        };\r\n        SmallInteger.prototype.shiftRight = BigInteger.prototype.shiftRight;\r\n\r\n        function bitwise(x, y, fn) {\r\n          y = parseValue(y);\r\n          var xSign = x.isNegative(),\r\n            ySign = y.isNegative();\r\n          var xRem = xSign ? x.not() : x,\r\n            yRem = ySign ? y.not() : y;\r\n          var xDigit = 0,\r\n            yDigit = 0;\r\n          var xDivMod = null,\r\n            yDivMod = null;\r\n          var result = [];\r\n          while (!xRem.isZero() || !yRem.isZero()) {\r\n            xDivMod = divModAny(xRem, highestPower2);\r\n            xDigit = xDivMod[1].toJSNumber();\r\n            if (xSign) {\r\n              xDigit = highestPower2 - 1 - xDigit; // two's complement for negative numbers\r\n            }\r\n\r\n            yDivMod = divModAny(yRem, highestPower2);\r\n            yDigit = yDivMod[1].toJSNumber();\r\n            if (ySign) {\r\n              yDigit = highestPower2 - 1 - yDigit; // two's complement for negative numbers\r\n            }\r\n\r\n            xRem = xDivMod[0];\r\n            yRem = yDivMod[0];\r\n            result.push(fn(xDigit, yDigit));\r\n          }\r\n          var sum = fn(xSign ? 1 : 0, ySign ? 1 : 0) !== 0 ? bigInt(-1) : bigInt(0);\r\n          for (var i = result.length - 1; i >= 0; i -= 1) {\r\n            sum = sum.multiply(highestPower2).add(bigInt(result[i]));\r\n          }\r\n          return sum;\r\n        }\r\n\r\n        BigInteger.prototype.not = function () {\r\n          return this.negate().prev();\r\n        };\r\n        SmallInteger.prototype.not = BigInteger.prototype.not;\r\n\r\n        BigInteger.prototype.and = function (n) {\r\n          return bitwise(this, n, function (a, b) {\r\n            return a & b;\r\n          });\r\n        };\r\n        SmallInteger.prototype.and = BigInteger.prototype.and;\r\n\r\n        BigInteger.prototype.or = function (n) {\r\n          return bitwise(this, n, function (a, b) {\r\n            return a | b;\r\n          });\r\n        };\r\n        SmallInteger.prototype.or = BigInteger.prototype.or;\r\n\r\n        BigInteger.prototype.xor = function (n) {\r\n          return bitwise(this, n, function (a, b) {\r\n            return a ^ b;\r\n          });\r\n        };\r\n        SmallInteger.prototype.xor = BigInteger.prototype.xor;\r\n\r\n        var LOBMASK_I = 1 << 30,\r\n          LOBMASK_BI = (BASE & -BASE) * (BASE & -BASE) | LOBMASK_I;\r\n\r\n        function roughLOB(n) { // get lowestOneBit (rough)\r\n          // SmallInteger: return Min(lowestOneBit(n), 1 << 30)\r\n          // BigInteger: return Min(lowestOneBit(n), 1 << 14) [BASE=1e7]\r\n          var v = n.value,\r\n            x = typeof v === \"number\" ? v | LOBMASK_I : v[0] + v[1] * BASE | LOBMASK_BI;\r\n          return x & -x;\r\n        }\r\n\r\n        function integerLogarithm(value, base) {\r\n          if (base.compareTo(value) <= 0) {\r\n            var tmp = integerLogarithm(value, base.square(base));\r\n            var p = tmp.p;\r\n            var e = tmp.e;\r\n            var t = p.multiply(base);\r\n            return t.compareTo(value) <= 0 ? {\r\n              p: t,\r\n              e: e * 2 + 1\r\n            } : {\r\n              p: p,\r\n              e: e * 2\r\n            };\r\n          }\r\n          return {\r\n            p: bigInt(1),\r\n            e: 0\r\n          };\r\n        }\r\n\r\n        BigInteger.prototype.bitLength = function () {\r\n          var n = this;\r\n          if (n.compareTo(bigInt(0)) < 0) {\r\n            n = n.negate().subtract(bigInt(1));\r\n          }\r\n          if (n.compareTo(bigInt(0)) === 0) {\r\n            return bigInt(0);\r\n          }\r\n          return bigInt(integerLogarithm(n, bigInt(2)).e).add(bigInt(1));\r\n        }\r\n        SmallInteger.prototype.bitLength = BigInteger.prototype.bitLength;\r\n\r\n        function max(a, b) {\r\n          a = parseValue(a);\r\n          b = parseValue(b);\r\n          return a.greater(b) ? a : b;\r\n        }\r\n\r\n        function min(a, b) {\r\n          a = parseValue(a);\r\n          b = parseValue(b);\r\n          return a.lesser(b) ? a : b;\r\n        }\r\n\r\n        function gcd(a, b) {\r\n          a = parseValue(a).abs();\r\n          b = parseValue(b).abs();\r\n          if (a.equals(b)) return a;\r\n          if (a.isZero()) return b;\r\n          if (b.isZero()) return a;\r\n          var c = Integer[1],\r\n            d, t;\r\n          while (a.isEven() && b.isEven()) {\r\n            d = Math.min(roughLOB(a), roughLOB(b));\r\n            a = a.divide(d);\r\n            b = b.divide(d);\r\n            c = c.multiply(d);\r\n          }\r\n          while (a.isEven()) {\r\n            a = a.divide(roughLOB(a));\r\n          }\r\n          do {\r\n            while (b.isEven()) {\r\n              b = b.divide(roughLOB(b));\r\n            }\r\n            if (a.greater(b)) {\r\n              t = b;\r\n              b = a;\r\n              a = t;\r\n            }\r\n            b = b.subtract(a);\r\n          } while (!b.isZero());\r\n          return c.isUnit() ? a : a.multiply(c);\r\n        }\r\n\r\n        function lcm(a, b) {\r\n          a = parseValue(a).abs();\r\n          b = parseValue(b).abs();\r\n          return a.divide(gcd(a, b)).multiply(b);\r\n        }\r\n\r\n        function randBetween(a, b) {\r\n          a = parseValue(a);\r\n          b = parseValue(b);\r\n          var low = min(a, b),\r\n            high = max(a, b);\r\n          var range = high.subtract(low).add(1);\r\n          if (range.isSmall) return low.add(Math.floor(Math.random() * range));\r\n          var length = range.value.length - 1;\r\n          var result = [],\r\n            restricted = true;\r\n          for (var i = length; i >= 0; i--) {\r\n            var top = restricted ? range.value[i] : BASE;\r\n            var digit = truncate(Math.random() * top);\r\n            result.unshift(digit);\r\n            if (digit < top) restricted = false;\r\n          }\r\n          result = arrayToSmall(result);\r\n          return low.add(typeof result === \"number\" ? new SmallInteger(result) : new BigInteger(result, false));\r\n        }\r\n        var parseBase = function (text, base) {\r\n          var length = text.length;\r\n          var i;\r\n          var absBase = Math.abs(base);\r\n          for (var i = 0; i < length; i++) {\r\n            var c = text[i].toLowerCase();\r\n            if (c === \"-\") continue;\r\n            if (/[a-z0-9]/.test(c)) {\r\n              if (/[0-9]/.test(c) && +c >= absBase) {\r\n                if (c === \"1\" && absBase === 1) continue;\r\n                throw new Error(c + \" is not a valid digit in base \" + base + \".\");\r\n              } else if (c.charCodeAt(0) - 87 >= absBase) {\r\n                throw new Error(c + \" is not a valid digit in base \" + base + \".\");\r\n              }\r\n            }\r\n          }\r\n          if (2 <= base && base <= 36) {\r\n            if (length <= LOG_MAX_INT / Math.log(base)) {\r\n              var result = parseInt(text, base);\r\n              if (isNaN(result)) {\r\n                throw new Error(c + \" is not a valid digit in base \" + base + \".\");\r\n              }\r\n              return new SmallInteger(parseInt(text, base));\r\n            }\r\n          }\r\n          base = parseValue(base);\r\n          var digits = [];\r\n          var isNegative = text[0] === \"-\";\r\n          for (i = isNegative ? 1 : 0; i < text.length; i++) {\r\n            var c = text[i].toLowerCase(),\r\n              charCode = c.charCodeAt(0);\r\n            if (48 <= charCode && charCode <= 57) digits.push(parseValue(c));\r\n            else if (97 <= charCode && charCode <= 122) digits.push(parseValue(c.charCodeAt(0) - 87));\r\n            else if (c === \"<\") {\r\n              var start = i;\r\n              do {\r\n                i++;\r\n              } while (text[i] !== \">\");\r\n              digits.push(parseValue(text.slice(start + 1, i)));\r\n            } else throw new Error(c + \" is not a valid character\");\r\n          }\r\n          return parseBaseFromArray(digits, base, isNegative);\r\n        };\r\n\r\n        function parseBaseFromArray(digits, base, isNegative) {\r\n          var val = Integer[0],\r\n            pow = Integer[1],\r\n            i;\r\n          for (i = digits.length - 1; i >= 0; i--) {\r\n            val = val.add(digits[i].times(pow));\r\n            pow = pow.times(base);\r\n          }\r\n          return isNegative ? val.negate() : val;\r\n        }\r\n\r\n        function stringify(digit) {\r\n          if (digit <= 35) {\r\n            return \"0123456789abcdefghijklmnopqrstuvwxyz\".charAt(digit);\r\n          }\r\n          return \"<\" + digit + \">\";\r\n        }\r\n\r\n        function toBase(n, base) {\r\n          base = bigInt(base);\r\n          if (base.isZero()) {\r\n            if (n.isZero()) return {\r\n              value: [0],\r\n              isNegative: false\r\n            };\r\n            throw new Error(\"Cannot convert nonzero numbers to base 0.\");\r\n          }\r\n          if (base.equals(-1)) {\r\n            if (n.isZero()) return {\r\n              value: [0],\r\n              isNegative: false\r\n            };\r\n            if (n.isNegative())\r\n              return {\r\n                value: [].concat.apply([], Array.apply(null, Array(-n))\r\n                  .map(Array.prototype.valueOf, [1, 0])\r\n                ),\r\n                isNegative: false\r\n              };\r\n\r\n            var arr = Array.apply(null, Array(+n - 1))\r\n              .map(Array.prototype.valueOf, [0, 1]);\r\n            arr.unshift([1]);\r\n            return {\r\n              value: [].concat.apply([], arr),\r\n              isNegative: false\r\n            };\r\n          }\r\n\r\n          var neg = false;\r\n          if (n.isNegative() && base.isPositive()) {\r\n            neg = true;\r\n            n = n.abs();\r\n          }\r\n          if (base.equals(1)) {\r\n            if (n.isZero()) return {\r\n              value: [0],\r\n              isNegative: false\r\n            };\r\n\r\n            return {\r\n              value: Array.apply(null, Array(+n))\r\n                .map(Number.prototype.valueOf, 1),\r\n              isNegative: neg\r\n            };\r\n          }\r\n          var out = [];\r\n          var left = n,\r\n            divmod;\r\n          while (left.isNegative() || left.compareAbs(base) >= 0) {\r\n            divmod = left.divmod(base);\r\n            left = divmod.quotient;\r\n            var digit = divmod.remainder;\r\n            if (digit.isNegative()) {\r\n              digit = base.minus(digit).abs();\r\n              left = left.next();\r\n            }\r\n            out.push(digit.toJSNumber());\r\n          }\r\n          out.push(left.toJSNumber());\r\n          return {\r\n            value: out.reverse(),\r\n            isNegative: neg\r\n          };\r\n        }\r\n\r\n        function toBaseString(n, base) {\r\n          var arr = toBase(n, base);\r\n          return (arr.isNegative ? \"-\" : \"\") + arr.value.map(stringify).join('');\r\n        }\r\n\r\n        BigInteger.prototype.toArray = function (radix) {\r\n          return toBase(this, radix);\r\n        };\r\n\r\n        SmallInteger.prototype.toArray = function (radix) {\r\n          return toBase(this, radix);\r\n        };\r\n\r\n        BigInteger.prototype.toString = function (radix) {\r\n          if (radix === undefined) radix = 10;\r\n          if (radix !== 10) return toBaseString(this, radix);\r\n          var v = this.value,\r\n            l = v.length,\r\n            str = String(v[--l]),\r\n            zeros = \"0000000\",\r\n            digit;\r\n          while (--l >= 0) {\r\n            digit = String(v[l]);\r\n            str += zeros.slice(digit.length) + digit;\r\n          }\r\n          var sign = this.sign ? \"-\" : \"\";\r\n          return sign + str;\r\n        };\r\n\r\n        SmallInteger.prototype.toString = function (radix) {\r\n          if (radix === undefined) radix = 10;\r\n          if (radix != 10) return toBaseString(this, radix);\r\n          return String(this.value);\r\n        };\r\n        BigInteger.prototype.toJSON = SmallInteger.prototype.toJSON = function () {\r\n          return this.toString();\r\n        }\r\n\r\n        BigInteger.prototype.valueOf = function () {\r\n          return parseInt(this.toString(), 10);\r\n        };\r\n        BigInteger.prototype.toJSNumber = BigInteger.prototype.valueOf;\r\n\r\n        SmallInteger.prototype.valueOf = function () {\r\n          return this.value;\r\n        };\r\n        SmallInteger.prototype.toJSNumber = SmallInteger.prototype.valueOf;\r\n\r\n        function parseStringValue(v) {\r\n          if (isPrecise(+v)) {\r\n            var x = +v;\r\n            if (x === truncate(x))\r\n              return new SmallInteger(x);\r\n            throw new Error(\"Invalid integer: \" + v);\r\n          }\r\n          var sign = v[0] === \"-\";\r\n          if (sign) v = v.slice(1);\r\n          var split = v.split(/e/i);\r\n          if (split.length > 2) throw new Error(\"Invalid integer: \" + split.join(\"e\"));\r\n          if (split.length === 2) {\r\n            var exp = split[1];\r\n            if (exp[0] === \"+\") exp = exp.slice(1);\r\n            exp = +exp;\r\n            if (exp !== truncate(exp) || !isPrecise(exp)) throw new Error(\"Invalid integer: \" + exp + \" is not a valid exponent.\");\r\n            var text = split[0];\r\n            var decimalPlace = text.indexOf(\".\");\r\n            if (decimalPlace >= 0) {\r\n              exp -= text.length - decimalPlace - 1;\r\n              text = text.slice(0, decimalPlace) + text.slice(decimalPlace + 1);\r\n            }\r\n            if (exp < 0) throw new Error(\"Cannot include negative exponent part for integers\");\r\n            text += (new Array(exp + 1)).join(\"0\");\r\n            v = text;\r\n          }\r\n          var isValid = /^([0-9][0-9]*)$/.test(v);\r\n          if (!isValid) throw new Error(\"Invalid integer: \" + v);\r\n          var r = [],\r\n            max = v.length,\r\n            l = LOG_BASE,\r\n            min = max - l;\r\n          while (max > 0) {\r\n            r.push(+v.slice(min, max));\r\n            min -= l;\r\n            if (min < 0) min = 0;\r\n            max -= l;\r\n          }\r\n          trim(r);\r\n          return new BigInteger(r, sign);\r\n        }\r\n\r\n        function parseNumberValue(v) {\r\n          if (isPrecise(v)) {\r\n            if (v !== truncate(v)) throw new Error(v + \" is not an integer.\");\r\n            return new SmallInteger(v);\r\n          }\r\n          return parseStringValue(v.toString());\r\n        }\r\n\r\n        function parseValue(v) {\r\n          if (typeof v === \"number\") {\r\n            return parseNumberValue(v);\r\n          }\r\n          if (typeof v === \"string\") {\r\n            return parseStringValue(v);\r\n          }\r\n          return v;\r\n        }\r\n        // Pre-define numbers in range [-999,999]\r\n        for (var i = 0; i < 1000; i++) {\r\n          Integer[i] = new SmallInteger(i);\r\n          if (i > 0) Integer[-i] = new SmallInteger(-i);\r\n        }\r\n        // Backwards compatibility\r\n        Integer.one = Integer[1];\r\n        Integer.zero = Integer[0];\r\n        Integer.minusOne = Integer[-1];\r\n        Integer.max = max;\r\n        Integer.min = min;\r\n        Integer.gcd = gcd;\r\n        Integer.lcm = lcm;\r\n        Integer.isInstance = function (x) {\r\n          return x instanceof BigInteger || x instanceof SmallInteger;\r\n        };\r\n        Integer.randBetween = randBetween;\r\n\r\n        Integer.fromArray = function (digits, base, isNegative) {\r\n          return parseBaseFromArray(digits.map(parseValue), parseValue(base || 10), isNegative);\r\n        };\r\n\r\n        return Integer;\r\n      })();\r\n\r\n      // Node.js check\r\n      if (typeof module !== \"undefined\" && module.hasOwnProperty(\"exports\")) {\r\n        module.exports = bigInt;\r\n      }\r\n\r\n      //amd check\r\n      if (typeof define === \"function\" && define.amd) {\r\n        define(\"big-integer\", [], function () {\r\n          return bigInt;\r\n        });\r\n      }\r\n\r\n    }, {}],\r\n    23: [function (require, module, exports) {\r\n      (function (module, exports) {\r\n        'use strict';\r\n\r\n        // Utils\r\n        function assert(val, msg) {\r\n          if (!val) throw new Error(msg || 'Assertion failed');\r\n        }\r\n\r\n        // Could use `inherits` module, but don't want to move from single file\r\n        // architecture yet.\r\n        function inherits(ctor, superCtor) {\r\n          ctor.super_ = superCtor;\r\n          var TempCtor = function () {};\r\n          TempCtor.prototype = superCtor.prototype;\r\n          ctor.prototype = new TempCtor();\r\n          ctor.prototype.constructor = ctor;\r\n        }\r\n\r\n        // BN\r\n\r\n        function BN(number, base, endian) {\r\n          if (BN.isBN(number)) {\r\n            return number;\r\n          }\r\n\r\n          this.negative = 0;\r\n          this.words = null;\r\n          this.length = 0;\r\n\r\n          // Reduction context\r\n          this.red = null;\r\n\r\n          if (number !== null) {\r\n            if (base === 'le' || base === 'be') {\r\n              endian = base;\r\n              base = 10;\r\n            }\r\n\r\n            this._init(number || 0, base || 10, endian || 'be');\r\n          }\r\n        }\r\n        if (typeof module === 'object') {\r\n          module.exports = BN;\r\n        } else {\r\n          exports.BN = BN;\r\n        }\r\n\r\n        BN.BN = BN;\r\n        BN.wordSize = 26;\r\n\r\n        var Buffer;\r\n        try {\r\n          Buffer = require('buffer').Buffer;\r\n        } catch (e) {}\r\n\r\n        BN.isBN = function isBN(num) {\r\n          if (num instanceof BN) {\r\n            return true;\r\n          }\r\n\r\n          return num !== null && typeof num === 'object' &&\r\n            num.constructor.wordSize === BN.wordSize && Array.isArray(num.words);\r\n        };\r\n\r\n        BN.max = function max(left, right) {\r\n          if (left.cmp(right) > 0) return left;\r\n          return right;\r\n        };\r\n\r\n        BN.min = function min(left, right) {\r\n          if (left.cmp(right) < 0) return left;\r\n          return right;\r\n        };\r\n\r\n        BN.prototype._init = function init(number, base, endian) {\r\n          if (typeof number === 'number') {\r\n            return this._initNumber(number, base, endian);\r\n          }\r\n\r\n          if (typeof number === 'object') {\r\n            return this._initArray(number, base, endian);\r\n          }\r\n\r\n          if (base === 'hex') {\r\n            base = 16;\r\n          }\r\n          assert(base === (base | 0) && base >= 2 && base <= 36);\r\n\r\n          number = number.toString().replace(/\\s+/g, '');\r\n          var start = 0;\r\n          if (number[0] === '-') {\r\n            start++;\r\n          }\r\n\r\n          if (base === 16) {\r\n            this._parseHex(number, start);\r\n          } else {\r\n            this._parseBase(number, base, start);\r\n          }\r\n\r\n          if (number[0] === '-') {\r\n            this.negative = 1;\r\n          }\r\n\r\n          this.strip();\r\n\r\n          if (endian !== 'le') return;\r\n\r\n          this._initArray(this.toArray(), base, endian);\r\n        };\r\n\r\n        BN.prototype._initNumber = function _initNumber(number, base, endian) {\r\n          if (number < 0) {\r\n            this.negative = 1;\r\n            number = -number;\r\n          }\r\n          if (number < 0x4000000) {\r\n            this.words = [number & 0x3ffffff];\r\n            this.length = 1;\r\n          } else if (number < 0x10000000000000) {\r\n            this.words = [\r\n              number & 0x3ffffff,\r\n              (number / 0x4000000) & 0x3ffffff\r\n            ];\r\n            this.length = 2;\r\n          } else {\r\n            assert(number < 0x20000000000000); // 2 ^ 53 (unsafe)\r\n            this.words = [\r\n              number & 0x3ffffff,\r\n              (number / 0x4000000) & 0x3ffffff,\r\n              1\r\n            ];\r\n            this.length = 3;\r\n          }\r\n\r\n          if (endian !== 'le') return;\r\n\r\n          // Reverse the bytes\r\n          this._initArray(this.toArray(), base, endian);\r\n        };\r\n\r\n        BN.prototype._initArray = function _initArray(number, base, endian) {\r\n          // Perhaps a Uint8Array\r\n          assert(typeof number.length === 'number');\r\n          if (number.length <= 0) {\r\n            this.words = [0];\r\n            this.length = 1;\r\n            return this;\r\n          }\r\n\r\n          this.length = Math.ceil(number.length / 3);\r\n          this.words = new Array(this.length);\r\n          for (var i = 0; i < this.length; i++) {\r\n            this.words[i] = 0;\r\n          }\r\n\r\n          var j, w;\r\n          var off = 0;\r\n          if (endian === 'be') {\r\n            for (i = number.length - 1, j = 0; i >= 0; i -= 3) {\r\n              w = number[i] | (number[i - 1] << 8) | (number[i - 2] << 16);\r\n              this.words[j] |= (w << off) & 0x3ffffff;\r\n              this.words[j + 1] = (w >>> (26 - off)) & 0x3ffffff;\r\n              off += 24;\r\n              if (off >= 26) {\r\n                off -= 26;\r\n                j++;\r\n              }\r\n            }\r\n          } else if (endian === 'le') {\r\n            for (i = 0, j = 0; i < number.length; i += 3) {\r\n              w = number[i] | (number[i + 1] << 8) | (number[i + 2] << 16);\r\n              this.words[j] |= (w << off) & 0x3ffffff;\r\n              this.words[j + 1] = (w >>> (26 - off)) & 0x3ffffff;\r\n              off += 24;\r\n              if (off >= 26) {\r\n                off -= 26;\r\n                j++;\r\n              }\r\n            }\r\n          }\r\n          return this.strip();\r\n        };\r\n\r\n        function parseHex(str, start, end) {\r\n          var r = 0;\r\n          var len = Math.min(str.length, end);\r\n          for (var i = start; i < len; i++) {\r\n            var c = str.charCodeAt(i) - 48;\r\n\r\n            r <<= 4;\r\n\r\n            // 'a' - 'f'\r\n            if (c >= 49 && c <= 54) {\r\n              r |= c - 49 + 0xa;\r\n\r\n              // 'A' - 'F'\r\n            } else if (c >= 17 && c <= 22) {\r\n              r |= c - 17 + 0xa;\r\n\r\n              // '0' - '9'\r\n            } else {\r\n              r |= c & 0xf;\r\n            }\r\n          }\r\n          return r;\r\n        }\r\n\r\n        BN.prototype._parseHex = function _parseHex(number, start) {\r\n          // Create possibly bigger array to ensure that it fits the number\r\n          this.length = Math.ceil((number.length - start) / 6);\r\n          this.words = new Array(this.length);\r\n          for (var i = 0; i < this.length; i++) {\r\n            this.words[i] = 0;\r\n          }\r\n\r\n          var j, w;\r\n          // Scan 24-bit chunks and add them to the number\r\n          var off = 0;\r\n          for (i = number.length - 6, j = 0; i >= start; i -= 6) {\r\n            w = parseHex(number, i, i + 6);\r\n            this.words[j] |= (w << off) & 0x3ffffff;\r\n            // NOTE: `0x3fffff` is intentional here, 26bits max shift + 24bit hex limb\r\n            this.words[j + 1] |= w >>> (26 - off) & 0x3fffff;\r\n            off += 24;\r\n            if (off >= 26) {\r\n              off -= 26;\r\n              j++;\r\n            }\r\n          }\r\n          if (i + 6 !== start) {\r\n            w = parseHex(number, start, i + 6);\r\n            this.words[j] |= (w << off) & 0x3ffffff;\r\n            this.words[j + 1] |= w >>> (26 - off) & 0x3fffff;\r\n          }\r\n          this.strip();\r\n        };\r\n\r\n        function parseBase(str, start, end, mul) {\r\n          var r = 0;\r\n          var len = Math.min(str.length, end);\r\n          for (var i = start; i < len; i++) {\r\n            var c = str.charCodeAt(i) - 48;\r\n\r\n            r *= mul;\r\n\r\n            // 'a'\r\n            if (c >= 49) {\r\n              r += c - 49 + 0xa;\r\n\r\n              // 'A'\r\n            } else if (c >= 17) {\r\n              r += c - 17 + 0xa;\r\n\r\n              // '0' - '9'\r\n            } else {\r\n              r += c;\r\n            }\r\n          }\r\n          return r;\r\n        }\r\n\r\n        BN.prototype._parseBase = function _parseBase(number, base, start) {\r\n          // Initialize as zero\r\n          this.words = [0];\r\n          this.length = 1;\r\n\r\n          // Find length of limb in base\r\n          for (var limbLen = 0, limbPow = 1; limbPow <= 0x3ffffff; limbPow *= base) {\r\n            limbLen++;\r\n          }\r\n          limbLen--;\r\n          limbPow = (limbPow / base) | 0;\r\n\r\n          var total = number.length - start;\r\n          var mod = total % limbLen;\r\n          var end = Math.min(total, total - mod) + start;\r\n\r\n          var word = 0;\r\n          for (var i = start; i < end; i += limbLen) {\r\n            word = parseBase(number, i, i + limbLen, base);\r\n\r\n            this.imuln(limbPow);\r\n            if (this.words[0] + word < 0x4000000) {\r\n              this.words[0] += word;\r\n            } else {\r\n              this._iaddn(word);\r\n            }\r\n          }\r\n\r\n          if (mod !== 0) {\r\n            var pow = 1;\r\n            word = parseBase(number, i, number.length, base);\r\n\r\n            for (i = 0; i < mod; i++) {\r\n              pow *= base;\r\n            }\r\n\r\n            this.imuln(pow);\r\n            if (this.words[0] + word < 0x4000000) {\r\n              this.words[0] += word;\r\n            } else {\r\n              this._iaddn(word);\r\n            }\r\n          }\r\n        };\r\n\r\n        BN.prototype.copy = function copy(dest) {\r\n          dest.words = new Array(this.length);\r\n          for (var i = 0; i < this.length; i++) {\r\n            dest.words[i] = this.words[i];\r\n          }\r\n          dest.length = this.length;\r\n          dest.negative = this.negative;\r\n          dest.red = this.red;\r\n        };\r\n\r\n        BN.prototype.clone = function clone() {\r\n          var r = new BN(null);\r\n          this.copy(r);\r\n          return r;\r\n        };\r\n\r\n        BN.prototype._expand = function _expand(size) {\r\n          while (this.length < size) {\r\n            this.words[this.length++] = 0;\r\n          }\r\n          return this;\r\n        };\r\n\r\n        // Remove leading `0` from `this`\r\n        BN.prototype.strip = function strip() {\r\n          while (this.length > 1 && this.words[this.length - 1] === 0) {\r\n            this.length--;\r\n          }\r\n          return this._normSign();\r\n        };\r\n\r\n        BN.prototype._normSign = function _normSign() {\r\n          // -0 = 0\r\n          if (this.length === 1 && this.words[0] === 0) {\r\n            this.negative = 0;\r\n          }\r\n          return this;\r\n        };\r\n\r\n        BN.prototype.inspect = function inspect() {\r\n          return (this.red ? '<BN-R: ' : '<BN: ') + this.toString(16) + '>';\r\n        };\r\n\r\n        /*\r\n\r\n        var zeros = [];\r\n        var groupSizes = [];\r\n        var groupBases = [];\r\n\r\n        var s = '';\r\n        var i = -1;\r\n        while (++i < BN.wordSize) {\r\n          zeros[i] = s;\r\n          s += '0';\r\n        }\r\n        groupSizes[0] = 0;\r\n        groupSizes[1] = 0;\r\n        groupBases[0] = 0;\r\n        groupBases[1] = 0;\r\n        var base = 2 - 1;\r\n        while (++base < 36 + 1) {\r\n          var groupSize = 0;\r\n          var groupBase = 1;\r\n          while (groupBase < (1 << BN.wordSize) / base) {\r\n            groupBase *= base;\r\n            groupSize += 1;\r\n          }\r\n          groupSizes[base] = groupSize;\r\n          groupBases[base] = groupBase;\r\n        }\r\n\r\n        */\r\n\r\n        var zeros = [\r\n          '',\r\n          '0',\r\n          '00',\r\n          '000',\r\n          '0000',\r\n          '00000',\r\n          '000000',\r\n          '0000000',\r\n          '00000000',\r\n          '000000000',\r\n          '0000000000',\r\n          '00000000000',\r\n          '000000000000',\r\n          '0000000000000',\r\n          '00000000000000',\r\n          '000000000000000',\r\n          '0000000000000000',\r\n          '00000000000000000',\r\n          '000000000000000000',\r\n          '0000000000000000000',\r\n          '00000000000000000000',\r\n          '000000000000000000000',\r\n          '0000000000000000000000',\r\n          '00000000000000000000000',\r\n          '000000000000000000000000',\r\n          '0000000000000000000000000'\r\n        ];\r\n\r\n        var groupSizes = [\r\n          0, 0,\r\n          25, 16, 12, 11, 10, 9, 8,\r\n          8, 7, 7, 7, 7, 6, 6,\r\n          6, 6, 6, 6, 6, 5, 5,\r\n          5, 5, 5, 5, 5, 5, 5,\r\n          5, 5, 5, 5, 5, 5, 5\r\n        ];\r\n\r\n        var groupBases = [\r\n          0, 0,\r\n          33554432, 43046721, 16777216, 48828125, 60466176, 40353607, 16777216,\r\n          43046721, 10000000, 19487171, 35831808, 62748517, 7529536, 11390625,\r\n          16777216, 24137569, 34012224, 47045881, 64000000, 4084101, 5153632,\r\n          6436343, 7962624, 9765625, 11881376, 14348907, 17210368, 20511149,\r\n          24300000, 28629151, 33554432, 39135393, 45435424, 52521875, 60466176\r\n        ];\r\n\r\n        BN.prototype.toString = function toString(base, padding) {\r\n          base = base || 10;\r\n          padding = padding | 0 || 1;\r\n\r\n          var out;\r\n          if (base === 16 || base === 'hex') {\r\n            out = '';\r\n            var off = 0;\r\n            var carry = 0;\r\n            for (var i = 0; i < this.length; i++) {\r\n              var w = this.words[i];\r\n              var word = (((w << off) | carry) & 0xffffff).toString(16);\r\n              carry = (w >>> (24 - off)) & 0xffffff;\r\n              if (carry !== 0 || i !== this.length - 1) {\r\n                out = zeros[6 - word.length] + word + out;\r\n              } else {\r\n                out = word + out;\r\n              }\r\n              off += 2;\r\n              if (off >= 26) {\r\n                off -= 26;\r\n                i--;\r\n              }\r\n            }\r\n            if (carry !== 0) {\r\n              out = carry.toString(16) + out;\r\n            }\r\n            while (out.length % padding !== 0) {\r\n              out = '0' + out;\r\n            }\r\n            if (this.negative !== 0) {\r\n              out = '-' + out;\r\n            }\r\n            return out;\r\n          }\r\n\r\n          if (base === (base | 0) && base >= 2 && base <= 36) {\r\n            // var groupSize = Math.floor(BN.wordSize * Math.LN2 / Math.log(base));\r\n            var groupSize = groupSizes[base];\r\n            // var groupBase = Math.pow(base, groupSize);\r\n            var groupBase = groupBases[base];\r\n            out = '';\r\n            var c = this.clone();\r\n            c.negative = 0;\r\n            while (!c.isZero()) {\r\n              var r = c.modn(groupBase).toString(base);\r\n              c = c.idivn(groupBase);\r\n\r\n              if (!c.isZero()) {\r\n                out = zeros[groupSize - r.length] + r + out;\r\n              } else {\r\n                out = r + out;\r\n              }\r\n            }\r\n            if (this.isZero()) {\r\n              out = '0' + out;\r\n            }\r\n            while (out.length % padding !== 0) {\r\n              out = '0' + out;\r\n            }\r\n            if (this.negative !== 0) {\r\n              out = '-' + out;\r\n            }\r\n            return out;\r\n          }\r\n\r\n          assert(false, 'Base should be between 2 and 36');\r\n        };\r\n\r\n        BN.prototype.toNumber = function toNumber() {\r\n          var ret = this.words[0];\r\n          if (this.length === 2) {\r\n            ret += this.words[1] * 0x4000000;\r\n          } else if (this.length === 3 && this.words[2] === 0x01) {\r\n            // NOTE: at this stage it is known that the top bit is set\r\n            ret += 0x10000000000000 + (this.words[1] * 0x4000000);\r\n          } else if (this.length > 2) {\r\n            assert(false, 'Number can only safely store up to 53 bits');\r\n          }\r\n          return (this.negative !== 0) ? -ret : ret;\r\n        };\r\n\r\n        BN.prototype.toJSON = function toJSON() {\r\n          return this.toString(16);\r\n        };\r\n\r\n        BN.prototype.toBuffer = function toBuffer(endian, length) {\r\n          assert(typeof Buffer !== 'undefined');\r\n          return this.toArrayLike(Buffer, endian, length);\r\n        };\r\n\r\n        BN.prototype.toArray = function toArray(endian, length) {\r\n          return this.toArrayLike(Array, endian, length);\r\n        };\r\n\r\n        BN.prototype.toArrayLike = function toArrayLike(ArrayType, endian, length) {\r\n          var byteLength = this.byteLength();\r\n          var reqLength = length || Math.max(1, byteLength);\r\n          assert(byteLength <= reqLength, 'byte array longer than desired length');\r\n          assert(reqLength > 0, 'Requested array length <= 0');\r\n\r\n          this.strip();\r\n          var littleEndian = endian === 'le';\r\n          var res = new ArrayType(reqLength);\r\n\r\n          var b, i;\r\n          var q = this.clone();\r\n          if (!littleEndian) {\r\n            // Assume big-endian\r\n            for (i = 0; i < reqLength - byteLength; i++) {\r\n              res[i] = 0;\r\n            }\r\n\r\n            for (i = 0; !q.isZero(); i++) {\r\n              b = q.andln(0xff);\r\n              q.iushrn(8);\r\n\r\n              res[reqLength - i - 1] = b;\r\n            }\r\n          } else {\r\n            for (i = 0; !q.isZero(); i++) {\r\n              b = q.andln(0xff);\r\n              q.iushrn(8);\r\n\r\n              res[i] = b;\r\n            }\r\n\r\n            for (; i < reqLength; i++) {\r\n              res[i] = 0;\r\n            }\r\n          }\r\n\r\n          return res;\r\n        };\r\n\r\n        if (Math.clz32) {\r\n          BN.prototype._countBits = function _countBits(w) {\r\n            return 32 - Math.clz32(w);\r\n          };\r\n        } else {\r\n          BN.prototype._countBits = function _countBits(w) {\r\n            var t = w;\r\n            var r = 0;\r\n            if (t >= 0x1000) {\r\n              r += 13;\r\n              t >>>= 13;\r\n            }\r\n            if (t >= 0x40) {\r\n              r += 7;\r\n              t >>>= 7;\r\n            }\r\n            if (t >= 0x8) {\r\n              r += 4;\r\n              t >>>= 4;\r\n            }\r\n            if (t >= 0x02) {\r\n              r += 2;\r\n              t >>>= 2;\r\n            }\r\n            return r + t;\r\n          };\r\n        }\r\n\r\n        BN.prototype._zeroBits = function _zeroBits(w) {\r\n          // Short-cut\r\n          if (w === 0) return 26;\r\n\r\n          var t = w;\r\n          var r = 0;\r\n          if ((t & 0x1fff) === 0) {\r\n            r += 13;\r\n            t >>>= 13;\r\n          }\r\n          if ((t & 0x7f) === 0) {\r\n            r += 7;\r\n            t >>>= 7;\r\n          }\r\n          if ((t & 0xf) === 0) {\r\n            r += 4;\r\n            t >>>= 4;\r\n          }\r\n          if ((t & 0x3) === 0) {\r\n            r += 2;\r\n            t >>>= 2;\r\n          }\r\n          if ((t & 0x1) === 0) {\r\n            r++;\r\n          }\r\n          return r;\r\n        };\r\n\r\n        // Return number of used bits in a BN\r\n        BN.prototype.bitLength = function bitLength() {\r\n          var w = this.words[this.length - 1];\r\n          var hi = this._countBits(w);\r\n          return (this.length - 1) * 26 + hi;\r\n        };\r\n\r\n        function toBitArray(num) {\r\n          var w = new Array(num.bitLength());\r\n\r\n          for (var bit = 0; bit < w.length; bit++) {\r\n            var off = (bit / 26) | 0;\r\n            var wbit = bit % 26;\r\n\r\n            w[bit] = (num.words[off] & (1 << wbit)) >>> wbit;\r\n          }\r\n\r\n          return w;\r\n        }\r\n\r\n        // Number of trailing zero bits\r\n        BN.prototype.zeroBits = function zeroBits() {\r\n          if (this.isZero()) return 0;\r\n\r\n          var r = 0;\r\n          for (var i = 0; i < this.length; i++) {\r\n            var b = this._zeroBits(this.words[i]);\r\n            r += b;\r\n            if (b !== 26) break;\r\n          }\r\n          return r;\r\n        };\r\n\r\n        BN.prototype.byteLength = function byteLength() {\r\n          return Math.ceil(this.bitLength() / 8);\r\n        };\r\n\r\n        BN.prototype.toTwos = function toTwos(width) {\r\n          if (this.negative !== 0) {\r\n            return this.abs().inotn(width).iaddn(1);\r\n          }\r\n          return this.clone();\r\n        };\r\n\r\n        BN.prototype.fromTwos = function fromTwos(width) {\r\n          if (this.testn(width - 1)) {\r\n            return this.notn(width).iaddn(1).ineg();\r\n          }\r\n          return this.clone();\r\n        };\r\n\r\n        BN.prototype.isNeg = function isNeg() {\r\n          return this.negative !== 0;\r\n        };\r\n\r\n        // Return negative clone of `this`\r\n        BN.prototype.neg = function neg() {\r\n          return this.clone().ineg();\r\n        };\r\n\r\n        BN.prototype.ineg = function ineg() {\r\n          if (!this.isZero()) {\r\n            this.negative ^= 1;\r\n          }\r\n\r\n          return this;\r\n        };\r\n\r\n        // Or `num` with `this` in-place\r\n        BN.prototype.iuor = function iuor(num) {\r\n          while (this.length < num.length) {\r\n            this.words[this.length++] = 0;\r\n          }\r\n\r\n          for (var i = 0; i < num.length; i++) {\r\n            this.words[i] = this.words[i] | num.words[i];\r\n          }\r\n\r\n          return this.strip();\r\n        };\r\n\r\n        BN.prototype.ior = function ior(num) {\r\n          assert((this.negative | num.negative) === 0);\r\n          return this.iuor(num);\r\n        };\r\n\r\n        // Or `num` with `this`\r\n        BN.prototype.or = function or(num) {\r\n          if (this.length > num.length) return this.clone().ior(num);\r\n          return num.clone().ior(this);\r\n        };\r\n\r\n        BN.prototype.uor = function uor(num) {\r\n          if (this.length > num.length) return this.clone().iuor(num);\r\n          return num.clone().iuor(this);\r\n        };\r\n\r\n        // And `num` with `this` in-place\r\n        BN.prototype.iuand = function iuand(num) {\r\n          // b = min-length(num, this)\r\n          var b;\r\n          if (this.length > num.length) {\r\n            b = num;\r\n          } else {\r\n            b = this;\r\n          }\r\n\r\n          for (var i = 0; i < b.length; i++) {\r\n            this.words[i] = this.words[i] & num.words[i];\r\n          }\r\n\r\n          this.length = b.length;\r\n\r\n          return this.strip();\r\n        };\r\n\r\n        BN.prototype.iand = function iand(num) {\r\n          assert((this.negative | num.negative) === 0);\r\n          return this.iuand(num);\r\n        };\r\n\r\n        // And `num` with `this`\r\n        BN.prototype.and = function and(num) {\r\n          if (this.length > num.length) return this.clone().iand(num);\r\n          return num.clone().iand(this);\r\n        };\r\n\r\n        BN.prototype.uand = function uand(num) {\r\n          if (this.length > num.length) return this.clone().iuand(num);\r\n          return num.clone().iuand(this);\r\n        };\r\n\r\n        // Xor `num` with `this` in-place\r\n        BN.prototype.iuxor = function iuxor(num) {\r\n          // a.length > b.length\r\n          var a;\r\n          var b;\r\n          if (this.length > num.length) {\r\n            a = this;\r\n            b = num;\r\n          } else {\r\n            a = num;\r\n            b = this;\r\n          }\r\n\r\n          for (var i = 0; i < b.length; i++) {\r\n            this.words[i] = a.words[i] ^ b.words[i];\r\n          }\r\n\r\n          if (this !== a) {\r\n            for (; i < a.length; i++) {\r\n              this.words[i] = a.words[i];\r\n            }\r\n          }\r\n\r\n          this.length = a.length;\r\n\r\n          return this.strip();\r\n        };\r\n\r\n        BN.prototype.ixor = function ixor(num) {\r\n          assert((this.negative | num.negative) === 0);\r\n          return this.iuxor(num);\r\n        };\r\n\r\n        // Xor `num` with `this`\r\n        BN.prototype.xor = function xor(num) {\r\n          if (this.length > num.length) return this.clone().ixor(num);\r\n          return num.clone().ixor(this);\r\n        };\r\n\r\n        BN.prototype.uxor = function uxor(num) {\r\n          if (this.length > num.length) return this.clone().iuxor(num);\r\n          return num.clone().iuxor(this);\r\n        };\r\n\r\n        // Not ``this`` with ``width`` bitwidth\r\n        BN.prototype.inotn = function inotn(width) {\r\n          assert(typeof width === 'number' && width >= 0);\r\n\r\n          var bytesNeeded = Math.ceil(width / 26) | 0;\r\n          var bitsLeft = width % 26;\r\n\r\n          // Extend the buffer with leading zeroes\r\n          this._expand(bytesNeeded);\r\n\r\n          if (bitsLeft > 0) {\r\n            bytesNeeded--;\r\n          }\r\n\r\n          // Handle complete words\r\n          for (var i = 0; i < bytesNeeded; i++) {\r\n            this.words[i] = ~this.words[i] & 0x3ffffff;\r\n          }\r\n\r\n          // Handle the residue\r\n          if (bitsLeft > 0) {\r\n            this.words[i] = ~this.words[i] & (0x3ffffff >> (26 - bitsLeft));\r\n          }\r\n\r\n          // And remove leading zeroes\r\n          return this.strip();\r\n        };\r\n\r\n        BN.prototype.notn = function notn(width) {\r\n          return this.clone().inotn(width);\r\n        };\r\n\r\n        // Set `bit` of `this`\r\n        BN.prototype.setn = function setn(bit, val) {\r\n          assert(typeof bit === 'number' && bit >= 0);\r\n\r\n          var off = (bit / 26) | 0;\r\n          var wbit = bit % 26;\r\n\r\n          this._expand(off + 1);\r\n\r\n          if (val) {\r\n            this.words[off] = this.words[off] | (1 << wbit);\r\n          } else {\r\n            this.words[off] = this.words[off] & ~(1 << wbit);\r\n          }\r\n\r\n          return this.strip();\r\n        };\r\n\r\n        // Add `num` to `this` in-place\r\n        BN.prototype.iadd = function iadd(num) {\r\n          var r;\r\n\r\n          // negative + positive\r\n          if (this.negative !== 0 && num.negative === 0) {\r\n            this.negative = 0;\r\n            r = this.isub(num);\r\n            this.negative ^= 1;\r\n            return this._normSign();\r\n\r\n            // positive + negative\r\n          } else if (this.negative === 0 && num.negative !== 0) {\r\n            num.negative = 0;\r\n            r = this.isub(num);\r\n            num.negative = 1;\r\n            return r._normSign();\r\n          }\r\n\r\n          // a.length > b.length\r\n          var a, b;\r\n          if (this.length > num.length) {\r\n            a = this;\r\n            b = num;\r\n          } else {\r\n            a = num;\r\n            b = this;\r\n          }\r\n\r\n          var carry = 0;\r\n          for (var i = 0; i < b.length; i++) {\r\n            r = (a.words[i] | 0) + (b.words[i] | 0) + carry;\r\n            this.words[i] = r & 0x3ffffff;\r\n            carry = r >>> 26;\r\n          }\r\n          for (; carry !== 0 && i < a.length; i++) {\r\n            r = (a.words[i] | 0) + carry;\r\n            this.words[i] = r & 0x3ffffff;\r\n            carry = r >>> 26;\r\n          }\r\n\r\n          this.length = a.length;\r\n          if (carry !== 0) {\r\n            this.words[this.length] = carry;\r\n            this.length++;\r\n            // Copy the rest of the words\r\n          } else if (a !== this) {\r\n            for (; i < a.length; i++) {\r\n              this.words[i] = a.words[i];\r\n            }\r\n          }\r\n\r\n          return this;\r\n        };\r\n\r\n        // Add `num` to `this`\r\n        BN.prototype.add = function add(num) {\r\n          var res;\r\n          if (num.negative !== 0 && this.negative === 0) {\r\n            num.negative = 0;\r\n            res = this.sub(num);\r\n            num.negative ^= 1;\r\n            return res;\r\n          } else if (num.negative === 0 && this.negative !== 0) {\r\n            this.negative = 0;\r\n            res = num.sub(this);\r\n            this.negative = 1;\r\n            return res;\r\n          }\r\n\r\n          if (this.length > num.length) return this.clone().iadd(num);\r\n\r\n          return num.clone().iadd(this);\r\n        };\r\n\r\n        // Subtract `num` from `this` in-place\r\n        BN.prototype.isub = function isub(num) {\r\n          // this - (-num) = this + num\r\n          if (num.negative !== 0) {\r\n            num.negative = 0;\r\n            var r = this.iadd(num);\r\n            num.negative = 1;\r\n            return r._normSign();\r\n\r\n            // -this - num = -(this + num)\r\n          } else if (this.negative !== 0) {\r\n            this.negative = 0;\r\n            this.iadd(num);\r\n            this.negative = 1;\r\n            return this._normSign();\r\n          }\r\n\r\n          // At this point both numbers are positive\r\n          var cmp = this.cmp(num);\r\n\r\n          // Optimization - zeroify\r\n          if (cmp === 0) {\r\n            this.negative = 0;\r\n            this.length = 1;\r\n            this.words[0] = 0;\r\n            return this;\r\n          }\r\n\r\n          // a > b\r\n          var a, b;\r\n          if (cmp > 0) {\r\n            a = this;\r\n            b = num;\r\n          } else {\r\n            a = num;\r\n            b = this;\r\n          }\r\n\r\n          var carry = 0;\r\n          for (var i = 0; i < b.length; i++) {\r\n            r = (a.words[i] | 0) - (b.words[i] | 0) + carry;\r\n            carry = r >> 26;\r\n            this.words[i] = r & 0x3ffffff;\r\n          }\r\n          for (; carry !== 0 && i < a.length; i++) {\r\n            r = (a.words[i] | 0) + carry;\r\n            carry = r >> 26;\r\n            this.words[i] = r & 0x3ffffff;\r\n          }\r\n\r\n          // Copy rest of the words\r\n          if (carry === 0 && i < a.length && a !== this) {\r\n            for (; i < a.length; i++) {\r\n              this.words[i] = a.words[i];\r\n            }\r\n          }\r\n\r\n          this.length = Math.max(this.length, i);\r\n\r\n          if (a !== this) {\r\n            this.negative = 1;\r\n          }\r\n\r\n          return this.strip();\r\n        };\r\n\r\n        // Subtract `num` from `this`\r\n        BN.prototype.sub = function sub(num) {\r\n          return this.clone().isub(num);\r\n        };\r\n\r\n        function smallMulTo(self, num, out) {\r\n          out.negative = num.negative ^ self.negative;\r\n          var len = (self.length + num.length) | 0;\r\n          out.length = len;\r\n          len = (len - 1) | 0;\r\n\r\n          // Peel one iteration (compiler can't do it, because of code complexity)\r\n          var a = self.words[0] | 0;\r\n          var b = num.words[0] | 0;\r\n          var r = a * b;\r\n\r\n          var lo = r & 0x3ffffff;\r\n          var carry = (r / 0x4000000) | 0;\r\n          out.words[0] = lo;\r\n\r\n          for (var k = 1; k < len; k++) {\r\n            // Sum all words with the same `i + j = k` and accumulate `ncarry`,\r\n            // note that ncarry could be >= 0x3ffffff\r\n            var ncarry = carry >>> 26;\r\n            var rword = carry & 0x3ffffff;\r\n            var maxJ = Math.min(k, num.length - 1);\r\n            for (var j = Math.max(0, k - self.length + 1); j <= maxJ; j++) {\r\n              var i = (k - j) | 0;\r\n              a = self.words[i] | 0;\r\n              b = num.words[j] | 0;\r\n              r = a * b + rword;\r\n              ncarry += (r / 0x4000000) | 0;\r\n              rword = r & 0x3ffffff;\r\n            }\r\n            out.words[k] = rword | 0;\r\n            carry = ncarry | 0;\r\n          }\r\n          if (carry !== 0) {\r\n            out.words[k] = carry | 0;\r\n          } else {\r\n            out.length--;\r\n          }\r\n\r\n          return out.strip();\r\n        }\r\n\r\n        // TODO(indutny): it may be reasonable to omit it for users who don't need\r\n        // to work with 256-bit numbers, otherwise it gives 20% improvement for 256-bit\r\n        // multiplication (like elliptic secp256k1).\r\n        var comb10MulTo = function comb10MulTo(self, num, out) {\r\n          var a = self.words;\r\n          var b = num.words;\r\n          var o = out.words;\r\n          var c = 0;\r\n          var lo;\r\n          var mid;\r\n          var hi;\r\n          var a0 = a[0] | 0;\r\n          var al0 = a0 & 0x1fff;\r\n          var ah0 = a0 >>> 13;\r\n          var a1 = a[1] | 0;\r\n          var al1 = a1 & 0x1fff;\r\n          var ah1 = a1 >>> 13;\r\n          var a2 = a[2] | 0;\r\n          var al2 = a2 & 0x1fff;\r\n          var ah2 = a2 >>> 13;\r\n          var a3 = a[3] | 0;\r\n          var al3 = a3 & 0x1fff;\r\n          var ah3 = a3 >>> 13;\r\n          var a4 = a[4] | 0;\r\n          var al4 = a4 & 0x1fff;\r\n          var ah4 = a4 >>> 13;\r\n          var a5 = a[5] | 0;\r\n          var al5 = a5 & 0x1fff;\r\n          var ah5 = a5 >>> 13;\r\n          var a6 = a[6] | 0;\r\n          var al6 = a6 & 0x1fff;\r\n          var ah6 = a6 >>> 13;\r\n          var a7 = a[7] | 0;\r\n          var al7 = a7 & 0x1fff;\r\n          var ah7 = a7 >>> 13;\r\n          var a8 = a[8] | 0;\r\n          var al8 = a8 & 0x1fff;\r\n          var ah8 = a8 >>> 13;\r\n          var a9 = a[9] | 0;\r\n          var al9 = a9 & 0x1fff;\r\n          var ah9 = a9 >>> 13;\r\n          var b0 = b[0] | 0;\r\n          var bl0 = b0 & 0x1fff;\r\n          var bh0 = b0 >>> 13;\r\n          var b1 = b[1] | 0;\r\n          var bl1 = b1 & 0x1fff;\r\n          var bh1 = b1 >>> 13;\r\n          var b2 = b[2] | 0;\r\n          var bl2 = b2 & 0x1fff;\r\n          var bh2 = b2 >>> 13;\r\n          var b3 = b[3] | 0;\r\n          var bl3 = b3 & 0x1fff;\r\n          var bh3 = b3 >>> 13;\r\n          var b4 = b[4] | 0;\r\n          var bl4 = b4 & 0x1fff;\r\n          var bh4 = b4 >>> 13;\r\n          var b5 = b[5] | 0;\r\n          var bl5 = b5 & 0x1fff;\r\n          var bh5 = b5 >>> 13;\r\n          var b6 = b[6] | 0;\r\n          var bl6 = b6 & 0x1fff;\r\n          var bh6 = b6 >>> 13;\r\n          var b7 = b[7] | 0;\r\n          var bl7 = b7 & 0x1fff;\r\n          var bh7 = b7 >>> 13;\r\n          var b8 = b[8] | 0;\r\n          var bl8 = b8 & 0x1fff;\r\n          var bh8 = b8 >>> 13;\r\n          var b9 = b[9] | 0;\r\n          var bl9 = b9 & 0x1fff;\r\n          var bh9 = b9 >>> 13;\r\n\r\n          out.negative = self.negative ^ num.negative;\r\n          out.length = 19;\r\n          /* k = 0 */\r\n          lo = Math.imul(al0, bl0);\r\n          mid = Math.imul(al0, bh0);\r\n          mid = (mid + Math.imul(ah0, bl0)) | 0;\r\n          hi = Math.imul(ah0, bh0);\r\n          var w0 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;\r\n          c = (((hi + (mid >>> 13)) | 0) + (w0 >>> 26)) | 0;\r\n          w0 &= 0x3ffffff;\r\n          /* k = 1 */\r\n          lo = Math.imul(al1, bl0);\r\n          mid = Math.imul(al1, bh0);\r\n          mid = (mid + Math.imul(ah1, bl0)) | 0;\r\n          hi = Math.imul(ah1, bh0);\r\n          lo = (lo + Math.imul(al0, bl1)) | 0;\r\n          mid = (mid + Math.imul(al0, bh1)) | 0;\r\n          mid = (mid + Math.imul(ah0, bl1)) | 0;\r\n          hi = (hi + Math.imul(ah0, bh1)) | 0;\r\n          var w1 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;\r\n          c = (((hi + (mid >>> 13)) | 0) + (w1 >>> 26)) | 0;\r\n          w1 &= 0x3ffffff;\r\n          /* k = 2 */\r\n          lo = Math.imul(al2, bl0);\r\n          mid = Math.imul(al2, bh0);\r\n          mid = (mid + Math.imul(ah2, bl0)) | 0;\r\n          hi = Math.imul(ah2, bh0);\r\n          lo = (lo + Math.imul(al1, bl1)) | 0;\r\n          mid = (mid + Math.imul(al1, bh1)) | 0;\r\n          mid = (mid + Math.imul(ah1, bl1)) | 0;\r\n          hi = (hi + Math.imul(ah1, bh1)) | 0;\r\n          lo = (lo + Math.imul(al0, bl2)) | 0;\r\n          mid = (mid + Math.imul(al0, bh2)) | 0;\r\n          mid = (mid + Math.imul(ah0, bl2)) | 0;\r\n          hi = (hi + Math.imul(ah0, bh2)) | 0;\r\n          var w2 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;\r\n          c = (((hi + (mid >>> 13)) | 0) + (w2 >>> 26)) | 0;\r\n          w2 &= 0x3ffffff;\r\n          /* k = 3 */\r\n          lo = Math.imul(al3, bl0);\r\n          mid = Math.imul(al3, bh0);\r\n          mid = (mid + Math.imul(ah3, bl0)) | 0;\r\n          hi = Math.imul(ah3, bh0);\r\n          lo = (lo + Math.imul(al2, bl1)) | 0;\r\n          mid = (mid + Math.imul(al2, bh1)) | 0;\r\n          mid = (mid + Math.imul(ah2, bl1)) | 0;\r\n          hi = (hi + Math.imul(ah2, bh1)) | 0;\r\n          lo = (lo + Math.imul(al1, bl2)) | 0;\r\n          mid = (mid + Math.imul(al1, bh2)) | 0;\r\n          mid = (mid + Math.imul(ah1, bl2)) | 0;\r\n          hi = (hi + Math.imul(ah1, bh2)) | 0;\r\n          lo = (lo + Math.imul(al0, bl3)) | 0;\r\n          mid = (mid + Math.imul(al0, bh3)) | 0;\r\n          mid = (mid + Math.imul(ah0, bl3)) | 0;\r\n          hi = (hi + Math.imul(ah0, bh3)) | 0;\r\n          var w3 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;\r\n          c = (((hi + (mid >>> 13)) | 0) + (w3 >>> 26)) | 0;\r\n          w3 &= 0x3ffffff;\r\n          /* k = 4 */\r\n          lo = Math.imul(al4, bl0);\r\n          mid = Math.imul(al4, bh0);\r\n          mid = (mid + Math.imul(ah4, bl0)) | 0;\r\n          hi = Math.imul(ah4, bh0);\r\n          lo = (lo + Math.imul(al3, bl1)) | 0;\r\n          mid = (mid + Math.imul(al3, bh1)) | 0;\r\n          mid = (mid + Math.imul(ah3, bl1)) | 0;\r\n          hi = (hi + Math.imul(ah3, bh1)) | 0;\r\n          lo = (lo + Math.imul(al2, bl2)) | 0;\r\n          mid = (mid + Math.imul(al2, bh2)) | 0;\r\n          mid = (mid + Math.imul(ah2, bl2)) | 0;\r\n          hi = (hi + Math.imul(ah2, bh2)) | 0;\r\n          lo = (lo + Math.imul(al1, bl3)) | 0;\r\n          mid = (mid + Math.imul(al1, bh3)) | 0;\r\n          mid = (mid + Math.imul(ah1, bl3)) | 0;\r\n          hi = (hi + Math.imul(ah1, bh3)) | 0;\r\n          lo = (lo + Math.imul(al0, bl4)) | 0;\r\n          mid = (mid + Math.imul(al0, bh4)) | 0;\r\n          mid = (mid + Math.imul(ah0, bl4)) | 0;\r\n          hi = (hi + Math.imul(ah0, bh4)) | 0;\r\n          var w4 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;\r\n          c = (((hi + (mid >>> 13)) | 0) + (w4 >>> 26)) | 0;\r\n          w4 &= 0x3ffffff;\r\n          /* k = 5 */\r\n          lo = Math.imul(al5, bl0);\r\n          mid = Math.imul(al5, bh0);\r\n          mid = (mid + Math.imul(ah5, bl0)) | 0;\r\n          hi = Math.imul(ah5, bh0);\r\n          lo = (lo + Math.imul(al4, bl1)) | 0;\r\n          mid = (mid + Math.imul(al4, bh1)) | 0;\r\n          mid = (mid + Math.imul(ah4, bl1)) | 0;\r\n          hi = (hi + Math.imul(ah4, bh1)) | 0;\r\n          lo = (lo + Math.imul(al3, bl2)) | 0;\r\n          mid = (mid + Math.imul(al3, bh2)) | 0;\r\n          mid = (mid + Math.imul(ah3, bl2)) | 0;\r\n          hi = (hi + Math.imul(ah3, bh2)) | 0;\r\n          lo = (lo + Math.imul(al2, bl3)) | 0;\r\n          mid = (mid + Math.imul(al2, bh3)) | 0;\r\n          mid = (mid + Math.imul(ah2, bl3)) | 0;\r\n          hi = (hi + Math.imul(ah2, bh3)) | 0;\r\n          lo = (lo + Math.imul(al1, bl4)) | 0;\r\n          mid = (mid + Math.imul(al1, bh4)) | 0;\r\n          mid = (mid + Math.imul(ah1, bl4)) | 0;\r\n          hi = (hi + Math.imul(ah1, bh4)) | 0;\r\n          lo = (lo + Math.imul(al0, bl5)) | 0;\r\n          mid = (mid + Math.imul(al0, bh5)) | 0;\r\n          mid = (mid + Math.imul(ah0, bl5)) | 0;\r\n          hi = (hi + Math.imul(ah0, bh5)) | 0;\r\n          var w5 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;\r\n          c = (((hi + (mid >>> 13)) | 0) + (w5 >>> 26)) | 0;\r\n          w5 &= 0x3ffffff;\r\n          /* k = 6 */\r\n          lo = Math.imul(al6, bl0);\r\n          mid = Math.imul(al6, bh0);\r\n          mid = (mid + Math.imul(ah6, bl0)) | 0;\r\n          hi = Math.imul(ah6, bh0);\r\n          lo = (lo + Math.imul(al5, bl1)) | 0;\r\n          mid = (mid + Math.imul(al5, bh1)) | 0;\r\n          mid = (mid + Math.imul(ah5, bl1)) | 0;\r\n          hi = (hi + Math.imul(ah5, bh1)) | 0;\r\n          lo = (lo + Math.imul(al4, bl2)) | 0;\r\n          mid = (mid + Math.imul(al4, bh2)) | 0;\r\n          mid = (mid + Math.imul(ah4, bl2)) | 0;\r\n          hi = (hi + Math.imul(ah4, bh2)) | 0;\r\n          lo = (lo + Math.imul(al3, bl3)) | 0;\r\n          mid = (mid + Math.imul(al3, bh3)) | 0;\r\n          mid = (mid + Math.imul(ah3, bl3)) | 0;\r\n          hi = (hi + Math.imul(ah3, bh3)) | 0;\r\n          lo = (lo + Math.imul(al2, bl4)) | 0;\r\n          mid = (mid + Math.imul(al2, bh4)) | 0;\r\n          mid = (mid + Math.imul(ah2, bl4)) | 0;\r\n          hi = (hi + Math.imul(ah2, bh4)) | 0;\r\n          lo = (lo + Math.imul(al1, bl5)) | 0;\r\n          mid = (mid + Math.imul(al1, bh5)) | 0;\r\n          mid = (mid + Math.imul(ah1, bl5)) | 0;\r\n          hi = (hi + Math.imul(ah1, bh5)) | 0;\r\n          lo = (lo + Math.imul(al0, bl6)) | 0;\r\n          mid = (mid + Math.imul(al0, bh6)) | 0;\r\n          mid = (mid + Math.imul(ah0, bl6)) | 0;\r\n          hi = (hi + Math.imul(ah0, bh6)) | 0;\r\n          var w6 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;\r\n          c = (((hi + (mid >>> 13)) | 0) + (w6 >>> 26)) | 0;\r\n          w6 &= 0x3ffffff;\r\n          /* k = 7 */\r\n          lo = Math.imul(al7, bl0);\r\n          mid = Math.imul(al7, bh0);\r\n          mid = (mid + Math.imul(ah7, bl0)) | 0;\r\n          hi = Math.imul(ah7, bh0);\r\n          lo = (lo + Math.imul(al6, bl1)) | 0;\r\n          mid = (mid + Math.imul(al6, bh1)) | 0;\r\n          mid = (mid + Math.imul(ah6, bl1)) | 0;\r\n          hi = (hi + Math.imul(ah6, bh1)) | 0;\r\n          lo = (lo + Math.imul(al5, bl2)) | 0;\r\n          mid = (mid + Math.imul(al5, bh2)) | 0;\r\n          mid = (mid + Math.imul(ah5, bl2)) | 0;\r\n          hi = (hi + Math.imul(ah5, bh2)) | 0;\r\n          lo = (lo + Math.imul(al4, bl3)) | 0;\r\n          mid = (mid + Math.imul(al4, bh3)) | 0;\r\n          mid = (mid + Math.imul(ah4, bl3)) | 0;\r\n          hi = (hi + Math.imul(ah4, bh3)) | 0;\r\n          lo = (lo + Math.imul(al3, bl4)) | 0;\r\n          mid = (mid + Math.imul(al3, bh4)) | 0;\r\n          mid = (mid + Math.imul(ah3, bl4)) | 0;\r\n          hi = (hi + Math.imul(ah3, bh4)) | 0;\r\n          lo = (lo + Math.imul(al2, bl5)) | 0;\r\n          mid = (mid + Math.imul(al2, bh5)) | 0;\r\n          mid = (mid + Math.imul(ah2, bl5)) | 0;\r\n          hi = (hi + Math.imul(ah2, bh5)) | 0;\r\n          lo = (lo + Math.imul(al1, bl6)) | 0;\r\n          mid = (mid + Math.imul(al1, bh6)) | 0;\r\n          mid = (mid + Math.imul(ah1, bl6)) | 0;\r\n          hi = (hi + Math.imul(ah1, bh6)) | 0;\r\n          lo = (lo + Math.imul(al0, bl7)) | 0;\r\n          mid = (mid + Math.imul(al0, bh7)) | 0;\r\n          mid = (mid + Math.imul(ah0, bl7)) | 0;\r\n          hi = (hi + Math.imul(ah0, bh7)) | 0;\r\n          var w7 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;\r\n          c = (((hi + (mid >>> 13)) | 0) + (w7 >>> 26)) | 0;\r\n          w7 &= 0x3ffffff;\r\n          /* k = 8 */\r\n          lo = Math.imul(al8, bl0);\r\n          mid = Math.imul(al8, bh0);\r\n          mid = (mid + Math.imul(ah8, bl0)) | 0;\r\n          hi = Math.imul(ah8, bh0);\r\n          lo = (lo + Math.imul(al7, bl1)) | 0;\r\n          mid = (mid + Math.imul(al7, bh1)) | 0;\r\n          mid = (mid + Math.imul(ah7, bl1)) | 0;\r\n          hi = (hi + Math.imul(ah7, bh1)) | 0;\r\n          lo = (lo + Math.imul(al6, bl2)) | 0;\r\n          mid = (mid + Math.imul(al6, bh2)) | 0;\r\n          mid = (mid + Math.imul(ah6, bl2)) | 0;\r\n          hi = (hi + Math.imul(ah6, bh2)) | 0;\r\n          lo = (lo + Math.imul(al5, bl3)) | 0;\r\n          mid = (mid + Math.imul(al5, bh3)) | 0;\r\n          mid = (mid + Math.imul(ah5, bl3)) | 0;\r\n          hi = (hi + Math.imul(ah5, bh3)) | 0;\r\n          lo = (lo + Math.imul(al4, bl4)) | 0;\r\n          mid = (mid + Math.imul(al4, bh4)) | 0;\r\n          mid = (mid + Math.imul(ah4, bl4)) | 0;\r\n          hi = (hi + Math.imul(ah4, bh4)) | 0;\r\n          lo = (lo + Math.imul(al3, bl5)) | 0;\r\n          mid = (mid + Math.imul(al3, bh5)) | 0;\r\n          mid = (mid + Math.imul(ah3, bl5)) | 0;\r\n          hi = (hi + Math.imul(ah3, bh5)) | 0;\r\n          lo = (lo + Math.imul(al2, bl6)) | 0;\r\n          mid = (mid + Math.imul(al2, bh6)) | 0;\r\n          mid = (mid + Math.imul(ah2, bl6)) | 0;\r\n          hi = (hi + Math.imul(ah2, bh6)) | 0;\r\n          lo = (lo + Math.imul(al1, bl7)) | 0;\r\n          mid = (mid + Math.imul(al1, bh7)) | 0;\r\n          mid = (mid + Math.imul(ah1, bl7)) | 0;\r\n          hi = (hi + Math.imul(ah1, bh7)) | 0;\r\n          lo = (lo + Math.imul(al0, bl8)) | 0;\r\n          mid = (mid + Math.imul(al0, bh8)) | 0;\r\n          mid = (mid + Math.imul(ah0, bl8)) | 0;\r\n          hi = (hi + Math.imul(ah0, bh8)) | 0;\r\n          var w8 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;\r\n          c = (((hi + (mid >>> 13)) | 0) + (w8 >>> 26)) | 0;\r\n          w8 &= 0x3ffffff;\r\n          /* k = 9 */\r\n          lo = Math.imul(al9, bl0);\r\n          mid = Math.imul(al9, bh0);\r\n          mid = (mid + Math.imul(ah9, bl0)) | 0;\r\n          hi = Math.imul(ah9, bh0);\r\n          lo = (lo + Math.imul(al8, bl1)) | 0;\r\n          mid = (mid + Math.imul(al8, bh1)) | 0;\r\n          mid = (mid + Math.imul(ah8, bl1)) | 0;\r\n          hi = (hi + Math.imul(ah8, bh1)) | 0;\r\n          lo = (lo + Math.imul(al7, bl2)) | 0;\r\n          mid = (mid + Math.imul(al7, bh2)) | 0;\r\n          mid = (mid + Math.imul(ah7, bl2)) | 0;\r\n          hi = (hi + Math.imul(ah7, bh2)) | 0;\r\n          lo = (lo + Math.imul(al6, bl3)) | 0;\r\n          mid = (mid + Math.imul(al6, bh3)) | 0;\r\n          mid = (mid + Math.imul(ah6, bl3)) | 0;\r\n          hi = (hi + Math.imul(ah6, bh3)) | 0;\r\n          lo = (lo + Math.imul(al5, bl4)) | 0;\r\n          mid = (mid + Math.imul(al5, bh4)) | 0;\r\n          mid = (mid + Math.imul(ah5, bl4)) | 0;\r\n          hi = (hi + Math.imul(ah5, bh4)) | 0;\r\n          lo = (lo + Math.imul(al4, bl5)) | 0;\r\n          mid = (mid + Math.imul(al4, bh5)) | 0;\r\n          mid = (mid + Math.imul(ah4, bl5)) | 0;\r\n          hi = (hi + Math.imul(ah4, bh5)) | 0;\r\n          lo = (lo + Math.imul(al3, bl6)) | 0;\r\n          mid = (mid + Math.imul(al3, bh6)) | 0;\r\n          mid = (mid + Math.imul(ah3, bl6)) | 0;\r\n          hi = (hi + Math.imul(ah3, bh6)) | 0;\r\n          lo = (lo + Math.imul(al2, bl7)) | 0;\r\n          mid = (mid + Math.imul(al2, bh7)) | 0;\r\n          mid = (mid + Math.imul(ah2, bl7)) | 0;\r\n          hi = (hi + Math.imul(ah2, bh7)) | 0;\r\n          lo = (lo + Math.imul(al1, bl8)) | 0;\r\n          mid = (mid + Math.imul(al1, bh8)) | 0;\r\n          mid = (mid + Math.imul(ah1, bl8)) | 0;\r\n          hi = (hi + Math.imul(ah1, bh8)) | 0;\r\n          lo = (lo + Math.imul(al0, bl9)) | 0;\r\n          mid = (mid + Math.imul(al0, bh9)) | 0;\r\n          mid = (mid + Math.imul(ah0, bl9)) | 0;\r\n          hi = (hi + Math.imul(ah0, bh9)) | 0;\r\n          var w9 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;\r\n          c = (((hi + (mid >>> 13)) | 0) + (w9 >>> 26)) | 0;\r\n          w9 &= 0x3ffffff;\r\n          /* k = 10 */\r\n          lo = Math.imul(al9, bl1);\r\n          mid = Math.imul(al9, bh1);\r\n          mid = (mid + Math.imul(ah9, bl1)) | 0;\r\n          hi = Math.imul(ah9, bh1);\r\n          lo = (lo + Math.imul(al8, bl2)) | 0;\r\n          mid = (mid + Math.imul(al8, bh2)) | 0;\r\n          mid = (mid + Math.imul(ah8, bl2)) | 0;\r\n          hi = (hi + Math.imul(ah8, bh2)) | 0;\r\n          lo = (lo + Math.imul(al7, bl3)) | 0;\r\n          mid = (mid + Math.imul(al7, bh3)) | 0;\r\n          mid = (mid + Math.imul(ah7, bl3)) | 0;\r\n          hi = (hi + Math.imul(ah7, bh3)) | 0;\r\n          lo = (lo + Math.imul(al6, bl4)) | 0;\r\n          mid = (mid + Math.imul(al6, bh4)) | 0;\r\n          mid = (mid + Math.imul(ah6, bl4)) | 0;\r\n          hi = (hi + Math.imul(ah6, bh4)) | 0;\r\n          lo = (lo + Math.imul(al5, bl5)) | 0;\r\n          mid = (mid + Math.imul(al5, bh5)) | 0;\r\n          mid = (mid + Math.imul(ah5, bl5)) | 0;\r\n          hi = (hi + Math.imul(ah5, bh5)) | 0;\r\n          lo = (lo + Math.imul(al4, bl6)) | 0;\r\n          mid = (mid + Math.imul(al4, bh6)) | 0;\r\n          mid = (mid + Math.imul(ah4, bl6)) | 0;\r\n          hi = (hi + Math.imul(ah4, bh6)) | 0;\r\n          lo = (lo + Math.imul(al3, bl7)) | 0;\r\n          mid = (mid + Math.imul(al3, bh7)) | 0;\r\n          mid = (mid + Math.imul(ah3, bl7)) | 0;\r\n          hi = (hi + Math.imul(ah3, bh7)) | 0;\r\n          lo = (lo + Math.imul(al2, bl8)) | 0;\r\n          mid = (mid + Math.imul(al2, bh8)) | 0;\r\n          mid = (mid + Math.imul(ah2, bl8)) | 0;\r\n          hi = (hi + Math.imul(ah2, bh8)) | 0;\r\n          lo = (lo + Math.imul(al1, bl9)) | 0;\r\n          mid = (mid + Math.imul(al1, bh9)) | 0;\r\n          mid = (mid + Math.imul(ah1, bl9)) | 0;\r\n          hi = (hi + Math.imul(ah1, bh9)) | 0;\r\n          var w10 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;\r\n          c = (((hi + (mid >>> 13)) | 0) + (w10 >>> 26)) | 0;\r\n          w10 &= 0x3ffffff;\r\n          /* k = 11 */\r\n          lo = Math.imul(al9, bl2);\r\n          mid = Math.imul(al9, bh2);\r\n          mid = (mid + Math.imul(ah9, bl2)) | 0;\r\n          hi = Math.imul(ah9, bh2);\r\n          lo = (lo + Math.imul(al8, bl3)) | 0;\r\n          mid = (mid + Math.imul(al8, bh3)) | 0;\r\n          mid = (mid + Math.imul(ah8, bl3)) | 0;\r\n          hi = (hi + Math.imul(ah8, bh3)) | 0;\r\n          lo = (lo + Math.imul(al7, bl4)) | 0;\r\n          mid = (mid + Math.imul(al7, bh4)) | 0;\r\n          mid = (mid + Math.imul(ah7, bl4)) | 0;\r\n          hi = (hi + Math.imul(ah7, bh4)) | 0;\r\n          lo = (lo + Math.imul(al6, bl5)) | 0;\r\n          mid = (mid + Math.imul(al6, bh5)) | 0;\r\n          mid = (mid + Math.imul(ah6, bl5)) | 0;\r\n          hi = (hi + Math.imul(ah6, bh5)) | 0;\r\n          lo = (lo + Math.imul(al5, bl6)) | 0;\r\n          mid = (mid + Math.imul(al5, bh6)) | 0;\r\n          mid = (mid + Math.imul(ah5, bl6)) | 0;\r\n          hi = (hi + Math.imul(ah5, bh6)) | 0;\r\n          lo = (lo + Math.imul(al4, bl7)) | 0;\r\n          mid = (mid + Math.imul(al4, bh7)) | 0;\r\n          mid = (mid + Math.imul(ah4, bl7)) | 0;\r\n          hi = (hi + Math.imul(ah4, bh7)) | 0;\r\n          lo = (lo + Math.imul(al3, bl8)) | 0;\r\n          mid = (mid + Math.imul(al3, bh8)) | 0;\r\n          mid = (mid + Math.imul(ah3, bl8)) | 0;\r\n          hi = (hi + Math.imul(ah3, bh8)) | 0;\r\n          lo = (lo + Math.imul(al2, bl9)) | 0;\r\n          mid = (mid + Math.imul(al2, bh9)) | 0;\r\n          mid = (mid + Math.imul(ah2, bl9)) | 0;\r\n          hi = (hi + Math.imul(ah2, bh9)) | 0;\r\n          var w11 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;\r\n          c = (((hi + (mid >>> 13)) | 0) + (w11 >>> 26)) | 0;\r\n          w11 &= 0x3ffffff;\r\n          /* k = 12 */\r\n          lo = Math.imul(al9, bl3);\r\n          mid = Math.imul(al9, bh3);\r\n          mid = (mid + Math.imul(ah9, bl3)) | 0;\r\n          hi = Math.imul(ah9, bh3);\r\n          lo = (lo + Math.imul(al8, bl4)) | 0;\r\n          mid = (mid + Math.imul(al8, bh4)) | 0;\r\n          mid = (mid + Math.imul(ah8, bl4)) | 0;\r\n          hi = (hi + Math.imul(ah8, bh4)) | 0;\r\n          lo = (lo + Math.imul(al7, bl5)) | 0;\r\n          mid = (mid + Math.imul(al7, bh5)) | 0;\r\n          mid = (mid + Math.imul(ah7, bl5)) | 0;\r\n          hi = (hi + Math.imul(ah7, bh5)) | 0;\r\n          lo = (lo + Math.imul(al6, bl6)) | 0;\r\n          mid = (mid + Math.imul(al6, bh6)) | 0;\r\n          mid = (mid + Math.imul(ah6, bl6)) | 0;\r\n          hi = (hi + Math.imul(ah6, bh6)) | 0;\r\n          lo = (lo + Math.imul(al5, bl7)) | 0;\r\n          mid = (mid + Math.imul(al5, bh7)) | 0;\r\n          mid = (mid + Math.imul(ah5, bl7)) | 0;\r\n          hi = (hi + Math.imul(ah5, bh7)) | 0;\r\n          lo = (lo + Math.imul(al4, bl8)) | 0;\r\n          mid = (mid + Math.imul(al4, bh8)) | 0;\r\n          mid = (mid + Math.imul(ah4, bl8)) | 0;\r\n          hi = (hi + Math.imul(ah4, bh8)) | 0;\r\n          lo = (lo + Math.imul(al3, bl9)) | 0;\r\n          mid = (mid + Math.imul(al3, bh9)) | 0;\r\n          mid = (mid + Math.imul(ah3, bl9)) | 0;\r\n          hi = (hi + Math.imul(ah3, bh9)) | 0;\r\n          var w12 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;\r\n          c = (((hi + (mid >>> 13)) | 0) + (w12 >>> 26)) | 0;\r\n          w12 &= 0x3ffffff;\r\n          /* k = 13 */\r\n          lo = Math.imul(al9, bl4);\r\n          mid = Math.imul(al9, bh4);\r\n          mid = (mid + Math.imul(ah9, bl4)) | 0;\r\n          hi = Math.imul(ah9, bh4);\r\n          lo = (lo + Math.imul(al8, bl5)) | 0;\r\n          mid = (mid + Math.imul(al8, bh5)) | 0;\r\n          mid = (mid + Math.imul(ah8, bl5)) | 0;\r\n          hi = (hi + Math.imul(ah8, bh5)) | 0;\r\n          lo = (lo + Math.imul(al7, bl6)) | 0;\r\n          mid = (mid + Math.imul(al7, bh6)) | 0;\r\n          mid = (mid + Math.imul(ah7, bl6)) | 0;\r\n          hi = (hi + Math.imul(ah7, bh6)) | 0;\r\n          lo = (lo + Math.imul(al6, bl7)) | 0;\r\n          mid = (mid + Math.imul(al6, bh7)) | 0;\r\n          mid = (mid + Math.imul(ah6, bl7)) | 0;\r\n          hi = (hi + Math.imul(ah6, bh7)) | 0;\r\n          lo = (lo + Math.imul(al5, bl8)) | 0;\r\n          mid = (mid + Math.imul(al5, bh8)) | 0;\r\n          mid = (mid + Math.imul(ah5, bl8)) | 0;\r\n          hi = (hi + Math.imul(ah5, bh8)) | 0;\r\n          lo = (lo + Math.imul(al4, bl9)) | 0;\r\n          mid = (mid + Math.imul(al4, bh9)) | 0;\r\n          mid = (mid + Math.imul(ah4, bl9)) | 0;\r\n          hi = (hi + Math.imul(ah4, bh9)) | 0;\r\n          var w13 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;\r\n          c = (((hi + (mid >>> 13)) | 0) + (w13 >>> 26)) | 0;\r\n          w13 &= 0x3ffffff;\r\n          /* k = 14 */\r\n          lo = Math.imul(al9, bl5);\r\n          mid = Math.imul(al9, bh5);\r\n          mid = (mid + Math.imul(ah9, bl5)) | 0;\r\n          hi = Math.imul(ah9, bh5);\r\n          lo = (lo + Math.imul(al8, bl6)) | 0;\r\n          mid = (mid + Math.imul(al8, bh6)) | 0;\r\n          mid = (mid + Math.imul(ah8, bl6)) | 0;\r\n          hi = (hi + Math.imul(ah8, bh6)) | 0;\r\n          lo = (lo + Math.imul(al7, bl7)) | 0;\r\n          mid = (mid + Math.imul(al7, bh7)) | 0;\r\n          mid = (mid + Math.imul(ah7, bl7)) | 0;\r\n          hi = (hi + Math.imul(ah7, bh7)) | 0;\r\n          lo = (lo + Math.imul(al6, bl8)) | 0;\r\n          mid = (mid + Math.imul(al6, bh8)) | 0;\r\n          mid = (mid + Math.imul(ah6, bl8)) | 0;\r\n          hi = (hi + Math.imul(ah6, bh8)) | 0;\r\n          lo = (lo + Math.imul(al5, bl9)) | 0;\r\n          mid = (mid + Math.imul(al5, bh9)) | 0;\r\n          mid = (mid + Math.imul(ah5, bl9)) | 0;\r\n          hi = (hi + Math.imul(ah5, bh9)) | 0;\r\n          var w14 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;\r\n          c = (((hi + (mid >>> 13)) | 0) + (w14 >>> 26)) | 0;\r\n          w14 &= 0x3ffffff;\r\n          /* k = 15 */\r\n          lo = Math.imul(al9, bl6);\r\n          mid = Math.imul(al9, bh6);\r\n          mid = (mid + Math.imul(ah9, bl6)) | 0;\r\n          hi = Math.imul(ah9, bh6);\r\n          lo = (lo + Math.imul(al8, bl7)) | 0;\r\n          mid = (mid + Math.imul(al8, bh7)) | 0;\r\n          mid = (mid + Math.imul(ah8, bl7)) | 0;\r\n          hi = (hi + Math.imul(ah8, bh7)) | 0;\r\n          lo = (lo + Math.imul(al7, bl8)) | 0;\r\n          mid = (mid + Math.imul(al7, bh8)) | 0;\r\n          mid = (mid + Math.imul(ah7, bl8)) | 0;\r\n          hi = (hi + Math.imul(ah7, bh8)) | 0;\r\n          lo = (lo + Math.imul(al6, bl9)) | 0;\r\n          mid = (mid + Math.imul(al6, bh9)) | 0;\r\n          mid = (mid + Math.imul(ah6, bl9)) | 0;\r\n          hi = (hi + Math.imul(ah6, bh9)) | 0;\r\n          var w15 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;\r\n          c = (((hi + (mid >>> 13)) | 0) + (w15 >>> 26)) | 0;\r\n          w15 &= 0x3ffffff;\r\n          /* k = 16 */\r\n          lo = Math.imul(al9, bl7);\r\n          mid = Math.imul(al9, bh7);\r\n          mid = (mid + Math.imul(ah9, bl7)) | 0;\r\n          hi = Math.imul(ah9, bh7);\r\n          lo = (lo + Math.imul(al8, bl8)) | 0;\r\n          mid = (mid + Math.imul(al8, bh8)) | 0;\r\n          mid = (mid + Math.imul(ah8, bl8)) | 0;\r\n          hi = (hi + Math.imul(ah8, bh8)) | 0;\r\n          lo = (lo + Math.imul(al7, bl9)) | 0;\r\n          mid = (mid + Math.imul(al7, bh9)) | 0;\r\n          mid = (mid + Math.imul(ah7, bl9)) | 0;\r\n          hi = (hi + Math.imul(ah7, bh9)) | 0;\r\n          var w16 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;\r\n          c = (((hi + (mid >>> 13)) | 0) + (w16 >>> 26)) | 0;\r\n          w16 &= 0x3ffffff;\r\n          /* k = 17 */\r\n          lo = Math.imul(al9, bl8);\r\n          mid = Math.imul(al9, bh8);\r\n          mid = (mid + Math.imul(ah9, bl8)) | 0;\r\n          hi = Math.imul(ah9, bh8);\r\n          lo = (lo + Math.imul(al8, bl9)) | 0;\r\n          mid = (mid + Math.imul(al8, bh9)) | 0;\r\n          mid = (mid + Math.imul(ah8, bl9)) | 0;\r\n          hi = (hi + Math.imul(ah8, bh9)) | 0;\r\n          var w17 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;\r\n          c = (((hi + (mid >>> 13)) | 0) + (w17 >>> 26)) | 0;\r\n          w17 &= 0x3ffffff;\r\n          /* k = 18 */\r\n          lo = Math.imul(al9, bl9);\r\n          mid = Math.imul(al9, bh9);\r\n          mid = (mid + Math.imul(ah9, bl9)) | 0;\r\n          hi = Math.imul(ah9, bh9);\r\n          var w18 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;\r\n          c = (((hi + (mid >>> 13)) | 0) + (w18 >>> 26)) | 0;\r\n          w18 &= 0x3ffffff;\r\n          o[0] = w0;\r\n          o[1] = w1;\r\n          o[2] = w2;\r\n          o[3] = w3;\r\n          o[4] = w4;\r\n          o[5] = w5;\r\n          o[6] = w6;\r\n          o[7] = w7;\r\n          o[8] = w8;\r\n          o[9] = w9;\r\n          o[10] = w10;\r\n          o[11] = w11;\r\n          o[12] = w12;\r\n          o[13] = w13;\r\n          o[14] = w14;\r\n          o[15] = w15;\r\n          o[16] = w16;\r\n          o[17] = w17;\r\n          o[18] = w18;\r\n          if (c !== 0) {\r\n            o[19] = c;\r\n            out.length++;\r\n          }\r\n          return out;\r\n        };\r\n\r\n        // Polyfill comb\r\n        if (!Math.imul) {\r\n          comb10MulTo = smallMulTo;\r\n        }\r\n\r\n        function bigMulTo(self, num, out) {\r\n          out.negative = num.negative ^ self.negative;\r\n          out.length = self.length + num.length;\r\n\r\n          var carry = 0;\r\n          var hncarry = 0;\r\n          for (var k = 0; k < out.length - 1; k++) {\r\n            // Sum all words with the same `i + j = k` and accumulate `ncarry`,\r\n            // note that ncarry could be >= 0x3ffffff\r\n            var ncarry = hncarry;\r\n            hncarry = 0;\r\n            var rword = carry & 0x3ffffff;\r\n            var maxJ = Math.min(k, num.length - 1);\r\n            for (var j = Math.max(0, k - self.length + 1); j <= maxJ; j++) {\r\n              var i = k - j;\r\n              var a = self.words[i] | 0;\r\n              var b = num.words[j] | 0;\r\n              var r = a * b;\r\n\r\n              var lo = r & 0x3ffffff;\r\n              ncarry = (ncarry + ((r / 0x4000000) | 0)) | 0;\r\n              lo = (lo + rword) | 0;\r\n              rword = lo & 0x3ffffff;\r\n              ncarry = (ncarry + (lo >>> 26)) | 0;\r\n\r\n              hncarry += ncarry >>> 26;\r\n              ncarry &= 0x3ffffff;\r\n            }\r\n            out.words[k] = rword;\r\n            carry = ncarry;\r\n            ncarry = hncarry;\r\n          }\r\n          if (carry !== 0) {\r\n            out.words[k] = carry;\r\n          } else {\r\n            out.length--;\r\n          }\r\n\r\n          return out.strip();\r\n        }\r\n\r\n        function jumboMulTo(self, num, out) {\r\n          var fftm = new FFTM();\r\n          return fftm.mulp(self, num, out);\r\n        }\r\n\r\n        BN.prototype.mulTo = function mulTo(num, out) {\r\n          var res;\r\n          var len = this.length + num.length;\r\n          if (this.length === 10 && num.length === 10) {\r\n            res = comb10MulTo(this, num, out);\r\n          } else if (len < 63) {\r\n            res = smallMulTo(this, num, out);\r\n          } else if (len < 1024) {\r\n            res = bigMulTo(this, num, out);\r\n          } else {\r\n            res = jumboMulTo(this, num, out);\r\n          }\r\n\r\n          return res;\r\n        };\r\n\r\n        // Cooley-Tukey algorithm for FFT\r\n        // slightly revisited to rely on looping instead of recursion\r\n\r\n        function FFTM(x, y) {\r\n          this.x = x;\r\n          this.y = y;\r\n        }\r\n\r\n        FFTM.prototype.makeRBT = function makeRBT(N) {\r\n          var t = new Array(N);\r\n          var l = BN.prototype._countBits(N) - 1;\r\n          for (var i = 0; i < N; i++) {\r\n            t[i] = this.revBin(i, l, N);\r\n          }\r\n\r\n          return t;\r\n        };\r\n\r\n        // Returns binary-reversed representation of `x`\r\n        FFTM.prototype.revBin = function revBin(x, l, N) {\r\n          if (x === 0 || x === N - 1) return x;\r\n\r\n          var rb = 0;\r\n          for (var i = 0; i < l; i++) {\r\n            rb |= (x & 1) << (l - i - 1);\r\n            x >>= 1;\r\n          }\r\n\r\n          return rb;\r\n        };\r\n\r\n        // Performs \"tweedling\" phase, therefore 'emulating'\r\n        // behaviour of the recursive algorithm\r\n        FFTM.prototype.permute = function permute(rbt, rws, iws, rtws, itws, N) {\r\n          for (var i = 0; i < N; i++) {\r\n            rtws[i] = rws[rbt[i]];\r\n            itws[i] = iws[rbt[i]];\r\n          }\r\n        };\r\n\r\n        FFTM.prototype.transform = function transform(rws, iws, rtws, itws, N, rbt) {\r\n          this.permute(rbt, rws, iws, rtws, itws, N);\r\n\r\n          for (var s = 1; s < N; s <<= 1) {\r\n            var l = s << 1;\r\n\r\n            var rtwdf = Math.cos(2 * Math.PI / l);\r\n            var itwdf = Math.sin(2 * Math.PI / l);\r\n\r\n            for (var p = 0; p < N; p += l) {\r\n              var rtwdf_ = rtwdf;\r\n              var itwdf_ = itwdf;\r\n\r\n              for (var j = 0; j < s; j++) {\r\n                var re = rtws[p + j];\r\n                var ie = itws[p + j];\r\n\r\n                var ro = rtws[p + j + s];\r\n                var io = itws[p + j + s];\r\n\r\n                var rx = rtwdf_ * ro - itwdf_ * io;\r\n\r\n                io = rtwdf_ * io + itwdf_ * ro;\r\n                ro = rx;\r\n\r\n                rtws[p + j] = re + ro;\r\n                itws[p + j] = ie + io;\r\n\r\n                rtws[p + j + s] = re - ro;\r\n                itws[p + j + s] = ie - io;\r\n\r\n                /* jshint maxdepth : false */\r\n                if (j !== l) {\r\n                  rx = rtwdf * rtwdf_ - itwdf * itwdf_;\r\n\r\n                  itwdf_ = rtwdf * itwdf_ + itwdf * rtwdf_;\r\n                  rtwdf_ = rx;\r\n                }\r\n              }\r\n            }\r\n          }\r\n        };\r\n\r\n        FFTM.prototype.guessLen13b = function guessLen13b(n, m) {\r\n          var N = Math.max(m, n) | 1;\r\n          var odd = N & 1;\r\n          var i = 0;\r\n          for (N = N / 2 | 0; N; N = N >>> 1) {\r\n            i++;\r\n          }\r\n\r\n          return 1 << i + 1 + odd;\r\n        };\r\n\r\n        FFTM.prototype.conjugate = function conjugate(rws, iws, N) {\r\n          if (N <= 1) return;\r\n\r\n          for (var i = 0; i < N / 2; i++) {\r\n            var t = rws[i];\r\n\r\n            rws[i] = rws[N - i - 1];\r\n            rws[N - i - 1] = t;\r\n\r\n            t = iws[i];\r\n\r\n            iws[i] = -iws[N - i - 1];\r\n            iws[N - i - 1] = -t;\r\n          }\r\n        };\r\n\r\n        FFTM.prototype.normalize13b = function normalize13b(ws, N) {\r\n          var carry = 0;\r\n          for (var i = 0; i < N / 2; i++) {\r\n            var w = Math.round(ws[2 * i + 1] / N) * 0x2000 +\r\n              Math.round(ws[2 * i] / N) +\r\n              carry;\r\n\r\n            ws[i] = w & 0x3ffffff;\r\n\r\n            if (w < 0x4000000) {\r\n              carry = 0;\r\n            } else {\r\n              carry = w / 0x4000000 | 0;\r\n            }\r\n          }\r\n\r\n          return ws;\r\n        };\r\n\r\n        FFTM.prototype.convert13b = function convert13b(ws, len, rws, N) {\r\n          var carry = 0;\r\n          for (var i = 0; i < len; i++) {\r\n            carry = carry + (ws[i] | 0);\r\n\r\n            rws[2 * i] = carry & 0x1fff;\r\n            carry = carry >>> 13;\r\n            rws[2 * i + 1] = carry & 0x1fff;\r\n            carry = carry >>> 13;\r\n          }\r\n\r\n          // Pad with zeroes\r\n          for (i = 2 * len; i < N; ++i) {\r\n            rws[i] = 0;\r\n          }\r\n\r\n          assert(carry === 0);\r\n          assert((carry & ~0x1fff) === 0);\r\n        };\r\n\r\n        FFTM.prototype.stub = function stub(N) {\r\n          var ph = new Array(N);\r\n          for (var i = 0; i < N; i++) {\r\n            ph[i] = 0;\r\n          }\r\n\r\n          return ph;\r\n        };\r\n\r\n        FFTM.prototype.mulp = function mulp(x, y, out) {\r\n          var N = 2 * this.guessLen13b(x.length, y.length);\r\n\r\n          var rbt = this.makeRBT(N);\r\n\r\n          var _ = this.stub(N);\r\n\r\n          var rws = new Array(N);\r\n          var rwst = new Array(N);\r\n          var iwst = new Array(N);\r\n\r\n          var nrws = new Array(N);\r\n          var nrwst = new Array(N);\r\n          var niwst = new Array(N);\r\n\r\n          var rmws = out.words;\r\n          rmws.length = N;\r\n\r\n          this.convert13b(x.words, x.length, rws, N);\r\n          this.convert13b(y.words, y.length, nrws, N);\r\n\r\n          this.transform(rws, _, rwst, iwst, N, rbt);\r\n          this.transform(nrws, _, nrwst, niwst, N, rbt);\r\n\r\n          for (var i = 0; i < N; i++) {\r\n            var rx = rwst[i] * nrwst[i] - iwst[i] * niwst[i];\r\n            iwst[i] = rwst[i] * niwst[i] + iwst[i] * nrwst[i];\r\n            rwst[i] = rx;\r\n          }\r\n\r\n          this.conjugate(rwst, iwst, N);\r\n          this.transform(rwst, iwst, rmws, _, N, rbt);\r\n          this.conjugate(rmws, _, N);\r\n          this.normalize13b(rmws, N);\r\n\r\n          out.negative = x.negative ^ y.negative;\r\n          out.length = x.length + y.length;\r\n          return out.strip();\r\n        };\r\n\r\n        // Multiply `this` by `num`\r\n        BN.prototype.mul = function mul(num) {\r\n          var out = new BN(null);\r\n          out.words = new Array(this.length + num.length);\r\n          return this.mulTo(num, out);\r\n        };\r\n\r\n        // Multiply employing FFT\r\n        BN.prototype.mulf = function mulf(num) {\r\n          var out = new BN(null);\r\n          out.words = new Array(this.length + num.length);\r\n          return jumboMulTo(this, num, out);\r\n        };\r\n\r\n        // In-place Multiplication\r\n        BN.prototype.imul = function imul(num) {\r\n          return this.clone().mulTo(num, this);\r\n        };\r\n\r\n        BN.prototype.imuln = function imuln(num) {\r\n          assert(typeof num === 'number');\r\n          assert(num < 0x4000000);\r\n\r\n          // Carry\r\n          var carry = 0;\r\n          for (var i = 0; i < this.length; i++) {\r\n            var w = (this.words[i] | 0) * num;\r\n            var lo = (w & 0x3ffffff) + (carry & 0x3ffffff);\r\n            carry >>= 26;\r\n            carry += (w / 0x4000000) | 0;\r\n            // NOTE: lo is 27bit maximum\r\n            carry += lo >>> 26;\r\n            this.words[i] = lo & 0x3ffffff;\r\n          }\r\n\r\n          if (carry !== 0) {\r\n            this.words[i] = carry;\r\n            this.length++;\r\n          }\r\n\r\n          return this;\r\n        };\r\n\r\n        BN.prototype.muln = function muln(num) {\r\n          return this.clone().imuln(num);\r\n        };\r\n\r\n        // `this` * `this`\r\n        BN.prototype.sqr = function sqr() {\r\n          return this.mul(this);\r\n        };\r\n\r\n        // `this` * `this` in-place\r\n        BN.prototype.isqr = function isqr() {\r\n          return this.imul(this.clone());\r\n        };\r\n\r\n        // Math.pow(`this`, `num`)\r\n        BN.prototype.pow = function pow(num) {\r\n          var w = toBitArray(num);\r\n          if (w.length === 0) return new BN(1);\r\n\r\n          // Skip leading zeroes\r\n          var res = this;\r\n          for (var i = 0; i < w.length; i++, res = res.sqr()) {\r\n            if (w[i] !== 0) break;\r\n          }\r\n\r\n          if (++i < w.length) {\r\n            for (var q = res.sqr(); i < w.length; i++, q = q.sqr()) {\r\n              if (w[i] === 0) continue;\r\n\r\n              res = res.mul(q);\r\n            }\r\n          }\r\n\r\n          return res;\r\n        };\r\n\r\n        // Shift-left in-place\r\n        BN.prototype.iushln = function iushln(bits) {\r\n          assert(typeof bits === 'number' && bits >= 0);\r\n          var r = bits % 26;\r\n          var s = (bits - r) / 26;\r\n          var carryMask = (0x3ffffff >>> (26 - r)) << (26 - r);\r\n          var i;\r\n\r\n          if (r !== 0) {\r\n            var carry = 0;\r\n\r\n            for (i = 0; i < this.length; i++) {\r\n              var newCarry = this.words[i] & carryMask;\r\n              var c = ((this.words[i] | 0) - newCarry) << r;\r\n              this.words[i] = c | carry;\r\n              carry = newCarry >>> (26 - r);\r\n            }\r\n\r\n            if (carry) {\r\n              this.words[i] = carry;\r\n              this.length++;\r\n            }\r\n          }\r\n\r\n          if (s !== 0) {\r\n            for (i = this.length - 1; i >= 0; i--) {\r\n              this.words[i + s] = this.words[i];\r\n            }\r\n\r\n            for (i = 0; i < s; i++) {\r\n              this.words[i] = 0;\r\n            }\r\n\r\n            this.length += s;\r\n          }\r\n\r\n          return this.strip();\r\n        };\r\n\r\n        BN.prototype.ishln = function ishln(bits) {\r\n          // TODO(indutny): implement me\r\n          assert(this.negative === 0);\r\n          return this.iushln(bits);\r\n        };\r\n\r\n        // Shift-right in-place\r\n        // NOTE: `hint` is a lowest bit before trailing zeroes\r\n        // NOTE: if `extended` is present - it will be filled with destroyed bits\r\n        BN.prototype.iushrn = function iushrn(bits, hint, extended) {\r\n          assert(typeof bits === 'number' && bits >= 0);\r\n          var h;\r\n          if (hint) {\r\n            h = (hint - (hint % 26)) / 26;\r\n          } else {\r\n            h = 0;\r\n          }\r\n\r\n          var r = bits % 26;\r\n          var s = Math.min((bits - r) / 26, this.length);\r\n          var mask = 0x3ffffff ^ ((0x3ffffff >>> r) << r);\r\n          var maskedWords = extended;\r\n\r\n          h -= s;\r\n          h = Math.max(0, h);\r\n\r\n          // Extended mode, copy masked part\r\n          if (maskedWords) {\r\n            for (var i = 0; i < s; i++) {\r\n              maskedWords.words[i] = this.words[i];\r\n            }\r\n            maskedWords.length = s;\r\n          }\r\n\r\n          if (s === 0) {\r\n            // No-op, we should not move anything at all\r\n          } else if (this.length > s) {\r\n            this.length -= s;\r\n            for (i = 0; i < this.length; i++) {\r\n              this.words[i] = this.words[i + s];\r\n            }\r\n          } else {\r\n            this.words[0] = 0;\r\n            this.length = 1;\r\n          }\r\n\r\n          var carry = 0;\r\n          for (i = this.length - 1; i >= 0 && (carry !== 0 || i >= h); i--) {\r\n            var word = this.words[i] | 0;\r\n            this.words[i] = (carry << (26 - r)) | (word >>> r);\r\n            carry = word & mask;\r\n          }\r\n\r\n          // Push carried bits as a mask\r\n          if (maskedWords && carry !== 0) {\r\n            maskedWords.words[maskedWords.length++] = carry;\r\n          }\r\n\r\n          if (this.length === 0) {\r\n            this.words[0] = 0;\r\n            this.length = 1;\r\n          }\r\n\r\n          return this.strip();\r\n        };\r\n\r\n        BN.prototype.ishrn = function ishrn(bits, hint, extended) {\r\n          // TODO(indutny): implement me\r\n          assert(this.negative === 0);\r\n          return this.iushrn(bits, hint, extended);\r\n        };\r\n\r\n        // Shift-left\r\n        BN.prototype.shln = function shln(bits) {\r\n          return this.clone().ishln(bits);\r\n        };\r\n\r\n        BN.prototype.ushln = function ushln(bits) {\r\n          return this.clone().iushln(bits);\r\n        };\r\n\r\n        // Shift-right\r\n        BN.prototype.shrn = function shrn(bits) {\r\n          return this.clone().ishrn(bits);\r\n        };\r\n\r\n        BN.prototype.ushrn = function ushrn(bits) {\r\n          return this.clone().iushrn(bits);\r\n        };\r\n\r\n        // Test if n bit is set\r\n        BN.prototype.testn = function testn(bit) {\r\n          assert(typeof bit === 'number' && bit >= 0);\r\n          var r = bit % 26;\r\n          var s = (bit - r) / 26;\r\n          var q = 1 << r;\r\n\r\n          // Fast case: bit is much higher than all existing words\r\n          if (this.length <= s) return false;\r\n\r\n          // Check bit and return\r\n          var w = this.words[s];\r\n\r\n          return !!(w & q);\r\n        };\r\n\r\n        // Return only lowers bits of number (in-place)\r\n        BN.prototype.imaskn = function imaskn(bits) {\r\n          assert(typeof bits === 'number' && bits >= 0);\r\n          var r = bits % 26;\r\n          var s = (bits - r) / 26;\r\n\r\n          assert(this.negative === 0, 'imaskn works only with positive numbers');\r\n\r\n          if (this.length <= s) {\r\n            return this;\r\n          }\r\n\r\n          if (r !== 0) {\r\n            s++;\r\n          }\r\n          this.length = Math.min(s, this.length);\r\n\r\n          if (r !== 0) {\r\n            var mask = 0x3ffffff ^ ((0x3ffffff >>> r) << r);\r\n            this.words[this.length - 1] &= mask;\r\n          }\r\n\r\n          return this.strip();\r\n        };\r\n\r\n        // Return only lowers bits of number\r\n        BN.prototype.maskn = function maskn(bits) {\r\n          return this.clone().imaskn(bits);\r\n        };\r\n\r\n        // Add plain number `num` to `this`\r\n        BN.prototype.iaddn = function iaddn(num) {\r\n          assert(typeof num === 'number');\r\n          assert(num < 0x4000000);\r\n          if (num < 0) return this.isubn(-num);\r\n\r\n          // Possible sign change\r\n          if (this.negative !== 0) {\r\n            if (this.length === 1 && (this.words[0] | 0) < num) {\r\n              this.words[0] = num - (this.words[0] | 0);\r\n              this.negative = 0;\r\n              return this;\r\n            }\r\n\r\n            this.negative = 0;\r\n            this.isubn(num);\r\n            this.negative = 1;\r\n            return this;\r\n          }\r\n\r\n          // Add without checks\r\n          return this._iaddn(num);\r\n        };\r\n\r\n        BN.prototype._iaddn = function _iaddn(num) {\r\n          this.words[0] += num;\r\n\r\n          // Carry\r\n          for (var i = 0; i < this.length && this.words[i] >= 0x4000000; i++) {\r\n            this.words[i] -= 0x4000000;\r\n            if (i === this.length - 1) {\r\n              this.words[i + 1] = 1;\r\n            } else {\r\n              this.words[i + 1]++;\r\n            }\r\n          }\r\n          this.length = Math.max(this.length, i + 1);\r\n\r\n          return this;\r\n        };\r\n\r\n        // Subtract plain number `num` from `this`\r\n        BN.prototype.isubn = function isubn(num) {\r\n          assert(typeof num === 'number');\r\n          assert(num < 0x4000000);\r\n          if (num < 0) return this.iaddn(-num);\r\n\r\n          if (this.negative !== 0) {\r\n            this.negative = 0;\r\n            this.iaddn(num);\r\n            this.negative = 1;\r\n            return this;\r\n          }\r\n\r\n          this.words[0] -= num;\r\n\r\n          if (this.length === 1 && this.words[0] < 0) {\r\n            this.words[0] = -this.words[0];\r\n            this.negative = 1;\r\n          } else {\r\n            // Carry\r\n            for (var i = 0; i < this.length && this.words[i] < 0; i++) {\r\n              this.words[i] += 0x4000000;\r\n              this.words[i + 1] -= 1;\r\n            }\r\n          }\r\n\r\n          return this.strip();\r\n        };\r\n\r\n        BN.prototype.addn = function addn(num) {\r\n          return this.clone().iaddn(num);\r\n        };\r\n\r\n        BN.prototype.subn = function subn(num) {\r\n          return this.clone().isubn(num);\r\n        };\r\n\r\n        BN.prototype.iabs = function iabs() {\r\n          this.negative = 0;\r\n\r\n          return this;\r\n        };\r\n\r\n        BN.prototype.abs = function abs() {\r\n          return this.clone().iabs();\r\n        };\r\n\r\n        BN.prototype._ishlnsubmul = function _ishlnsubmul(num, mul, shift) {\r\n          var len = num.length + shift;\r\n          var i;\r\n\r\n          this._expand(len);\r\n\r\n          var w;\r\n          var carry = 0;\r\n          for (i = 0; i < num.length; i++) {\r\n            w = (this.words[i + shift] | 0) + carry;\r\n            var right = (num.words[i] | 0) * mul;\r\n            w -= right & 0x3ffffff;\r\n            carry = (w >> 26) - ((right / 0x4000000) | 0);\r\n            this.words[i + shift] = w & 0x3ffffff;\r\n          }\r\n          for (; i < this.length - shift; i++) {\r\n            w = (this.words[i + shift] | 0) + carry;\r\n            carry = w >> 26;\r\n            this.words[i + shift] = w & 0x3ffffff;\r\n          }\r\n\r\n          if (carry === 0) return this.strip();\r\n\r\n          // Subtraction overflow\r\n          assert(carry === -1);\r\n          carry = 0;\r\n          for (i = 0; i < this.length; i++) {\r\n            w = -(this.words[i] | 0) + carry;\r\n            carry = w >> 26;\r\n            this.words[i] = w & 0x3ffffff;\r\n          }\r\n          this.negative = 1;\r\n\r\n          return this.strip();\r\n        };\r\n\r\n        BN.prototype._wordDiv = function _wordDiv(num, mode) {\r\n          var shift = this.length - num.length;\r\n\r\n          var a = this.clone();\r\n          var b = num;\r\n\r\n          // Normalize\r\n          var bhi = b.words[b.length - 1] | 0;\r\n          var bhiBits = this._countBits(bhi);\r\n          shift = 26 - bhiBits;\r\n          if (shift !== 0) {\r\n            b = b.ushln(shift);\r\n            a.iushln(shift);\r\n            bhi = b.words[b.length - 1] | 0;\r\n          }\r\n\r\n          // Initialize quotient\r\n          var m = a.length - b.length;\r\n          var q;\r\n\r\n          if (mode !== 'mod') {\r\n            q = new BN(null);\r\n            q.length = m + 1;\r\n            q.words = new Array(q.length);\r\n            for (var i = 0; i < q.length; i++) {\r\n              q.words[i] = 0;\r\n            }\r\n          }\r\n\r\n          var diff = a.clone()._ishlnsubmul(b, 1, m);\r\n          if (diff.negative === 0) {\r\n            a = diff;\r\n            if (q) {\r\n              q.words[m] = 1;\r\n            }\r\n          }\r\n\r\n          for (var j = m - 1; j >= 0; j--) {\r\n            var qj = (a.words[b.length + j] | 0) * 0x4000000 +\r\n              (a.words[b.length + j - 1] | 0);\r\n\r\n            // NOTE: (qj / bhi) is (0x3ffffff * 0x4000000 + 0x3ffffff) / 0x2000000 max\r\n            // (0x7ffffff)\r\n            qj = Math.min((qj / bhi) | 0, 0x3ffffff);\r\n\r\n            a._ishlnsubmul(b, qj, j);\r\n            while (a.negative !== 0) {\r\n              qj--;\r\n              a.negative = 0;\r\n              a._ishlnsubmul(b, 1, j);\r\n              if (!a.isZero()) {\r\n                a.negative ^= 1;\r\n              }\r\n            }\r\n            if (q) {\r\n              q.words[j] = qj;\r\n            }\r\n          }\r\n          if (q) {\r\n            q.strip();\r\n          }\r\n          a.strip();\r\n\r\n          // Denormalize\r\n          if (mode !== 'div' && shift !== 0) {\r\n            a.iushrn(shift);\r\n          }\r\n\r\n          return {\r\n            div: q || null,\r\n            mod: a\r\n          };\r\n        };\r\n\r\n        // NOTE: 1) `mode` can be set to `mod` to request mod only,\r\n        //       to `div` to request div only, or be absent to\r\n        //       request both div & mod\r\n        //       2) `positive` is true if unsigned mod is requested\r\n        BN.prototype.divmod = function divmod(num, mode, positive) {\r\n          assert(!num.isZero());\r\n\r\n          if (this.isZero()) {\r\n            return {\r\n              div: new BN(0),\r\n              mod: new BN(0)\r\n            };\r\n          }\r\n\r\n          var div, mod, res;\r\n          if (this.negative !== 0 && num.negative === 0) {\r\n            res = this.neg().divmod(num, mode);\r\n\r\n            if (mode !== 'mod') {\r\n              div = res.div.neg();\r\n            }\r\n\r\n            if (mode !== 'div') {\r\n              mod = res.mod.neg();\r\n              if (positive && mod.negative !== 0) {\r\n                mod.iadd(num);\r\n              }\r\n            }\r\n\r\n            return {\r\n              div: div,\r\n              mod: mod\r\n            };\r\n          }\r\n\r\n          if (this.negative === 0 && num.negative !== 0) {\r\n            res = this.divmod(num.neg(), mode);\r\n\r\n            if (mode !== 'mod') {\r\n              div = res.div.neg();\r\n            }\r\n\r\n            return {\r\n              div: div,\r\n              mod: res.mod\r\n            };\r\n          }\r\n\r\n          if ((this.negative & num.negative) !== 0) {\r\n            res = this.neg().divmod(num.neg(), mode);\r\n\r\n            if (mode !== 'div') {\r\n              mod = res.mod.neg();\r\n              if (positive && mod.negative !== 0) {\r\n                mod.isub(num);\r\n              }\r\n            }\r\n\r\n            return {\r\n              div: res.div,\r\n              mod: mod\r\n            };\r\n          }\r\n\r\n          // Both numbers are positive at this point\r\n\r\n          // Strip both numbers to approximate shift value\r\n          if (num.length > this.length || this.cmp(num) < 0) {\r\n            return {\r\n              div: new BN(0),\r\n              mod: this\r\n            };\r\n          }\r\n\r\n          // Very short reduction\r\n          if (num.length === 1) {\r\n            if (mode === 'div') {\r\n              return {\r\n                div: this.divn(num.words[0]),\r\n                mod: null\r\n              };\r\n            }\r\n\r\n            if (mode === 'mod') {\r\n              return {\r\n                div: null,\r\n                mod: new BN(this.modn(num.words[0]))\r\n              };\r\n            }\r\n\r\n            return {\r\n              div: this.divn(num.words[0]),\r\n              mod: new BN(this.modn(num.words[0]))\r\n            };\r\n          }\r\n\r\n          return this._wordDiv(num, mode);\r\n        };\r\n\r\n        // Find `this` / `num`\r\n        BN.prototype.div = function div(num) {\r\n          return this.divmod(num, 'div', false).div;\r\n        };\r\n\r\n        // Find `this` % `num`\r\n        BN.prototype.mod = function mod(num) {\r\n          return this.divmod(num, 'mod', false).mod;\r\n        };\r\n\r\n        BN.prototype.umod = function umod(num) {\r\n          return this.divmod(num, 'mod', true).mod;\r\n        };\r\n\r\n        // Find Round(`this` / `num`)\r\n        BN.prototype.divRound = function divRound(num) {\r\n          var dm = this.divmod(num);\r\n\r\n          // Fast case - exact division\r\n          if (dm.mod.isZero()) return dm.div;\r\n\r\n          var mod = dm.div.negative !== 0 ? dm.mod.isub(num) : dm.mod;\r\n\r\n          var half = num.ushrn(1);\r\n          var r2 = num.andln(1);\r\n          var cmp = mod.cmp(half);\r\n\r\n          // Round down\r\n          if (cmp < 0 || r2 === 1 && cmp === 0) return dm.div;\r\n\r\n          // Round up\r\n          return dm.div.negative !== 0 ? dm.div.isubn(1) : dm.div.iaddn(1);\r\n        };\r\n\r\n        BN.prototype.modn = function modn(num) {\r\n          assert(num <= 0x3ffffff);\r\n          var p = (1 << 26) % num;\r\n\r\n          var acc = 0;\r\n          for (var i = this.length - 1; i >= 0; i--) {\r\n            acc = (p * acc + (this.words[i] | 0)) % num;\r\n          }\r\n\r\n          return acc;\r\n        };\r\n\r\n        // In-place division by number\r\n        BN.prototype.idivn = function idivn(num) {\r\n          assert(num <= 0x3ffffff);\r\n\r\n          var carry = 0;\r\n          for (var i = this.length - 1; i >= 0; i--) {\r\n            var w = (this.words[i] | 0) + carry * 0x4000000;\r\n            this.words[i] = (w / num) | 0;\r\n            carry = w % num;\r\n          }\r\n\r\n          return this.strip();\r\n        };\r\n\r\n        BN.prototype.divn = function divn(num) {\r\n          return this.clone().idivn(num);\r\n        };\r\n\r\n        BN.prototype.egcd = function egcd(p) {\r\n          assert(p.negative === 0);\r\n          assert(!p.isZero());\r\n\r\n          var x = this;\r\n          var y = p.clone();\r\n\r\n          if (x.negative !== 0) {\r\n            x = x.umod(p);\r\n          } else {\r\n            x = x.clone();\r\n          }\r\n\r\n          // A * x + B * y = x\r\n          var A = new BN(1);\r\n          var B = new BN(0);\r\n\r\n          // C * x + D * y = y\r\n          var C = new BN(0);\r\n          var D = new BN(1);\r\n\r\n          var g = 0;\r\n\r\n          while (x.isEven() && y.isEven()) {\r\n            x.iushrn(1);\r\n            y.iushrn(1);\r\n            ++g;\r\n          }\r\n\r\n          var yp = y.clone();\r\n          var xp = x.clone();\r\n\r\n          while (!x.isZero()) {\r\n            for (var i = 0, im = 1;\r\n              (x.words[0] & im) === 0 && i < 26; ++i, im <<= 1);\r\n            if (i > 0) {\r\n              x.iushrn(i);\r\n              while (i-- > 0) {\r\n                if (A.isOdd() || B.isOdd()) {\r\n                  A.iadd(yp);\r\n                  B.isub(xp);\r\n                }\r\n\r\n                A.iushrn(1);\r\n                B.iushrn(1);\r\n              }\r\n            }\r\n\r\n            for (var j = 0, jm = 1;\r\n              (y.words[0] & jm) === 0 && j < 26; ++j, jm <<= 1);\r\n            if (j > 0) {\r\n              y.iushrn(j);\r\n              while (j-- > 0) {\r\n                if (C.isOdd() || D.isOdd()) {\r\n                  C.iadd(yp);\r\n                  D.isub(xp);\r\n                }\r\n\r\n                C.iushrn(1);\r\n                D.iushrn(1);\r\n              }\r\n            }\r\n\r\n            if (x.cmp(y) >= 0) {\r\n              x.isub(y);\r\n              A.isub(C);\r\n              B.isub(D);\r\n            } else {\r\n              y.isub(x);\r\n              C.isub(A);\r\n              D.isub(B);\r\n            }\r\n          }\r\n\r\n          return {\r\n            a: C,\r\n            b: D,\r\n            gcd: y.iushln(g)\r\n          };\r\n        };\r\n\r\n        // This is reduced incarnation of the binary EEA\r\n        // above, designated to invert members of the\r\n        // _prime_ fields F(p) at a maximal speed\r\n        BN.prototype._invmp = function _invmp(p) {\r\n          assert(p.negative === 0);\r\n          assert(!p.isZero());\r\n\r\n          var a = this;\r\n          var b = p.clone();\r\n\r\n          if (a.negative !== 0) {\r\n            a = a.umod(p);\r\n          } else {\r\n            a = a.clone();\r\n          }\r\n\r\n          var x1 = new BN(1);\r\n          var x2 = new BN(0);\r\n\r\n          var delta = b.clone();\r\n\r\n          while (a.cmpn(1) > 0 && b.cmpn(1) > 0) {\r\n            for (var i = 0, im = 1;\r\n              (a.words[0] & im) === 0 && i < 26; ++i, im <<= 1);\r\n            if (i > 0) {\r\n              a.iushrn(i);\r\n              while (i-- > 0) {\r\n                if (x1.isOdd()) {\r\n                  x1.iadd(delta);\r\n                }\r\n\r\n                x1.iushrn(1);\r\n              }\r\n            }\r\n\r\n            for (var j = 0, jm = 1;\r\n              (b.words[0] & jm) === 0 && j < 26; ++j, jm <<= 1);\r\n            if (j > 0) {\r\n              b.iushrn(j);\r\n              while (j-- > 0) {\r\n                if (x2.isOdd()) {\r\n                  x2.iadd(delta);\r\n                }\r\n\r\n                x2.iushrn(1);\r\n              }\r\n            }\r\n\r\n            if (a.cmp(b) >= 0) {\r\n              a.isub(b);\r\n              x1.isub(x2);\r\n            } else {\r\n              b.isub(a);\r\n              x2.isub(x1);\r\n            }\r\n          }\r\n\r\n          var res;\r\n          if (a.cmpn(1) === 0) {\r\n            res = x1;\r\n          } else {\r\n            res = x2;\r\n          }\r\n\r\n          if (res.cmpn(0) < 0) {\r\n            res.iadd(p);\r\n          }\r\n\r\n          return res;\r\n        };\r\n\r\n        BN.prototype.gcd = function gcd(num) {\r\n          if (this.isZero()) return num.abs();\r\n          if (num.isZero()) return this.abs();\r\n\r\n          var a = this.clone();\r\n          var b = num.clone();\r\n          a.negative = 0;\r\n          b.negative = 0;\r\n\r\n          // Remove common factor of two\r\n          for (var shift = 0; a.isEven() && b.isEven(); shift++) {\r\n            a.iushrn(1);\r\n            b.iushrn(1);\r\n          }\r\n\r\n          do {\r\n            while (a.isEven()) {\r\n              a.iushrn(1);\r\n            }\r\n            while (b.isEven()) {\r\n              b.iushrn(1);\r\n            }\r\n\r\n            var r = a.cmp(b);\r\n            if (r < 0) {\r\n              // Swap `a` and `b` to make `a` always bigger than `b`\r\n              var t = a;\r\n              a = b;\r\n              b = t;\r\n            } else if (r === 0 || b.cmpn(1) === 0) {\r\n              break;\r\n            }\r\n\r\n            a.isub(b);\r\n          } while (true);\r\n\r\n          return b.iushln(shift);\r\n        };\r\n\r\n        // Invert number in the field F(num)\r\n        BN.prototype.invm = function invm(num) {\r\n          return this.egcd(num).a.umod(num);\r\n        };\r\n\r\n        BN.prototype.isEven = function isEven() {\r\n          return (this.words[0] & 1) === 0;\r\n        };\r\n\r\n        BN.prototype.isOdd = function isOdd() {\r\n          return (this.words[0] & 1) === 1;\r\n        };\r\n\r\n        // And first word and num\r\n        BN.prototype.andln = function andln(num) {\r\n          return this.words[0] & num;\r\n        };\r\n\r\n        // Increment at the bit position in-line\r\n        BN.prototype.bincn = function bincn(bit) {\r\n          assert(typeof bit === 'number');\r\n          var r = bit % 26;\r\n          var s = (bit - r) / 26;\r\n          var q = 1 << r;\r\n\r\n          // Fast case: bit is much higher than all existing words\r\n          if (this.length <= s) {\r\n            this._expand(s + 1);\r\n            this.words[s] |= q;\r\n            return this;\r\n          }\r\n\r\n          // Add bit and propagate, if needed\r\n          var carry = q;\r\n          for (var i = s; carry !== 0 && i < this.length; i++) {\r\n            var w = this.words[i] | 0;\r\n            w += carry;\r\n            carry = w >>> 26;\r\n            w &= 0x3ffffff;\r\n            this.words[i] = w;\r\n          }\r\n          if (carry !== 0) {\r\n            this.words[i] = carry;\r\n            this.length++;\r\n          }\r\n          return this;\r\n        };\r\n\r\n        BN.prototype.isZero = function isZero() {\r\n          return this.length === 1 && this.words[0] === 0;\r\n        };\r\n\r\n        BN.prototype.cmpn = function cmpn(num) {\r\n          var negative = num < 0;\r\n\r\n          if (this.negative !== 0 && !negative) return -1;\r\n          if (this.negative === 0 && negative) return 1;\r\n\r\n          this.strip();\r\n\r\n          var res;\r\n          if (this.length > 1) {\r\n            res = 1;\r\n          } else {\r\n            if (negative) {\r\n              num = -num;\r\n            }\r\n\r\n            assert(num <= 0x3ffffff, 'Number is too big');\r\n\r\n            var w = this.words[0] | 0;\r\n            res = w === num ? 0 : w < num ? -1 : 1;\r\n          }\r\n          if (this.negative !== 0) return -res | 0;\r\n          return res;\r\n        };\r\n\r\n        // Compare two numbers and return:\r\n        // 1 - if `this` > `num`\r\n        // 0 - if `this` == `num`\r\n        // -1 - if `this` < `num`\r\n        BN.prototype.cmp = function cmp(num) {\r\n          if (this.negative !== 0 && num.negative === 0) return -1;\r\n          if (this.negative === 0 && num.negative !== 0) return 1;\r\n\r\n          var res = this.ucmp(num);\r\n          if (this.negative !== 0) return -res | 0;\r\n          return res;\r\n        };\r\n\r\n        // Unsigned comparison\r\n        BN.prototype.ucmp = function ucmp(num) {\r\n          // At this point both numbers have the same sign\r\n          if (this.length > num.length) return 1;\r\n          if (this.length < num.length) return -1;\r\n\r\n          var res = 0;\r\n          for (var i = this.length - 1; i >= 0; i--) {\r\n            var a = this.words[i] | 0;\r\n            var b = num.words[i] | 0;\r\n\r\n            if (a === b) continue;\r\n            if (a < b) {\r\n              res = -1;\r\n            } else if (a > b) {\r\n              res = 1;\r\n            }\r\n            break;\r\n          }\r\n          return res;\r\n        };\r\n\r\n        BN.prototype.gtn = function gtn(num) {\r\n          return this.cmpn(num) === 1;\r\n        };\r\n\r\n        BN.prototype.gt = function gt(num) {\r\n          return this.cmp(num) === 1;\r\n        };\r\n\r\n        BN.prototype.gten = function gten(num) {\r\n          return this.cmpn(num) >= 0;\r\n        };\r\n\r\n        BN.prototype.gte = function gte(num) {\r\n          return this.cmp(num) >= 0;\r\n        };\r\n\r\n        BN.prototype.ltn = function ltn(num) {\r\n          return this.cmpn(num) === -1;\r\n        };\r\n\r\n        BN.prototype.lt = function lt(num) {\r\n          return this.cmp(num) === -1;\r\n        };\r\n\r\n        BN.prototype.lten = function lten(num) {\r\n          return this.cmpn(num) <= 0;\r\n        };\r\n\r\n        BN.prototype.lte = function lte(num) {\r\n          return this.cmp(num) <= 0;\r\n        };\r\n\r\n        BN.prototype.eqn = function eqn(num) {\r\n          return this.cmpn(num) === 0;\r\n        };\r\n\r\n        BN.prototype.eq = function eq(num) {\r\n          return this.cmp(num) === 0;\r\n        };\r\n\r\n        //\r\n        // A reduce context, could be using montgomery or something better, depending\r\n        // on the `m` itself.\r\n        //\r\n        BN.red = function red(num) {\r\n          return new Red(num);\r\n        };\r\n\r\n        BN.prototype.toRed = function toRed(ctx) {\r\n          assert(!this.red, 'Already a number in reduction context');\r\n          assert(this.negative === 0, 'red works only with positives');\r\n          return ctx.convertTo(this)._forceRed(ctx);\r\n        };\r\n\r\n        BN.prototype.fromRed = function fromRed() {\r\n          assert(this.red, 'fromRed works only with numbers in reduction context');\r\n          return this.red.convertFrom(this);\r\n        };\r\n\r\n        BN.prototype._forceRed = function _forceRed(ctx) {\r\n          this.red = ctx;\r\n          return this;\r\n        };\r\n\r\n        BN.prototype.forceRed = function forceRed(ctx) {\r\n          assert(!this.red, 'Already a number in reduction context');\r\n          return this._forceRed(ctx);\r\n        };\r\n\r\n        BN.prototype.redAdd = function redAdd(num) {\r\n          assert(this.red, 'redAdd works only with red numbers');\r\n          return this.red.add(this, num);\r\n        };\r\n\r\n        BN.prototype.redIAdd = function redIAdd(num) {\r\n          assert(this.red, 'redIAdd works only with red numbers');\r\n          return this.red.iadd(this, num);\r\n        };\r\n\r\n        BN.prototype.redSub = function redSub(num) {\r\n          assert(this.red, 'redSub works only with red numbers');\r\n          return this.red.sub(this, num);\r\n        };\r\n\r\n        BN.prototype.redISub = function redISub(num) {\r\n          assert(this.red, 'redISub works only with red numbers');\r\n          return this.red.isub(this, num);\r\n        };\r\n\r\n        BN.prototype.redShl = function redShl(num) {\r\n          assert(this.red, 'redShl works only with red numbers');\r\n          return this.red.shl(this, num);\r\n        };\r\n\r\n        BN.prototype.redMul = function redMul(num) {\r\n          assert(this.red, 'redMul works only with red numbers');\r\n          this.red._verify2(this, num);\r\n          return this.red.mul(this, num);\r\n        };\r\n\r\n        BN.prototype.redIMul = function redIMul(num) {\r\n          assert(this.red, 'redMul works only with red numbers');\r\n          this.red._verify2(this, num);\r\n          return this.red.imul(this, num);\r\n        };\r\n\r\n        BN.prototype.redSqr = function redSqr() {\r\n          assert(this.red, 'redSqr works only with red numbers');\r\n          this.red._verify1(this);\r\n          return this.red.sqr(this);\r\n        };\r\n\r\n        BN.prototype.redISqr = function redISqr() {\r\n          assert(this.red, 'redISqr works only with red numbers');\r\n          this.red._verify1(this);\r\n          return this.red.isqr(this);\r\n        };\r\n\r\n        // Square root over p\r\n        BN.prototype.redSqrt = function redSqrt() {\r\n          assert(this.red, 'redSqrt works only with red numbers');\r\n          this.red._verify1(this);\r\n          return this.red.sqrt(this);\r\n        };\r\n\r\n        BN.prototype.redInvm = function redInvm() {\r\n          assert(this.red, 'redInvm works only with red numbers');\r\n          this.red._verify1(this);\r\n          return this.red.invm(this);\r\n        };\r\n\r\n        // Return negative clone of `this` % `red modulo`\r\n        BN.prototype.redNeg = function redNeg() {\r\n          assert(this.red, 'redNeg works only with red numbers');\r\n          this.red._verify1(this);\r\n          return this.red.neg(this);\r\n        };\r\n\r\n        BN.prototype.redPow = function redPow(num) {\r\n          assert(this.red && !num.red, 'redPow(normalNum)');\r\n          this.red._verify1(this);\r\n          return this.red.pow(this, num);\r\n        };\r\n\r\n        // Prime numbers with efficient reduction\r\n        var primes = {\r\n          k256: null,\r\n          p224: null,\r\n          p192: null,\r\n          p25519: null\r\n        };\r\n\r\n        // Pseudo-Mersenne prime\r\n        function MPrime(name, p) {\r\n          // P = 2 ^ N - K\r\n          this.name = name;\r\n          this.p = new BN(p, 16);\r\n          this.n = this.p.bitLength();\r\n          this.k = new BN(1).iushln(this.n).isub(this.p);\r\n\r\n          this.tmp = this._tmp();\r\n        }\r\n\r\n        MPrime.prototype._tmp = function _tmp() {\r\n          var tmp = new BN(null);\r\n          tmp.words = new Array(Math.ceil(this.n / 13));\r\n          return tmp;\r\n        };\r\n\r\n        MPrime.prototype.ireduce = function ireduce(num) {\r\n          // Assumes that `num` is less than `P^2`\r\n          // num = HI * (2 ^ N - K) + HI * K + LO = HI * K + LO (mod P)\r\n          var r = num;\r\n          var rlen;\r\n\r\n          do {\r\n            this.split(r, this.tmp);\r\n            r = this.imulK(r);\r\n            r = r.iadd(this.tmp);\r\n            rlen = r.bitLength();\r\n          } while (rlen > this.n);\r\n\r\n          var cmp = rlen < this.n ? -1 : r.ucmp(this.p);\r\n          if (cmp === 0) {\r\n            r.words[0] = 0;\r\n            r.length = 1;\r\n          } else if (cmp > 0) {\r\n            r.isub(this.p);\r\n          } else {\r\n            r.strip();\r\n          }\r\n\r\n          return r;\r\n        };\r\n\r\n        MPrime.prototype.split = function split(input, out) {\r\n          input.iushrn(this.n, 0, out);\r\n        };\r\n\r\n        MPrime.prototype.imulK = function imulK(num) {\r\n          return num.imul(this.k);\r\n        };\r\n\r\n        function K256() {\r\n          MPrime.call(\r\n            this,\r\n            'k256',\r\n            'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f');\r\n        }\r\n        inherits(K256, MPrime);\r\n\r\n        K256.prototype.split = function split(input, output) {\r\n          // 256 = 9 * 26 + 22\r\n          var mask = 0x3fffff;\r\n\r\n          var outLen = Math.min(input.length, 9);\r\n          for (var i = 0; i < outLen; i++) {\r\n            output.words[i] = input.words[i];\r\n          }\r\n          output.length = outLen;\r\n\r\n          if (input.length <= 9) {\r\n            input.words[0] = 0;\r\n            input.length = 1;\r\n            return;\r\n          }\r\n\r\n          // Shift by 9 limbs\r\n          var prev = input.words[9];\r\n          output.words[output.length++] = prev & mask;\r\n\r\n          for (i = 10; i < input.length; i++) {\r\n            var next = input.words[i] | 0;\r\n            input.words[i - 10] = ((next & mask) << 4) | (prev >>> 22);\r\n            prev = next;\r\n          }\r\n          prev >>>= 22;\r\n          input.words[i - 10] = prev;\r\n          if (prev === 0 && input.length > 10) {\r\n            input.length -= 10;\r\n          } else {\r\n            input.length -= 9;\r\n          }\r\n        };\r\n\r\n        K256.prototype.imulK = function imulK(num) {\r\n          // K = 0x1000003d1 = [ 0x40, 0x3d1 ]\r\n          num.words[num.length] = 0;\r\n          num.words[num.length + 1] = 0;\r\n          num.length += 2;\r\n\r\n          // bounded at: 0x40 * 0x3ffffff + 0x3d0 = 0x100000390\r\n          var lo = 0;\r\n          for (var i = 0; i < num.length; i++) {\r\n            var w = num.words[i] | 0;\r\n            lo += w * 0x3d1;\r\n            num.words[i] = lo & 0x3ffffff;\r\n            lo = w * 0x40 + ((lo / 0x4000000) | 0);\r\n          }\r\n\r\n          // Fast length reduction\r\n          if (num.words[num.length - 1] === 0) {\r\n            num.length--;\r\n            if (num.words[num.length - 1] === 0) {\r\n              num.length--;\r\n            }\r\n          }\r\n          return num;\r\n        };\r\n\r\n        function P224() {\r\n          MPrime.call(\r\n            this,\r\n            'p224',\r\n            'ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001');\r\n        }\r\n        inherits(P224, MPrime);\r\n\r\n        function P192() {\r\n          MPrime.call(\r\n            this,\r\n            'p192',\r\n            'ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff');\r\n        }\r\n        inherits(P192, MPrime);\r\n\r\n        function P25519() {\r\n          // 2 ^ 255 - 19\r\n          MPrime.call(\r\n            this,\r\n            '25519',\r\n            '7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed');\r\n        }\r\n        inherits(P25519, MPrime);\r\n\r\n        P25519.prototype.imulK = function imulK(num) {\r\n          // K = 0x13\r\n          var carry = 0;\r\n          for (var i = 0; i < num.length; i++) {\r\n            var hi = (num.words[i] | 0) * 0x13 + carry;\r\n            var lo = hi & 0x3ffffff;\r\n            hi >>>= 26;\r\n\r\n            num.words[i] = lo;\r\n            carry = hi;\r\n          }\r\n          if (carry !== 0) {\r\n            num.words[num.length++] = carry;\r\n          }\r\n          return num;\r\n        };\r\n\r\n        // Exported mostly for testing purposes, use plain name instead\r\n        BN._prime = function prime(name) {\r\n          // Cached version of prime\r\n          if (primes[name]) return primes[name];\r\n\r\n          var prime;\r\n          if (name === 'k256') {\r\n            prime = new K256();\r\n          } else if (name === 'p224') {\r\n            prime = new P224();\r\n          } else if (name === 'p192') {\r\n            prime = new P192();\r\n          } else if (name === 'p25519') {\r\n            prime = new P25519();\r\n          } else {\r\n            throw new Error('Unknown prime ' + name);\r\n          }\r\n          primes[name] = prime;\r\n\r\n          return prime;\r\n        };\r\n\r\n        //\r\n        // Base reduction engine\r\n        //\r\n        function Red(m) {\r\n          if (typeof m === 'string') {\r\n            var prime = BN._prime(m);\r\n            this.m = prime.p;\r\n            this.prime = prime;\r\n          } else {\r\n            assert(m.gtn(1), 'modulus must be greater than 1');\r\n            this.m = m;\r\n            this.prime = null;\r\n          }\r\n        }\r\n\r\n        Red.prototype._verify1 = function _verify1(a) {\r\n          assert(a.negative === 0, 'red works only with positives');\r\n          assert(a.red, 'red works only with red numbers');\r\n        };\r\n\r\n        Red.prototype._verify2 = function _verify2(a, b) {\r\n          assert((a.negative | b.negative) === 0, 'red works only with positives');\r\n          assert(a.red && a.red === b.red,\r\n            'red works only with red numbers');\r\n        };\r\n\r\n        Red.prototype.imod = function imod(a) {\r\n          if (this.prime) return this.prime.ireduce(a)._forceRed(this);\r\n          return a.umod(this.m)._forceRed(this);\r\n        };\r\n\r\n        Red.prototype.neg = function neg(a) {\r\n          if (a.isZero()) {\r\n            return a.clone();\r\n          }\r\n\r\n          return this.m.sub(a)._forceRed(this);\r\n        };\r\n\r\n        Red.prototype.add = function add(a, b) {\r\n          this._verify2(a, b);\r\n\r\n          var res = a.add(b);\r\n          if (res.cmp(this.m) >= 0) {\r\n            res.isub(this.m);\r\n          }\r\n          return res._forceRed(this);\r\n        };\r\n\r\n        Red.prototype.iadd = function iadd(a, b) {\r\n          this._verify2(a, b);\r\n\r\n          var res = a.iadd(b);\r\n          if (res.cmp(this.m) >= 0) {\r\n            res.isub(this.m);\r\n          }\r\n          return res;\r\n        };\r\n\r\n        Red.prototype.sub = function sub(a, b) {\r\n          this._verify2(a, b);\r\n\r\n          var res = a.sub(b);\r\n          if (res.cmpn(0) < 0) {\r\n            res.iadd(this.m);\r\n          }\r\n          return res._forceRed(this);\r\n        };\r\n\r\n        Red.prototype.isub = function isub(a, b) {\r\n          this._verify2(a, b);\r\n\r\n          var res = a.isub(b);\r\n          if (res.cmpn(0) < 0) {\r\n            res.iadd(this.m);\r\n          }\r\n          return res;\r\n        };\r\n\r\n        Red.prototype.shl = function shl(a, num) {\r\n          this._verify1(a);\r\n          return this.imod(a.ushln(num));\r\n        };\r\n\r\n        Red.prototype.imul = function imul(a, b) {\r\n          this._verify2(a, b);\r\n          return this.imod(a.imul(b));\r\n        };\r\n\r\n        Red.prototype.mul = function mul(a, b) {\r\n          this._verify2(a, b);\r\n          return this.imod(a.mul(b));\r\n        };\r\n\r\n        Red.prototype.isqr = function isqr(a) {\r\n          return this.imul(a, a.clone());\r\n        };\r\n\r\n        Red.prototype.sqr = function sqr(a) {\r\n          return this.mul(a, a);\r\n        };\r\n\r\n        Red.prototype.sqrt = function sqrt(a) {\r\n          if (a.isZero()) return a.clone();\r\n\r\n          var mod3 = this.m.andln(3);\r\n          assert(mod3 % 2 === 1);\r\n\r\n          // Fast case\r\n          if (mod3 === 3) {\r\n            var pow = this.m.add(new BN(1)).iushrn(2);\r\n            return this.pow(a, pow);\r\n          }\r\n\r\n          // Tonelli-Shanks algorithm (Totally unoptimized and slow)\r\n          //\r\n          // Find Q and S, that Q * 2 ^ S = (P - 1)\r\n          var q = this.m.subn(1);\r\n          var s = 0;\r\n          while (!q.isZero() && q.andln(1) === 0) {\r\n            s++;\r\n            q.iushrn(1);\r\n          }\r\n          assert(!q.isZero());\r\n\r\n          var one = new BN(1).toRed(this);\r\n          var nOne = one.redNeg();\r\n\r\n          // Find quadratic non-residue\r\n          // NOTE: Max is such because of generalized Riemann hypothesis.\r\n          var lpow = this.m.subn(1).iushrn(1);\r\n          var z = this.m.bitLength();\r\n          z = new BN(2 * z * z).toRed(this);\r\n\r\n          while (this.pow(z, lpow).cmp(nOne) !== 0) {\r\n            z.redIAdd(nOne);\r\n          }\r\n\r\n          var c = this.pow(z, q);\r\n          var r = this.pow(a, q.addn(1).iushrn(1));\r\n          var t = this.pow(a, q);\r\n          var m = s;\r\n          while (t.cmp(one) !== 0) {\r\n            var tmp = t;\r\n            for (var i = 0; tmp.cmp(one) !== 0; i++) {\r\n              tmp = tmp.redSqr();\r\n            }\r\n            assert(i < m);\r\n            var b = this.pow(c, new BN(1).iushln(m - i - 1));\r\n\r\n            r = r.redMul(b);\r\n            c = b.redSqr();\r\n            t = t.redMul(c);\r\n            m = i;\r\n          }\r\n\r\n          return r;\r\n        };\r\n\r\n        Red.prototype.invm = function invm(a) {\r\n          var inv = a._invmp(this.m);\r\n          if (inv.negative !== 0) {\r\n            inv.negative = 0;\r\n            return this.imod(inv).redNeg();\r\n          } else {\r\n            return this.imod(inv);\r\n          }\r\n        };\r\n\r\n        Red.prototype.pow = function pow(a, num) {\r\n          if (num.isZero()) return new BN(1).toRed(this);\r\n          if (num.cmpn(1) === 0) return a.clone();\r\n\r\n          var windowSize = 4;\r\n          var wnd = new Array(1 << windowSize);\r\n          wnd[0] = new BN(1).toRed(this);\r\n          wnd[1] = a;\r\n          for (var i = 2; i < wnd.length; i++) {\r\n            wnd[i] = this.mul(wnd[i - 1], a);\r\n          }\r\n\r\n          var res = wnd[0];\r\n          var current = 0;\r\n          var currentLen = 0;\r\n          var start = num.bitLength() % 26;\r\n          if (start === 0) {\r\n            start = 26;\r\n          }\r\n\r\n          for (i = num.length - 1; i >= 0; i--) {\r\n            var word = num.words[i];\r\n            for (var j = start - 1; j >= 0; j--) {\r\n              var bit = (word >> j) & 1;\r\n              if (res !== wnd[0]) {\r\n                res = this.sqr(res);\r\n              }\r\n\r\n              if (bit === 0 && current === 0) {\r\n                currentLen = 0;\r\n                continue;\r\n              }\r\n\r\n              current <<= 1;\r\n              current |= bit;\r\n              currentLen++;\r\n              if (currentLen !== windowSize && (i !== 0 || j !== 0)) continue;\r\n\r\n              res = this.mul(res, wnd[current]);\r\n              currentLen = 0;\r\n              current = 0;\r\n            }\r\n            start = 26;\r\n          }\r\n\r\n          return res;\r\n        };\r\n\r\n        Red.prototype.convertTo = function convertTo(num) {\r\n          var r = num.umod(this.m);\r\n\r\n          return r === num ? r.clone() : r;\r\n        };\r\n\r\n        Red.prototype.convertFrom = function convertFrom(num) {\r\n          var res = num.clone();\r\n          res.red = null;\r\n          return res;\r\n        };\r\n\r\n        //\r\n        // Montgomery method engine\r\n        //\r\n\r\n        BN.mont = function mont(num) {\r\n          return new Mont(num);\r\n        };\r\n\r\n        function Mont(m) {\r\n          Red.call(this, m);\r\n\r\n          this.shift = this.m.bitLength();\r\n          if (this.shift % 26 !== 0) {\r\n            this.shift += 26 - (this.shift % 26);\r\n          }\r\n\r\n          this.r = new BN(1).iushln(this.shift);\r\n          this.r2 = this.imod(this.r.sqr());\r\n          this.rinv = this.r._invmp(this.m);\r\n\r\n          this.minv = this.rinv.mul(this.r).isubn(1).div(this.m);\r\n          this.minv = this.minv.umod(this.r);\r\n          this.minv = this.r.sub(this.minv);\r\n        }\r\n        inherits(Mont, Red);\r\n\r\n        Mont.prototype.convertTo = function convertTo(num) {\r\n          return this.imod(num.ushln(this.shift));\r\n        };\r\n\r\n        Mont.prototype.convertFrom = function convertFrom(num) {\r\n          var r = this.imod(num.mul(this.rinv));\r\n          r.red = null;\r\n          return r;\r\n        };\r\n\r\n        Mont.prototype.imul = function imul(a, b) {\r\n          if (a.isZero() || b.isZero()) {\r\n            a.words[0] = 0;\r\n            a.length = 1;\r\n            return a;\r\n          }\r\n\r\n          var t = a.imul(b);\r\n          var c = t.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);\r\n          var u = t.isub(c).iushrn(this.shift);\r\n          var res = u;\r\n\r\n          if (u.cmp(this.m) >= 0) {\r\n            res = u.isub(this.m);\r\n          } else if (u.cmpn(0) < 0) {\r\n            res = u.iadd(this.m);\r\n          }\r\n\r\n          return res._forceRed(this);\r\n        };\r\n\r\n        Mont.prototype.mul = function mul(a, b) {\r\n          if (a.isZero() || b.isZero()) return new BN(0)._forceRed(this);\r\n\r\n          var t = a.mul(b);\r\n          var c = t.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);\r\n          var u = t.isub(c).iushrn(this.shift);\r\n          var res = u;\r\n          if (u.cmp(this.m) >= 0) {\r\n            res = u.isub(this.m);\r\n          } else if (u.cmpn(0) < 0) {\r\n            res = u.iadd(this.m);\r\n          }\r\n\r\n          return res._forceRed(this);\r\n        };\r\n\r\n        Mont.prototype.invm = function invm(a) {\r\n          // (AR)^-1 * R^2 = (A^-1 * R^-1) * R^2 = A^-1 * R\r\n          var res = this.imod(a._invmp(this.m).mul(this.r2));\r\n          return res._forceRed(this);\r\n        };\r\n      })(typeof module === 'undefined' || module, this);\r\n\r\n    }, {\r\n      \"buffer\": 25\r\n    }],\r\n    24: [function (require, module, exports) {\r\n      var r;\r\n\r\n      module.exports = function rand(len) {\r\n        if (!r)\r\n          r = new Rand(null);\r\n\r\n        return r.generate(len);\r\n      };\r\n\r\n      function Rand(rand) {\r\n        this.rand = rand;\r\n      }\r\n      module.exports.Rand = Rand;\r\n\r\n      Rand.prototype.generate = function generate(len) {\r\n        return this._rand(len);\r\n      };\r\n\r\n      // Emulate crypto API using randy\r\n      Rand.prototype._rand = function _rand(n) {\r\n        if (this.rand.getBytes)\r\n          return this.rand.getBytes(n);\r\n\r\n        var res = new Uint8Array(n);\r\n        for (var i = 0; i < res.length; i++)\r\n          res[i] = this.rand.getByte();\r\n        return res;\r\n      };\r\n\r\n      if (typeof self === 'object') {\r\n        if (self.crypto && self.crypto.getRandomValues) {\r\n          // Modern browsers\r\n          Rand.prototype._rand = function _rand(n) {\r\n            var arr = new Uint8Array(n);\r\n            self.crypto.getRandomValues(arr);\r\n            return arr;\r\n          };\r\n        } else if (self.msCrypto && self.msCrypto.getRandomValues) {\r\n          // IE\r\n          Rand.prototype._rand = function _rand(n) {\r\n            var arr = new Uint8Array(n);\r\n            self.msCrypto.getRandomValues(arr);\r\n            return arr;\r\n          };\r\n\r\n          // Safari's WebWorkers do not have `crypto`\r\n        } else if (typeof window === 'object') {\r\n          // Old junk\r\n          Rand.prototype._rand = function () {\r\n            throw new Error('Not implemented yet');\r\n          };\r\n        }\r\n      } else {\r\n        // Node.js or Web worker with no crypto support\r\n        try {\r\n          var crypto = require('crypto');\r\n          if (typeof crypto.randomBytes !== 'function')\r\n            throw new Error('Not supported');\r\n\r\n          Rand.prototype._rand = function _rand(n) {\r\n            return crypto.randomBytes(n);\r\n          };\r\n        } catch (e) {}\r\n      }\r\n\r\n    }, {\r\n      \"crypto\": 25\r\n    }],\r\n    25: [function (require, module, exports) {\r\n\r\n    }, {}],\r\n    26: [function (require, module, exports) {\r\n      // based on the aes implimentation in triple sec\r\n      // https://github.com/keybase/triplesec\r\n      // which is in turn based on the one from crypto-js\r\n      // https://code.google.com/p/crypto-js/\r\n\r\n      var Buffer = require('safe-buffer').Buffer\r\n\r\n      function asUInt32Array(buf) {\r\n        if (!Buffer.isBuffer(buf)) buf = Buffer.from(buf)\r\n\r\n        var len = (buf.length / 4) | 0\r\n        var out = new Array(len)\r\n\r\n        for (var i = 0; i < len; i++) {\r\n          out[i] = buf.readUInt32BE(i * 4)\r\n        }\r\n\r\n        return out\r\n      }\r\n\r\n      function scrubVec(v) {\r\n        for (var i = 0; i < v.length; v++) {\r\n          v[i] = 0\r\n        }\r\n      }\r\n\r\n      function cryptBlock(M, keySchedule, SUB_MIX, SBOX, nRounds) {\r\n        var SUB_MIX0 = SUB_MIX[0]\r\n        var SUB_MIX1 = SUB_MIX[1]\r\n        var SUB_MIX2 = SUB_MIX[2]\r\n        var SUB_MIX3 = SUB_MIX[3]\r\n\r\n        var s0 = M[0] ^ keySchedule[0]\r\n        var s1 = M[1] ^ keySchedule[1]\r\n        var s2 = M[2] ^ keySchedule[2]\r\n        var s3 = M[3] ^ keySchedule[3]\r\n        var t0, t1, t2, t3\r\n        var ksRow = 4\r\n\r\n        for (var round = 1; round < nRounds; round++) {\r\n          t0 = SUB_MIX0[s0 >>> 24] ^ SUB_MIX1[(s1 >>> 16) & 0xff] ^ SUB_MIX2[(s2 >>> 8) & 0xff] ^ SUB_MIX3[s3 & 0xff] ^ keySchedule[ksRow++]\r\n          t1 = SUB_MIX0[s1 >>> 24] ^ SUB_MIX1[(s2 >>> 16) & 0xff] ^ SUB_MIX2[(s3 >>> 8) & 0xff] ^ SUB_MIX3[s0 & 0xff] ^ keySchedule[ksRow++]\r\n          t2 = SUB_MIX0[s2 >>> 24] ^ SUB_MIX1[(s3 >>> 16) & 0xff] ^ SUB_MIX2[(s0 >>> 8) & 0xff] ^ SUB_MIX3[s1 & 0xff] ^ keySchedule[ksRow++]\r\n          t3 = SUB_MIX0[s3 >>> 24] ^ SUB_MIX1[(s0 >>> 16) & 0xff] ^ SUB_MIX2[(s1 >>> 8) & 0xff] ^ SUB_MIX3[s2 & 0xff] ^ keySchedule[ksRow++]\r\n          s0 = t0\r\n          s1 = t1\r\n          s2 = t2\r\n          s3 = t3\r\n        }\r\n\r\n        t0 = ((SBOX[s0 >>> 24] << 24) | (SBOX[(s1 >>> 16) & 0xff] << 16) | (SBOX[(s2 >>> 8) & 0xff] << 8) | SBOX[s3 & 0xff]) ^ keySchedule[ksRow++]\r\n        t1 = ((SBOX[s1 >>> 24] << 24) | (SBOX[(s2 >>> 16) & 0xff] << 16) | (SBOX[(s3 >>> 8) & 0xff] << 8) | SBOX[s0 & 0xff]) ^ keySchedule[ksRow++]\r\n        t2 = ((SBOX[s2 >>> 24] << 24) | (SBOX[(s3 >>> 16) & 0xff] << 16) | (SBOX[(s0 >>> 8) & 0xff] << 8) | SBOX[s1 & 0xff]) ^ keySchedule[ksRow++]\r\n        t3 = ((SBOX[s3 >>> 24] << 24) | (SBOX[(s0 >>> 16) & 0xff] << 16) | (SBOX[(s1 >>> 8) & 0xff] << 8) | SBOX[s2 & 0xff]) ^ keySchedule[ksRow++]\r\n        t0 = t0 >>> 0\r\n        t1 = t1 >>> 0\r\n        t2 = t2 >>> 0\r\n        t3 = t3 >>> 0\r\n\r\n        return [t0, t1, t2, t3]\r\n      }\r\n\r\n      // AES constants\r\n      var RCON = [0x00, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36]\r\n      var G = (function () {\r\n        // Compute double table\r\n        var d = new Array(256)\r\n        for (var j = 0; j < 256; j++) {\r\n          if (j < 128) {\r\n            d[j] = j << 1\r\n          } else {\r\n            d[j] = (j << 1) ^ 0x11b\r\n          }\r\n        }\r\n\r\n        var SBOX = []\r\n        var INV_SBOX = []\r\n        var SUB_MIX = [\r\n          [],\r\n          [],\r\n          [],\r\n          []\r\n        ]\r\n        var INV_SUB_MIX = [\r\n          [],\r\n          [],\r\n          [],\r\n          []\r\n        ]\r\n\r\n        // Walk GF(2^8)\r\n        var x = 0\r\n        var xi = 0\r\n        for (var i = 0; i < 256; ++i) {\r\n          // Compute sbox\r\n          var sx = xi ^ (xi << 1) ^ (xi << 2) ^ (xi << 3) ^ (xi << 4)\r\n          sx = (sx >>> 8) ^ (sx & 0xff) ^ 0x63\r\n          SBOX[x] = sx\r\n          INV_SBOX[sx] = x\r\n\r\n          // Compute multiplication\r\n          var x2 = d[x]\r\n          var x4 = d[x2]\r\n          var x8 = d[x4]\r\n\r\n          // Compute sub bytes, mix columns tables\r\n          var t = (d[sx] * 0x101) ^ (sx * 0x1010100)\r\n          SUB_MIX[0][x] = (t << 24) | (t >>> 8)\r\n          SUB_MIX[1][x] = (t << 16) | (t >>> 16)\r\n          SUB_MIX[2][x] = (t << 8) | (t >>> 24)\r\n          SUB_MIX[3][x] = t\r\n\r\n          // Compute inv sub bytes, inv mix columns tables\r\n          t = (x8 * 0x1010101) ^ (x4 * 0x10001) ^ (x2 * 0x101) ^ (x * 0x1010100)\r\n          INV_SUB_MIX[0][sx] = (t << 24) | (t >>> 8)\r\n          INV_SUB_MIX[1][sx] = (t << 16) | (t >>> 16)\r\n          INV_SUB_MIX[2][sx] = (t << 8) | (t >>> 24)\r\n          INV_SUB_MIX[3][sx] = t\r\n\r\n          if (x === 0) {\r\n            x = xi = 1\r\n          } else {\r\n            x = x2 ^ d[d[d[x8 ^ x2]]]\r\n            xi ^= d[d[xi]]\r\n          }\r\n        }\r\n\r\n        return {\r\n          SBOX: SBOX,\r\n          INV_SBOX: INV_SBOX,\r\n          SUB_MIX: SUB_MIX,\r\n          INV_SUB_MIX: INV_SUB_MIX\r\n        }\r\n      })()\r\n\r\n      function AES(key) {\r\n        this._key = asUInt32Array(key)\r\n        this._reset()\r\n      }\r\n\r\n      AES.blockSize = 4 * 4\r\n      AES.keySize = 256 / 8\r\n      AES.prototype.blockSize = AES.blockSize\r\n      AES.prototype.keySize = AES.keySize\r\n      AES.prototype._reset = function () {\r\n        var keyWords = this._key\r\n        var keySize = keyWords.length\r\n        var nRounds = keySize + 6\r\n        var ksRows = (nRounds + 1) * 4\r\n\r\n        var keySchedule = []\r\n        for (var k = 0; k < keySize; k++) {\r\n          keySchedule[k] = keyWords[k]\r\n        }\r\n\r\n        for (k = keySize; k < ksRows; k++) {\r\n          var t = keySchedule[k - 1]\r\n\r\n          if (k % keySize === 0) {\r\n            t = (t << 8) | (t >>> 24)\r\n            t =\r\n              (G.SBOX[t >>> 24] << 24) |\r\n              (G.SBOX[(t >>> 16) & 0xff] << 16) |\r\n              (G.SBOX[(t >>> 8) & 0xff] << 8) |\r\n              (G.SBOX[t & 0xff])\r\n\r\n            t ^= RCON[(k / keySize) | 0] << 24\r\n          } else if (keySize > 6 && k % keySize === 4) {\r\n            t =\r\n              (G.SBOX[t >>> 24] << 24) |\r\n              (G.SBOX[(t >>> 16) & 0xff] << 16) |\r\n              (G.SBOX[(t >>> 8) & 0xff] << 8) |\r\n              (G.SBOX[t & 0xff])\r\n          }\r\n\r\n          keySchedule[k] = keySchedule[k - keySize] ^ t\r\n        }\r\n\r\n        var invKeySchedule = []\r\n        for (var ik = 0; ik < ksRows; ik++) {\r\n          var ksR = ksRows - ik\r\n          var tt = keySchedule[ksR - (ik % 4 ? 0 : 4)]\r\n\r\n          if (ik < 4 || ksR <= 4) {\r\n            invKeySchedule[ik] = tt\r\n          } else {\r\n            invKeySchedule[ik] =\r\n              G.INV_SUB_MIX[0][G.SBOX[tt >>> 24]] ^\r\n              G.INV_SUB_MIX[1][G.SBOX[(tt >>> 16) & 0xff]] ^\r\n              G.INV_SUB_MIX[2][G.SBOX[(tt >>> 8) & 0xff]] ^\r\n              G.INV_SUB_MIX[3][G.SBOX[tt & 0xff]]\r\n          }\r\n        }\r\n\r\n        this._nRounds = nRounds\r\n        this._keySchedule = keySchedule\r\n        this._invKeySchedule = invKeySchedule\r\n      }\r\n\r\n      AES.prototype.encryptBlockRaw = function (M) {\r\n        M = asUInt32Array(M)\r\n        return cryptBlock(M, this._keySchedule, G.SUB_MIX, G.SBOX, this._nRounds)\r\n      }\r\n\r\n      AES.prototype.encryptBlock = function (M) {\r\n        var out = this.encryptBlockRaw(M)\r\n        var buf = Buffer.allocUnsafe(16)\r\n        buf.writeUInt32BE(out[0], 0)\r\n        buf.writeUInt32BE(out[1], 4)\r\n        buf.writeUInt32BE(out[2], 8)\r\n        buf.writeUInt32BE(out[3], 12)\r\n        return buf\r\n      }\r\n\r\n      AES.prototype.decryptBlock = function (M) {\r\n        M = asUInt32Array(M)\r\n\r\n        // swap\r\n        var m1 = M[1]\r\n        M[1] = M[3]\r\n        M[3] = m1\r\n\r\n        var out = cryptBlock(M, this._invKeySchedule, G.INV_SUB_MIX, G.INV_SBOX, this._nRounds)\r\n        var buf = Buffer.allocUnsafe(16)\r\n        buf.writeUInt32BE(out[0], 0)\r\n        buf.writeUInt32BE(out[3], 4)\r\n        buf.writeUInt32BE(out[2], 8)\r\n        buf.writeUInt32BE(out[1], 12)\r\n        return buf\r\n      }\r\n\r\n      AES.prototype.scrub = function () {\r\n        scrubVec(this._keySchedule)\r\n        scrubVec(this._invKeySchedule)\r\n        scrubVec(this._key)\r\n      }\r\n\r\n      module.exports.AES = AES\r\n\r\n    }, {\r\n      \"safe-buffer\": 147\r\n    }],\r\n    27: [function (require, module, exports) {\r\n      var aes = require('./aes')\r\n      var Buffer = require('safe-buffer').Buffer\r\n      var Transform = require('cipher-base')\r\n      var inherits = require('inherits')\r\n      var GHASH = require('./ghash')\r\n      var xor = require('buffer-xor')\r\n      var incr32 = require('./incr32')\r\n\r\n      function xorTest(a, b) {\r\n        var out = 0\r\n        if (a.length !== b.length) out++\r\n\r\n        var len = Math.min(a.length, b.length)\r\n        for (var i = 0; i < len; ++i) {\r\n          out += (a[i] ^ b[i])\r\n        }\r\n\r\n        return out\r\n      }\r\n\r\n      function calcIv(self, iv, ck) {\r\n        if (iv.length === 12) {\r\n          self._finID = Buffer.concat([iv, Buffer.from([0, 0, 0, 1])])\r\n          return Buffer.concat([iv, Buffer.from([0, 0, 0, 2])])\r\n        }\r\n        var ghash = new GHASH(ck)\r\n        var len = iv.length\r\n        var toPad = len % 16\r\n        ghash.update(iv)\r\n        if (toPad) {\r\n          toPad = 16 - toPad\r\n          ghash.update(Buffer.alloc(toPad, 0))\r\n        }\r\n        ghash.update(Buffer.alloc(8, 0))\r\n        var ivBits = len * 8\r\n        var tail = Buffer.alloc(8)\r\n        tail.writeUIntBE(ivBits, 0, 8)\r\n        ghash.update(tail)\r\n        self._finID = ghash.state\r\n        var out = Buffer.from(self._finID)\r\n        incr32(out)\r\n        return out\r\n      }\r\n\r\n      function StreamCipher(mode, key, iv, decrypt) {\r\n        Transform.call(this)\r\n\r\n        var h = Buffer.alloc(4, 0)\r\n\r\n        this._cipher = new aes.AES(key)\r\n        var ck = this._cipher.encryptBlock(h)\r\n        this._ghash = new GHASH(ck)\r\n        iv = calcIv(this, iv, ck)\r\n\r\n        this._prev = Buffer.from(iv)\r\n        this._cache = Buffer.allocUnsafe(0)\r\n        this._secCache = Buffer.allocUnsafe(0)\r\n        this._decrypt = decrypt\r\n        this._alen = 0\r\n        this._len = 0\r\n        this._mode = mode\r\n\r\n        this._authTag = null\r\n        this._called = false\r\n      }\r\n\r\n      inherits(StreamCipher, Transform)\r\n\r\n      StreamCipher.prototype._update = function (chunk) {\r\n        if (!this._called && this._alen) {\r\n          var rump = 16 - (this._alen % 16)\r\n          if (rump < 16) {\r\n            rump = Buffer.alloc(rump, 0)\r\n            this._ghash.update(rump)\r\n          }\r\n        }\r\n\r\n        this._called = true\r\n        var out = this._mode.encrypt(this, chunk)\r\n        if (this._decrypt) {\r\n          this._ghash.update(chunk)\r\n        } else {\r\n          this._ghash.update(out)\r\n        }\r\n        this._len += chunk.length\r\n        return out\r\n      }\r\n\r\n      StreamCipher.prototype._final = function () {\r\n        if (this._decrypt && !this._authTag) throw new Error('Unsupported state or unable to authenticate data')\r\n\r\n        var tag = xor(this._ghash.final(this._alen * 8, this._len * 8), this._cipher.encryptBlock(this._finID))\r\n        if (this._decrypt && xorTest(tag, this._authTag)) throw new Error('Unsupported state or unable to authenticate data')\r\n\r\n        this._authTag = tag\r\n        this._cipher.scrub()\r\n      }\r\n\r\n      StreamCipher.prototype.getAuthTag = function getAuthTag() {\r\n        if (this._decrypt || !Buffer.isBuffer(this._authTag)) throw new Error('Attempting to get auth tag in unsupported state')\r\n\r\n        return this._authTag\r\n      }\r\n\r\n      StreamCipher.prototype.setAuthTag = function setAuthTag(tag) {\r\n        if (!this._decrypt) throw new Error('Attempting to set auth tag in unsupported state')\r\n\r\n        this._authTag = tag\r\n      }\r\n\r\n      StreamCipher.prototype.setAAD = function setAAD(buf) {\r\n        if (this._called) throw new Error('Attempting to set AAD in unsupported state')\r\n\r\n        this._ghash.update(buf)\r\n        this._alen += buf.length\r\n      }\r\n\r\n      module.exports = StreamCipher\r\n\r\n    }, {\r\n      \"./aes\": 26,\r\n      \"./ghash\": 31,\r\n      \"./incr32\": 32,\r\n      \"buffer-xor\": 53,\r\n      \"cipher-base\": 55,\r\n      \"inherits\": 106,\r\n      \"safe-buffer\": 147\r\n    }],\r\n    28: [function (require, module, exports) {\r\n      var ciphers = require('./encrypter')\r\n      var deciphers = require('./decrypter')\r\n      var modes = require('./modes/list.json')\r\n\r\n      function getCiphers() {\r\n        return Object.keys(modes)\r\n      }\r\n\r\n      exports.createCipher = exports.Cipher = ciphers.createCipher\r\n      exports.createCipheriv = exports.Cipheriv = ciphers.createCipheriv\r\n      exports.createDecipher = exports.Decipher = deciphers.createDecipher\r\n      exports.createDecipheriv = exports.Decipheriv = deciphers.createDecipheriv\r\n      exports.listCiphers = exports.getCiphers = getCiphers\r\n\r\n    }, {\r\n      \"./decrypter\": 29,\r\n      \"./encrypter\": 30,\r\n      \"./modes/list.json\": 40\r\n    }],\r\n    29: [function (require, module, exports) {\r\n      var AuthCipher = require('./authCipher')\r\n      var Buffer = require('safe-buffer').Buffer\r\n      var MODES = require('./modes')\r\n      var StreamCipher = require('./streamCipher')\r\n      var Transform = require('cipher-base')\r\n      var aes = require('./aes')\r\n      var ebtk = require('evp_bytestokey')\r\n      var inherits = require('inherits')\r\n\r\n      function Decipher(mode, key, iv) {\r\n        Transform.call(this)\r\n\r\n        this._cache = new Splitter()\r\n        this._last = void 0\r\n        this._cipher = new aes.AES(key)\r\n        this._prev = Buffer.from(iv)\r\n        this._mode = mode\r\n        this._autopadding = true\r\n      }\r\n\r\n      inherits(Decipher, Transform)\r\n\r\n      Decipher.prototype._update = function (data) {\r\n        this._cache.add(data)\r\n        var chunk\r\n        var thing\r\n        var out = []\r\n        while ((chunk = this._cache.get(this._autopadding))) {\r\n          thing = this._mode.decrypt(this, chunk)\r\n          out.push(thing)\r\n        }\r\n        return Buffer.concat(out)\r\n      }\r\n\r\n      Decipher.prototype._final = function () {\r\n        var chunk = this._cache.flush()\r\n        if (this._autopadding) {\r\n          return unpad(this._mode.decrypt(this, chunk))\r\n        } else if (chunk) {\r\n          throw new Error('data not multiple of block length')\r\n        }\r\n      }\r\n\r\n      Decipher.prototype.setAutoPadding = function (setTo) {\r\n        this._autopadding = !!setTo\r\n        return this\r\n      }\r\n\r\n      function Splitter() {\r\n        this.cache = Buffer.allocUnsafe(0)\r\n      }\r\n\r\n      Splitter.prototype.add = function (data) {\r\n        this.cache = Buffer.concat([this.cache, data])\r\n      }\r\n\r\n      Splitter.prototype.get = function (autoPadding) {\r\n        var out\r\n        if (autoPadding) {\r\n          if (this.cache.length > 16) {\r\n            out = this.cache.slice(0, 16)\r\n            this.cache = this.cache.slice(16)\r\n            return out\r\n          }\r\n        } else {\r\n          if (this.cache.length >= 16) {\r\n            out = this.cache.slice(0, 16)\r\n            this.cache = this.cache.slice(16)\r\n            return out\r\n          }\r\n        }\r\n\r\n        return null\r\n      }\r\n\r\n      Splitter.prototype.flush = function () {\r\n        if (this.cache.length) return this.cache\r\n      }\r\n\r\n      function unpad(last) {\r\n        var padded = last[15]\r\n        if (padded < 1 || padded > 16) {\r\n          throw new Error('unable to decrypt data')\r\n        }\r\n        var i = -1\r\n        while (++i < padded) {\r\n          if (last[(i + (16 - padded))] !== padded) {\r\n            throw new Error('unable to decrypt data')\r\n          }\r\n        }\r\n        if (padded === 16) return\r\n\r\n        return last.slice(0, 16 - padded)\r\n      }\r\n\r\n      function createDecipheriv(suite, password, iv) {\r\n        var config = MODES[suite.toLowerCase()]\r\n        if (!config) throw new TypeError('invalid suite type')\r\n\r\n        if (typeof iv === 'string') iv = Buffer.from(iv)\r\n        if (config.mode !== 'GCM' && iv.length !== config.iv) throw new TypeError('invalid iv length ' + iv.length)\r\n\r\n        if (typeof password === 'string') password = Buffer.from(password)\r\n        if (password.length !== config.key / 8) throw new TypeError('invalid key length ' + password.length)\r\n\r\n        if (config.type === 'stream') {\r\n          return new StreamCipher(config.module, password, iv, true)\r\n        } else if (config.type === 'auth') {\r\n          return new AuthCipher(config.module, password, iv, true)\r\n        }\r\n\r\n        return new Decipher(config.module, password, iv)\r\n      }\r\n\r\n      function createDecipher(suite, password) {\r\n        var config = MODES[suite.toLowerCase()]\r\n        if (!config) throw new TypeError('invalid suite type')\r\n\r\n        var keys = ebtk(password, false, config.key, config.iv)\r\n        return createDecipheriv(suite, keys.key, keys.iv)\r\n      }\r\n\r\n      exports.createDecipher = createDecipher\r\n      exports.createDecipheriv = createDecipheriv\r\n\r\n    }, {\r\n      \"./aes\": 26,\r\n      \"./authCipher\": 27,\r\n      \"./modes\": 39,\r\n      \"./streamCipher\": 42,\r\n      \"cipher-base\": 55,\r\n      \"evp_bytestokey\": 90,\r\n      \"inherits\": 106,\r\n      \"safe-buffer\": 147\r\n    }],\r\n    30: [function (require, module, exports) {\r\n      var MODES = require('./modes')\r\n      var AuthCipher = require('./authCipher')\r\n      var Buffer = require('safe-buffer').Buffer\r\n      var StreamCipher = require('./streamCipher')\r\n      var Transform = require('cipher-base')\r\n      var aes = require('./aes')\r\n      var ebtk = require('evp_bytestokey')\r\n      var inherits = require('inherits')\r\n\r\n      function Cipher(mode, key, iv) {\r\n        Transform.call(this)\r\n\r\n        this._cache = new Splitter()\r\n        this._cipher = new aes.AES(key)\r\n        this._prev = Buffer.from(iv)\r\n        this._mode = mode\r\n        this._autopadding = true\r\n      }\r\n\r\n      inherits(Cipher, Transform)\r\n\r\n      Cipher.prototype._update = function (data) {\r\n        this._cache.add(data)\r\n        var chunk\r\n        var thing\r\n        var out = []\r\n\r\n        while ((chunk = this._cache.get())) {\r\n          thing = this._mode.encrypt(this, chunk)\r\n          out.push(thing)\r\n        }\r\n\r\n        return Buffer.concat(out)\r\n      }\r\n\r\n      var PADDING = Buffer.alloc(16, 0x10)\r\n\r\n      Cipher.prototype._final = function () {\r\n        var chunk = this._cache.flush()\r\n        if (this._autopadding) {\r\n          chunk = this._mode.encrypt(this, chunk)\r\n          this._cipher.scrub()\r\n          return chunk\r\n        }\r\n\r\n        if (!chunk.equals(PADDING)) {\r\n          this._cipher.scrub()\r\n          throw new Error('data not multiple of block length')\r\n        }\r\n      }\r\n\r\n      Cipher.prototype.setAutoPadding = function (setTo) {\r\n        this._autopadding = !!setTo\r\n        return this\r\n      }\r\n\r\n      function Splitter() {\r\n        this.cache = Buffer.allocUnsafe(0)\r\n      }\r\n\r\n      Splitter.prototype.add = function (data) {\r\n        this.cache = Buffer.concat([this.cache, data])\r\n      }\r\n\r\n      Splitter.prototype.get = function () {\r\n        if (this.cache.length > 15) {\r\n          var out = this.cache.slice(0, 16)\r\n          this.cache = this.cache.slice(16)\r\n          return out\r\n        }\r\n        return null\r\n      }\r\n\r\n      Splitter.prototype.flush = function () {\r\n        var len = 16 - this.cache.length\r\n        var padBuff = Buffer.allocUnsafe(len)\r\n\r\n        var i = -1\r\n        while (++i < len) {\r\n          padBuff.writeUInt8(len, i)\r\n        }\r\n\r\n        return Buffer.concat([this.cache, padBuff])\r\n      }\r\n\r\n      function createCipheriv(suite, password, iv) {\r\n        var config = MODES[suite.toLowerCase()]\r\n        if (!config) throw new TypeError('invalid suite type')\r\n\r\n        if (typeof password === 'string') password = Buffer.from(password)\r\n        if (password.length !== config.key / 8) throw new TypeError('invalid key length ' + password.length)\r\n\r\n        if (typeof iv === 'string') iv = Buffer.from(iv)\r\n        if (config.mode !== 'GCM' && iv.length !== config.iv) throw new TypeError('invalid iv length ' + iv.length)\r\n\r\n        if (config.type === 'stream') {\r\n          return new StreamCipher(config.module, password, iv)\r\n        } else if (config.type === 'auth') {\r\n          return new AuthCipher(config.module, password, iv)\r\n        }\r\n\r\n        return new Cipher(config.module, password, iv)\r\n      }\r\n\r\n      function createCipher(suite, password) {\r\n        var config = MODES[suite.toLowerCase()]\r\n        if (!config) throw new TypeError('invalid suite type')\r\n\r\n        var keys = ebtk(password, false, config.key, config.iv)\r\n        return createCipheriv(suite, keys.key, keys.iv)\r\n      }\r\n\r\n      exports.createCipheriv = createCipheriv\r\n      exports.createCipher = createCipher\r\n\r\n    }, {\r\n      \"./aes\": 26,\r\n      \"./authCipher\": 27,\r\n      \"./modes\": 39,\r\n      \"./streamCipher\": 42,\r\n      \"cipher-base\": 55,\r\n      \"evp_bytestokey\": 90,\r\n      \"inherits\": 106,\r\n      \"safe-buffer\": 147\r\n    }],\r\n    31: [function (require, module, exports) {\r\n      var Buffer = require('safe-buffer').Buffer\r\n      var ZEROES = Buffer.alloc(16, 0)\r\n\r\n      function toArray(buf) {\r\n        return [\r\n          buf.readUInt32BE(0),\r\n          buf.readUInt32BE(4),\r\n          buf.readUInt32BE(8),\r\n          buf.readUInt32BE(12)\r\n        ]\r\n      }\r\n\r\n      function fromArray(out) {\r\n        var buf = Buffer.allocUnsafe(16)\r\n        buf.writeUInt32BE(out[0] >>> 0, 0)\r\n        buf.writeUInt32BE(out[1] >>> 0, 4)\r\n        buf.writeUInt32BE(out[2] >>> 0, 8)\r\n        buf.writeUInt32BE(out[3] >>> 0, 12)\r\n        return buf\r\n      }\r\n\r\n      function GHASH(key) {\r\n        this.h = key\r\n        this.state = Buffer.alloc(16, 0)\r\n        this.cache = Buffer.allocUnsafe(0)\r\n      }\r\n\r\n      // from http://bitwiseshiftleft.github.io/sjcl/doc/symbols/src/core_gcm.js.html\r\n      // by Juho Vh-Herttua\r\n      GHASH.prototype.ghash = function (block) {\r\n        var i = -1\r\n        while (++i < block.length) {\r\n          this.state[i] ^= block[i]\r\n        }\r\n        this._multiply()\r\n      }\r\n\r\n      GHASH.prototype._multiply = function () {\r\n        var Vi = toArray(this.h)\r\n        var Zi = [0, 0, 0, 0]\r\n        var j, xi, lsbVi\r\n        var i = -1\r\n        while (++i < 128) {\r\n          xi = (this.state[~~(i / 8)] & (1 << (7 - (i % 8)))) !== 0\r\n          if (xi) {\r\n            // Z_i+1 = Z_i ^ V_i\r\n            Zi[0] ^= Vi[0]\r\n            Zi[1] ^= Vi[1]\r\n            Zi[2] ^= Vi[2]\r\n            Zi[3] ^= Vi[3]\r\n          }\r\n\r\n          // Store the value of LSB(V_i)\r\n          lsbVi = (Vi[3] & 1) !== 0\r\n\r\n          // V_i+1 = V_i >> 1\r\n          for (j = 3; j > 0; j--) {\r\n            Vi[j] = (Vi[j] >>> 1) | ((Vi[j - 1] & 1) << 31)\r\n          }\r\n          Vi[0] = Vi[0] >>> 1\r\n\r\n          // If LSB(V_i) is 1, V_i+1 = (V_i >> 1) ^ R\r\n          if (lsbVi) {\r\n            Vi[0] = Vi[0] ^ (0xe1 << 24)\r\n          }\r\n        }\r\n        this.state = fromArray(Zi)\r\n      }\r\n\r\n      GHASH.prototype.update = function (buf) {\r\n        this.cache = Buffer.concat([this.cache, buf])\r\n        var chunk\r\n        while (this.cache.length >= 16) {\r\n          chunk = this.cache.slice(0, 16)\r\n          this.cache = this.cache.slice(16)\r\n          this.ghash(chunk)\r\n        }\r\n      }\r\n\r\n      GHASH.prototype.final = function (abl, bl) {\r\n        if (this.cache.length) {\r\n          this.ghash(Buffer.concat([this.cache, ZEROES], 16))\r\n        }\r\n\r\n        this.ghash(fromArray([0, abl, 0, bl]))\r\n        return this.state\r\n      }\r\n\r\n      module.exports = GHASH\r\n\r\n    }, {\r\n      \"safe-buffer\": 147\r\n    }],\r\n    32: [function (require, module, exports) {\r\n      function incr32(iv) {\r\n        var len = iv.length\r\n        var item\r\n        while (len--) {\r\n          item = iv.readUInt8(len)\r\n          if (item === 255) {\r\n            iv.writeUInt8(0, len)\r\n          } else {\r\n            item++\r\n            iv.writeUInt8(item, len)\r\n            break\r\n          }\r\n        }\r\n      }\r\n      module.exports = incr32\r\n\r\n    }, {}],\r\n    33: [function (require, module, exports) {\r\n      var xor = require('buffer-xor')\r\n\r\n      exports.encrypt = function (self, block) {\r\n        var data = xor(block, self._prev)\r\n\r\n        self._prev = self._cipher.encryptBlock(data)\r\n        return self._prev\r\n      }\r\n\r\n      exports.decrypt = function (self, block) {\r\n        var pad = self._prev\r\n\r\n        self._prev = block\r\n        var out = self._cipher.decryptBlock(block)\r\n\r\n        return xor(out, pad)\r\n      }\r\n\r\n    }, {\r\n      \"buffer-xor\": 53\r\n    }],\r\n    34: [function (require, module, exports) {\r\n      var Buffer = require('safe-buffer').Buffer\r\n      var xor = require('buffer-xor')\r\n\r\n      function encryptStart(self, data, decrypt) {\r\n        var len = data.length\r\n        var out = xor(data, self._cache)\r\n        self._cache = self._cache.slice(len)\r\n        self._prev = Buffer.concat([self._prev, decrypt ? data : out])\r\n        return out\r\n      }\r\n\r\n      exports.encrypt = function (self, data, decrypt) {\r\n        var out = Buffer.allocUnsafe(0)\r\n        var len\r\n\r\n        while (data.length) {\r\n          if (self._cache.length === 0) {\r\n            self._cache = self._cipher.encryptBlock(self._prev)\r\n            self._prev = Buffer.allocUnsafe(0)\r\n          }\r\n\r\n          if (self._cache.length <= data.length) {\r\n            len = self._cache.length\r\n            out = Buffer.concat([out, encryptStart(self, data.slice(0, len), decrypt)])\r\n            data = data.slice(len)\r\n          } else {\r\n            out = Buffer.concat([out, encryptStart(self, data, decrypt)])\r\n            break\r\n          }\r\n        }\r\n\r\n        return out\r\n      }\r\n\r\n    }, {\r\n      \"buffer-xor\": 53,\r\n      \"safe-buffer\": 147\r\n    }],\r\n    35: [function (require, module, exports) {\r\n      var Buffer = require('safe-buffer').Buffer\r\n\r\n      function encryptByte(self, byteParam, decrypt) {\r\n        var pad\r\n        var i = -1\r\n        var len = 8\r\n        var out = 0\r\n        var bit, value\r\n        while (++i < len) {\r\n          pad = self._cipher.encryptBlock(self._prev)\r\n          bit = (byteParam & (1 << (7 - i))) ? 0x80 : 0\r\n          value = pad[0] ^ bit\r\n          out += ((value & 0x80) >> (i % 8))\r\n          self._prev = shiftIn(self._prev, decrypt ? bit : value)\r\n        }\r\n        return out\r\n      }\r\n\r\n      function shiftIn(buffer, value) {\r\n        var len = buffer.length\r\n        var i = -1\r\n        var out = Buffer.allocUnsafe(buffer.length)\r\n        buffer = Buffer.concat([buffer, Buffer.from([value])])\r\n\r\n        while (++i < len) {\r\n          out[i] = buffer[i] << 1 | buffer[i + 1] >> (7)\r\n        }\r\n\r\n        return out\r\n      }\r\n\r\n      exports.encrypt = function (self, chunk, decrypt) {\r\n        var len = chunk.length\r\n        var out = Buffer.allocUnsafe(len)\r\n        var i = -1\r\n\r\n        while (++i < len) {\r\n          out[i] = encryptByte(self, chunk[i], decrypt)\r\n        }\r\n\r\n        return out\r\n      }\r\n\r\n    }, {\r\n      \"safe-buffer\": 147\r\n    }],\r\n    36: [function (require, module, exports) {\r\n      var Buffer = require('safe-buffer').Buffer\r\n\r\n      function encryptByte(self, byteParam, decrypt) {\r\n        var pad = self._cipher.encryptBlock(self._prev)\r\n        var out = pad[0] ^ byteParam\r\n\r\n        self._prev = Buffer.concat([\r\n          self._prev.slice(1),\r\n          Buffer.from([decrypt ? byteParam : out])\r\n        ])\r\n\r\n        return out\r\n      }\r\n\r\n      exports.encrypt = function (self, chunk, decrypt) {\r\n        var len = chunk.length\r\n        var out = Buffer.allocUnsafe(len)\r\n        var i = -1\r\n\r\n        while (++i < len) {\r\n          out[i] = encryptByte(self, chunk[i], decrypt)\r\n        }\r\n\r\n        return out\r\n      }\r\n\r\n    }, {\r\n      \"safe-buffer\": 147\r\n    }],\r\n    37: [function (require, module, exports) {\r\n      var xor = require('buffer-xor')\r\n      var Buffer = require('safe-buffer').Buffer\r\n      var incr32 = require('../incr32')\r\n\r\n      function getBlock(self) {\r\n        var out = self._cipher.encryptBlockRaw(self._prev)\r\n        incr32(self._prev)\r\n        return out\r\n      }\r\n\r\n      var blockSize = 16\r\n      exports.encrypt = function (self, chunk) {\r\n        var chunkNum = Math.ceil(chunk.length / blockSize)\r\n        var start = self._cache.length\r\n        self._cache = Buffer.concat([\r\n          self._cache,\r\n          Buffer.allocUnsafe(chunkNum * blockSize)\r\n        ])\r\n        for (var i = 0; i < chunkNum; i++) {\r\n          var out = getBlock(self)\r\n          var offset = start + i * blockSize\r\n          self._cache.writeUInt32BE(out[0], offset + 0)\r\n          self._cache.writeUInt32BE(out[1], offset + 4)\r\n          self._cache.writeUInt32BE(out[2], offset + 8)\r\n          self._cache.writeUInt32BE(out[3], offset + 12)\r\n        }\r\n        var pad = self._cache.slice(0, chunk.length)\r\n        self._cache = self._cache.slice(chunk.length)\r\n        return xor(chunk, pad)\r\n      }\r\n\r\n    }, {\r\n      \"../incr32\": 32,\r\n      \"buffer-xor\": 53,\r\n      \"safe-buffer\": 147\r\n    }],\r\n    38: [function (require, module, exports) {\r\n      exports.encrypt = function (self, block) {\r\n        return self._cipher.encryptBlock(block)\r\n      }\r\n\r\n      exports.decrypt = function (self, block) {\r\n        return self._cipher.decryptBlock(block)\r\n      }\r\n\r\n    }, {}],\r\n    39: [function (require, module, exports) {\r\n      var modeModules = {\r\n        ECB: require('./ecb'),\r\n        CBC: require('./cbc'),\r\n        CFB: require('./cfb'),\r\n        CFB8: require('./cfb8'),\r\n        CFB1: require('./cfb1'),\r\n        OFB: require('./ofb'),\r\n        CTR: require('./ctr'),\r\n        GCM: require('./ctr')\r\n      }\r\n\r\n      var modes = require('./list.json')\r\n\r\n      for (var key in modes) {\r\n        modes[key].module = modeModules[modes[key].mode]\r\n      }\r\n\r\n      module.exports = modes\r\n\r\n    }, {\r\n      \"./cbc\": 33,\r\n      \"./cfb\": 34,\r\n      \"./cfb1\": 35,\r\n      \"./cfb8\": 36,\r\n      \"./ctr\": 37,\r\n      \"./ecb\": 38,\r\n      \"./list.json\": 40,\r\n      \"./ofb\": 41\r\n    }],\r\n    40: [function (require, module, exports) {\r\n      module.exports = {\r\n        \"aes-128-ecb\": {\r\n          \"cipher\": \"AES\",\r\n          \"key\": 128,\r\n          \"iv\": 0,\r\n          \"mode\": \"ECB\",\r\n          \"type\": \"block\"\r\n        },\r\n        \"aes-192-ecb\": {\r\n          \"cipher\": \"AES\",\r\n          \"key\": 192,\r\n          \"iv\": 0,\r\n          \"mode\": \"ECB\",\r\n          \"type\": \"block\"\r\n        },\r\n        \"aes-256-ecb\": {\r\n          \"cipher\": \"AES\",\r\n          \"key\": 256,\r\n          \"iv\": 0,\r\n          \"mode\": \"ECB\",\r\n          \"type\": \"block\"\r\n        },\r\n        \"aes-128-cbc\": {\r\n          \"cipher\": \"AES\",\r\n          \"key\": 128,\r\n          \"iv\": 16,\r\n          \"mode\": \"CBC\",\r\n          \"type\": \"block\"\r\n        },\r\n        \"aes-192-cbc\": {\r\n          \"cipher\": \"AES\",\r\n          \"key\": 192,\r\n          \"iv\": 16,\r\n          \"mode\": \"CBC\",\r\n          \"type\": \"block\"\r\n        },\r\n        \"aes-256-cbc\": {\r\n          \"cipher\": \"AES\",\r\n          \"key\": 256,\r\n          \"iv\": 16,\r\n          \"mode\": \"CBC\",\r\n          \"type\": \"block\"\r\n        },\r\n        \"aes128\": {\r\n          \"cipher\": \"AES\",\r\n          \"key\": 128,\r\n          \"iv\": 16,\r\n          \"mode\": \"CBC\",\r\n          \"type\": \"block\"\r\n        },\r\n        \"aes192\": {\r\n          \"cipher\": \"AES\",\r\n          \"key\": 192,\r\n          \"iv\": 16,\r\n          \"mode\": \"CBC\",\r\n          \"type\": \"block\"\r\n        },\r\n        \"aes256\": {\r\n          \"cipher\": \"AES\",\r\n          \"key\": 256,\r\n          \"iv\": 16,\r\n          \"mode\": \"CBC\",\r\n          \"type\": \"block\"\r\n        },\r\n        \"aes-128-cfb\": {\r\n          \"cipher\": \"AES\",\r\n          \"key\": 128,\r\n          \"iv\": 16,\r\n          \"mode\": \"CFB\",\r\n          \"type\": \"stream\"\r\n        },\r\n        \"aes-192-cfb\": {\r\n          \"cipher\": \"AES\",\r\n          \"key\": 192,\r\n          \"iv\": 16,\r\n          \"mode\": \"CFB\",\r\n          \"type\": \"stream\"\r\n        },\r\n        \"aes-256-cfb\": {\r\n          \"cipher\": \"AES\",\r\n          \"key\": 256,\r\n          \"iv\": 16,\r\n          \"mode\": \"CFB\",\r\n          \"type\": \"stream\"\r\n        },\r\n        \"aes-128-cfb8\": {\r\n          \"cipher\": \"AES\",\r\n          \"key\": 128,\r\n          \"iv\": 16,\r\n          \"mode\": \"CFB8\",\r\n          \"type\": \"stream\"\r\n        },\r\n        \"aes-192-cfb8\": {\r\n          \"cipher\": \"AES\",\r\n          \"key\": 192,\r\n          \"iv\": 16,\r\n          \"mode\": \"CFB8\",\r\n          \"type\": \"stream\"\r\n        },\r\n        \"aes-256-cfb8\": {\r\n          \"cipher\": \"AES\",\r\n          \"key\": 256,\r\n          \"iv\": 16,\r\n          \"mode\": \"CFB8\",\r\n          \"type\": \"stream\"\r\n        },\r\n        \"aes-128-cfb1\": {\r\n          \"cipher\": \"AES\",\r\n          \"key\": 128,\r\n          \"iv\": 16,\r\n          \"mode\": \"CFB1\",\r\n          \"type\": \"stream\"\r\n        },\r\n        \"aes-192-cfb1\": {\r\n          \"cipher\": \"AES\",\r\n          \"key\": 192,\r\n          \"iv\": 16,\r\n          \"mode\": \"CFB1\",\r\n          \"type\": \"stream\"\r\n        },\r\n        \"aes-256-cfb1\": {\r\n          \"cipher\": \"AES\",\r\n          \"key\": 256,\r\n          \"iv\": 16,\r\n          \"mode\": \"CFB1\",\r\n          \"type\": \"stream\"\r\n        },\r\n        \"aes-128-ofb\": {\r\n          \"cipher\": \"AES\",\r\n          \"key\": 128,\r\n          \"iv\": 16,\r\n          \"mode\": \"OFB\",\r\n          \"type\": \"stream\"\r\n        },\r\n        \"aes-192-ofb\": {\r\n          \"cipher\": \"AES\",\r\n          \"key\": 192,\r\n          \"iv\": 16,\r\n          \"mode\": \"OFB\",\r\n          \"type\": \"stream\"\r\n        },\r\n        \"aes-256-ofb\": {\r\n          \"cipher\": \"AES\",\r\n          \"key\": 256,\r\n          \"iv\": 16,\r\n          \"mode\": \"OFB\",\r\n          \"type\": \"stream\"\r\n        },\r\n        \"aes-128-ctr\": {\r\n          \"cipher\": \"AES\",\r\n          \"key\": 128,\r\n          \"iv\": 16,\r\n          \"mode\": \"CTR\",\r\n          \"type\": \"stream\"\r\n        },\r\n        \"aes-192-ctr\": {\r\n          \"cipher\": \"AES\",\r\n          \"key\": 192,\r\n          \"iv\": 16,\r\n          \"mode\": \"CTR\",\r\n          \"type\": \"stream\"\r\n        },\r\n        \"aes-256-ctr\": {\r\n          \"cipher\": \"AES\",\r\n          \"key\": 256,\r\n          \"iv\": 16,\r\n          \"mode\": \"CTR\",\r\n          \"type\": \"stream\"\r\n        },\r\n        \"aes-128-gcm\": {\r\n          \"cipher\": \"AES\",\r\n          \"key\": 128,\r\n          \"iv\": 12,\r\n          \"mode\": \"GCM\",\r\n          \"type\": \"auth\"\r\n        },\r\n        \"aes-192-gcm\": {\r\n          \"cipher\": \"AES\",\r\n          \"key\": 192,\r\n          \"iv\": 12,\r\n          \"mode\": \"GCM\",\r\n          \"type\": \"auth\"\r\n        },\r\n        \"aes-256-gcm\": {\r\n          \"cipher\": \"AES\",\r\n          \"key\": 256,\r\n          \"iv\": 12,\r\n          \"mode\": \"GCM\",\r\n          \"type\": \"auth\"\r\n        }\r\n      }\r\n\r\n    }, {}],\r\n    41: [function (require, module, exports) {\r\n      (function (Buffer) {\r\n        var xor = require('buffer-xor')\r\n\r\n        function getBlock(self) {\r\n          self._prev = self._cipher.encryptBlock(self._prev)\r\n          return self._prev\r\n        }\r\n\r\n        exports.encrypt = function (self, chunk) {\r\n          while (self._cache.length < chunk.length) {\r\n            self._cache = Buffer.concat([self._cache, getBlock(self)])\r\n          }\r\n\r\n          var pad = self._cache.slice(0, chunk.length)\r\n          self._cache = self._cache.slice(chunk.length)\r\n          return xor(chunk, pad)\r\n        }\r\n\r\n      }).call(this, require(\"buffer\").Buffer)\r\n    }, {\r\n      \"buffer\": 54,\r\n      \"buffer-xor\": 53\r\n    }],\r\n    42: [function (require, module, exports) {\r\n      var aes = require('./aes')\r\n      var Buffer = require('safe-buffer').Buffer\r\n      var Transform = require('cipher-base')\r\n      var inherits = require('inherits')\r\n\r\n      function StreamCipher(mode, key, iv, decrypt) {\r\n        Transform.call(this)\r\n\r\n        this._cipher = new aes.AES(key)\r\n        this._prev = Buffer.from(iv)\r\n        this._cache = Buffer.allocUnsafe(0)\r\n        this._secCache = Buffer.allocUnsafe(0)\r\n        this._decrypt = decrypt\r\n        this._mode = mode\r\n      }\r\n\r\n      inherits(StreamCipher, Transform)\r\n\r\n      StreamCipher.prototype._update = function (chunk) {\r\n        return this._mode.encrypt(this, chunk, this._decrypt)\r\n      }\r\n\r\n      StreamCipher.prototype._final = function () {\r\n        this._cipher.scrub()\r\n      }\r\n\r\n      module.exports = StreamCipher\r\n\r\n    }, {\r\n      \"./aes\": 26,\r\n      \"cipher-base\": 55,\r\n      \"inherits\": 106,\r\n      \"safe-buffer\": 147\r\n    }],\r\n    43: [function (require, module, exports) {\r\n      var DES = require('browserify-des')\r\n      var aes = require('browserify-aes/browser')\r\n      var aesModes = require('browserify-aes/modes')\r\n      var desModes = require('browserify-des/modes')\r\n      var ebtk = require('evp_bytestokey')\r\n\r\n      function createCipher(suite, password) {\r\n        suite = suite.toLowerCase()\r\n\r\n        var keyLen, ivLen\r\n        if (aesModes[suite]) {\r\n          keyLen = aesModes[suite].key\r\n          ivLen = aesModes[suite].iv\r\n        } else if (desModes[suite]) {\r\n          keyLen = desModes[suite].key * 8\r\n          ivLen = desModes[suite].iv\r\n        } else {\r\n          throw new TypeError('invalid suite type')\r\n        }\r\n\r\n        var keys = ebtk(password, false, keyLen, ivLen)\r\n        return createCipheriv(suite, keys.key, keys.iv)\r\n      }\r\n\r\n      function createDecipher(suite, password) {\r\n        suite = suite.toLowerCase()\r\n\r\n        var keyLen, ivLen\r\n        if (aesModes[suite]) {\r\n          keyLen = aesModes[suite].key\r\n          ivLen = aesModes[suite].iv\r\n        } else if (desModes[suite]) {\r\n          keyLen = desModes[suite].key * 8\r\n          ivLen = desModes[suite].iv\r\n        } else {\r\n          throw new TypeError('invalid suite type')\r\n        }\r\n\r\n        var keys = ebtk(password, false, keyLen, ivLen)\r\n        return createDecipheriv(suite, keys.key, keys.iv)\r\n      }\r\n\r\n      function createCipheriv(suite, key, iv) {\r\n        suite = suite.toLowerCase()\r\n        if (aesModes[suite]) return aes.createCipheriv(suite, key, iv)\r\n        if (desModes[suite]) return new DES({\r\n          key: key,\r\n          iv: iv,\r\n          mode: suite\r\n        })\r\n\r\n        throw new TypeError('invalid suite type')\r\n      }\r\n\r\n      function createDecipheriv(suite, key, iv) {\r\n        suite = suite.toLowerCase()\r\n        if (aesModes[suite]) return aes.createDecipheriv(suite, key, iv)\r\n        if (desModes[suite]) return new DES({\r\n          key: key,\r\n          iv: iv,\r\n          mode: suite,\r\n          decrypt: true\r\n        })\r\n\r\n        throw new TypeError('invalid suite type')\r\n      }\r\n\r\n      function getCiphers() {\r\n        return Object.keys(desModes).concat(aes.getCiphers())\r\n      }\r\n\r\n      exports.createCipher = exports.Cipher = createCipher\r\n      exports.createCipheriv = exports.Cipheriv = createCipheriv\r\n      exports.createDecipher = exports.Decipher = createDecipher\r\n      exports.createDecipheriv = exports.Decipheriv = createDecipheriv\r\n      exports.listCiphers = exports.getCiphers = getCiphers\r\n\r\n    }, {\r\n      \"browserify-aes/browser\": 28,\r\n      \"browserify-aes/modes\": 39,\r\n      \"browserify-des\": 44,\r\n      \"browserify-des/modes\": 45,\r\n      \"evp_bytestokey\": 90\r\n    }],\r\n    44: [function (require, module, exports) {\r\n      var CipherBase = require('cipher-base')\r\n      var des = require('des.js')\r\n      var inherits = require('inherits')\r\n      var Buffer = require('safe-buffer').Buffer\r\n\r\n      var modes = {\r\n        'des-ede3-cbc': des.CBC.instantiate(des.EDE),\r\n        'des-ede3': des.EDE,\r\n        'des-ede-cbc': des.CBC.instantiate(des.EDE),\r\n        'des-ede': des.EDE,\r\n        'des-cbc': des.CBC.instantiate(des.DES),\r\n        'des-ecb': des.DES\r\n      }\r\n      modes.des = modes['des-cbc']\r\n      modes.des3 = modes['des-ede3-cbc']\r\n      module.exports = DES\r\n      inherits(DES, CipherBase)\r\n\r\n      function DES(opts) {\r\n        CipherBase.call(this)\r\n        var modeName = opts.mode.toLowerCase()\r\n        var mode = modes[modeName]\r\n        var type\r\n        if (opts.decrypt) {\r\n          type = 'decrypt'\r\n        } else {\r\n          type = 'encrypt'\r\n        }\r\n        var key = opts.key\r\n        if (!Buffer.isBuffer(key)) {\r\n          key = Buffer.from(key)\r\n        }\r\n        if (modeName === 'des-ede' || modeName === 'des-ede-cbc') {\r\n          key = Buffer.concat([key, key.slice(0, 8)])\r\n        }\r\n        var iv = opts.iv\r\n        if (!Buffer.isBuffer(iv)) {\r\n          iv = Buffer.from(iv)\r\n        }\r\n        this._des = mode.create({\r\n          key: key,\r\n          iv: iv,\r\n          type: type\r\n        })\r\n      }\r\n      DES.prototype._update = function (data) {\r\n        return Buffer.from(this._des.update(data))\r\n      }\r\n      DES.prototype._final = function () {\r\n        return Buffer.from(this._des.final())\r\n      }\r\n\r\n    }, {\r\n      \"cipher-base\": 55,\r\n      \"des.js\": 63,\r\n      \"inherits\": 106,\r\n      \"safe-buffer\": 147\r\n    }],\r\n    45: [function (require, module, exports) {\r\n      exports['des-ecb'] = {\r\n        key: 8,\r\n        iv: 0\r\n      }\r\n      exports['des-cbc'] = exports.des = {\r\n        key: 8,\r\n        iv: 8\r\n      }\r\n      exports['des-ede3-cbc'] = exports.des3 = {\r\n        key: 24,\r\n        iv: 8\r\n      }\r\n      exports['des-ede3'] = {\r\n        key: 24,\r\n        iv: 0\r\n      }\r\n      exports['des-ede-cbc'] = {\r\n        key: 16,\r\n        iv: 8\r\n      }\r\n      exports['des-ede'] = {\r\n        key: 16,\r\n        iv: 0\r\n      }\r\n\r\n    }, {}],\r\n    46: [function (require, module, exports) {\r\n      (function (Buffer) {\r\n        var bn = require('bn.js');\r\n        var randomBytes = require('randombytes');\r\n        module.exports = crt;\r\n\r\n        function blind(priv) {\r\n          var r = getr(priv);\r\n          var blinder = r.toRed(bn.mont(priv.modulus))\r\n            .redPow(new bn(priv.publicExponent)).fromRed();\r\n          return {\r\n            blinder: blinder,\r\n            unblinder: r.invm(priv.modulus)\r\n          };\r\n        }\r\n\r\n        function crt(msg, priv) {\r\n          var blinds = blind(priv);\r\n          var len = priv.modulus.byteLength();\r\n          var mod = bn.mont(priv.modulus);\r\n          var blinded = new bn(msg).mul(blinds.blinder).umod(priv.modulus);\r\n          var c1 = blinded.toRed(bn.mont(priv.prime1));\r\n          var c2 = blinded.toRed(bn.mont(priv.prime2));\r\n          var qinv = priv.coefficient;\r\n          var p = priv.prime1;\r\n          var q = priv.prime2;\r\n          var m1 = c1.redPow(priv.exponent1);\r\n          var m2 = c2.redPow(priv.exponent2);\r\n          m1 = m1.fromRed();\r\n          m2 = m2.fromRed();\r\n          var h = m1.isub(m2).imul(qinv).umod(p);\r\n          h.imul(q);\r\n          m2.iadd(h);\r\n          return new Buffer(m2.imul(blinds.unblinder).umod(priv.modulus).toArray(false, len));\r\n        }\r\n        crt.getr = getr;\r\n\r\n        function getr(priv) {\r\n          var len = priv.modulus.byteLength();\r\n          var r = new bn(randomBytes(len));\r\n          while (r.cmp(priv.modulus) >= 0 || !r.umod(priv.prime1) || !r.umod(priv.prime2)) {\r\n            r = new bn(randomBytes(len));\r\n          }\r\n          return r;\r\n        }\r\n\r\n      }).call(this, require(\"buffer\").Buffer)\r\n    }, {\r\n      \"bn.js\": 23,\r\n      \"buffer\": 54,\r\n      \"randombytes\": 131\r\n    }],\r\n    47: [function (require, module, exports) {\r\n      module.exports = require('./browser/algorithms.json')\r\n\r\n    }, {\r\n      \"./browser/algorithms.json\": 48\r\n    }],\r\n    48: [function (require, module, exports) {\r\n      module.exports = {\r\n        \"sha224WithRSAEncryption\": {\r\n          \"sign\": \"rsa\",\r\n          \"hash\": \"sha224\",\r\n          \"id\": \"302d300d06096086480165030402040500041c\"\r\n        },\r\n        \"RSA-SHA224\": {\r\n          \"sign\": \"ecdsa/rsa\",\r\n          \"hash\": \"sha224\",\r\n          \"id\": \"302d300d06096086480165030402040500041c\"\r\n        },\r\n        \"sha256WithRSAEncryption\": {\r\n          \"sign\": \"rsa\",\r\n          \"hash\": \"sha256\",\r\n          \"id\": \"3031300d060960864801650304020105000420\"\r\n        },\r\n        \"RSA-SHA256\": {\r\n          \"sign\": \"ecdsa/rsa\",\r\n          \"hash\": \"sha256\",\r\n          \"id\": \"3031300d060960864801650304020105000420\"\r\n        },\r\n        \"sha384WithRSAEncryption\": {\r\n          \"sign\": \"rsa\",\r\n          \"hash\": \"sha384\",\r\n          \"id\": \"3041300d060960864801650304020205000430\"\r\n        },\r\n        \"RSA-SHA384\": {\r\n          \"sign\": \"ecdsa/rsa\",\r\n          \"hash\": \"sha384\",\r\n          \"id\": \"3041300d060960864801650304020205000430\"\r\n        },\r\n        \"sha512WithRSAEncryption\": {\r\n          \"sign\": \"rsa\",\r\n          \"hash\": \"sha512\",\r\n          \"id\": \"3051300d060960864801650304020305000440\"\r\n        },\r\n        \"RSA-SHA512\": {\r\n          \"sign\": \"ecdsa/rsa\",\r\n          \"hash\": \"sha512\",\r\n          \"id\": \"3051300d060960864801650304020305000440\"\r\n        },\r\n        \"RSA-SHA1\": {\r\n          \"sign\": \"rsa\",\r\n          \"hash\": \"sha1\",\r\n          \"id\": \"3021300906052b0e03021a05000414\"\r\n        },\r\n        \"ecdsa-with-SHA1\": {\r\n          \"sign\": \"ecdsa\",\r\n          \"hash\": \"sha1\",\r\n          \"id\": \"\"\r\n        },\r\n        \"sha256\": {\r\n          \"sign\": \"ecdsa\",\r\n          \"hash\": \"sha256\",\r\n          \"id\": \"\"\r\n        },\r\n        \"sha224\": {\r\n          \"sign\": \"ecdsa\",\r\n          \"hash\": \"sha224\",\r\n          \"id\": \"\"\r\n        },\r\n        \"sha384\": {\r\n          \"sign\": \"ecdsa\",\r\n          \"hash\": \"sha384\",\r\n          \"id\": \"\"\r\n        },\r\n        \"sha512\": {\r\n          \"sign\": \"ecdsa\",\r\n          \"hash\": \"sha512\",\r\n          \"id\": \"\"\r\n        },\r\n        \"DSA-SHA\": {\r\n          \"sign\": \"dsa\",\r\n          \"hash\": \"sha1\",\r\n          \"id\": \"\"\r\n        },\r\n        \"DSA-SHA1\": {\r\n          \"sign\": \"dsa\",\r\n          \"hash\": \"sha1\",\r\n          \"id\": \"\"\r\n        },\r\n        \"DSA\": {\r\n          \"sign\": \"dsa\",\r\n          \"hash\": \"sha1\",\r\n          \"id\": \"\"\r\n        },\r\n        \"DSA-WITH-SHA224\": {\r\n          \"sign\": \"dsa\",\r\n          \"hash\": \"sha224\",\r\n          \"id\": \"\"\r\n        },\r\n        \"DSA-SHA224\": {\r\n          \"sign\": \"dsa\",\r\n          \"hash\": \"sha224\",\r\n          \"id\": \"\"\r\n        },\r\n        \"DSA-WITH-SHA256\": {\r\n          \"sign\": \"dsa\",\r\n          \"hash\": \"sha256\",\r\n          \"id\": \"\"\r\n        },\r\n        \"DSA-SHA256\": {\r\n          \"sign\": \"dsa\",\r\n          \"hash\": \"sha256\",\r\n          \"id\": \"\"\r\n        },\r\n        \"DSA-WITH-SHA384\": {\r\n          \"sign\": \"dsa\",\r\n          \"hash\": \"sha384\",\r\n          \"id\": \"\"\r\n        },\r\n        \"DSA-SHA384\": {\r\n          \"sign\": \"dsa\",\r\n          \"hash\": \"sha384\",\r\n          \"id\": \"\"\r\n        },\r\n        \"DSA-WITH-SHA512\": {\r\n          \"sign\": \"dsa\",\r\n          \"hash\": \"sha512\",\r\n          \"id\": \"\"\r\n        },\r\n        \"DSA-SHA512\": {\r\n          \"sign\": \"dsa\",\r\n          \"hash\": \"sha512\",\r\n          \"id\": \"\"\r\n        },\r\n        \"DSA-RIPEMD160\": {\r\n          \"sign\": \"dsa\",\r\n          \"hash\": \"rmd160\",\r\n          \"id\": \"\"\r\n        },\r\n        \"ripemd160WithRSA\": {\r\n          \"sign\": \"rsa\",\r\n          \"hash\": \"rmd160\",\r\n          \"id\": \"3021300906052b2403020105000414\"\r\n        },\r\n        \"RSA-RIPEMD160\": {\r\n          \"sign\": \"rsa\",\r\n          \"hash\": \"rmd160\",\r\n          \"id\": \"3021300906052b2403020105000414\"\r\n        },\r\n        \"md5WithRSAEncryption\": {\r\n          \"sign\": \"rsa\",\r\n          \"hash\": \"md5\",\r\n          \"id\": \"3020300c06082a864886f70d020505000410\"\r\n        },\r\n        \"RSA-MD5\": {\r\n          \"sign\": \"rsa\",\r\n          \"hash\": \"md5\",\r\n          \"id\": \"3020300c06082a864886f70d020505000410\"\r\n        }\r\n      }\r\n\r\n    }, {}],\r\n    49: [function (require, module, exports) {\r\n      module.exports = {\r\n        \"1.3.132.0.10\": \"secp256k1\",\r\n        \"1.3.132.0.33\": \"p224\",\r\n        \"1.2.840.10045.3.1.1\": \"p192\",\r\n        \"1.2.840.10045.3.1.7\": \"p256\",\r\n        \"1.3.132.0.34\": \"p384\",\r\n        \"1.3.132.0.35\": \"p521\"\r\n      }\r\n\r\n    }, {}],\r\n    50: [function (require, module, exports) {\r\n      (function (Buffer) {\r\n        var createHash = require('create-hash')\r\n        var stream = require('stream')\r\n        var inherits = require('inherits')\r\n        var sign = require('./sign')\r\n        var verify = require('./verify')\r\n\r\n        var algorithms = require('./algorithms.json')\r\n        Object.keys(algorithms).forEach(function (key) {\r\n          algorithms[key].id = new Buffer(algorithms[key].id, 'hex')\r\n          algorithms[key.toLowerCase()] = algorithms[key]\r\n        })\r\n\r\n        function Sign(algorithm) {\r\n          stream.Writable.call(this)\r\n\r\n          var data = algorithms[algorithm]\r\n          if (!data) throw new Error('Unknown message digest')\r\n\r\n          this._hashType = data.hash\r\n          this._hash = createHash(data.hash)\r\n          this._tag = data.id\r\n          this._signType = data.sign\r\n        }\r\n        inherits(Sign, stream.Writable)\r\n\r\n        Sign.prototype._write = function _write(data, _, done) {\r\n          this._hash.update(data)\r\n          done()\r\n        }\r\n\r\n        Sign.prototype.update = function update(data, enc) {\r\n          if (typeof data === 'string') data = new Buffer(data, enc)\r\n\r\n          this._hash.update(data)\r\n          return this\r\n        }\r\n\r\n        Sign.prototype.sign = function signMethod(key, enc) {\r\n          this.end()\r\n          var hash = this._hash.digest()\r\n          var sig = sign(hash, key, this._hashType, this._signType, this._tag)\r\n\r\n          return enc ? sig.toString(enc) : sig\r\n        }\r\n\r\n        function Verify(algorithm) {\r\n          stream.Writable.call(this)\r\n\r\n          var data = algorithms[algorithm]\r\n          if (!data) throw new Error('Unknown message digest')\r\n\r\n          this._hash = createHash(data.hash)\r\n          this._tag = data.id\r\n          this._signType = data.sign\r\n        }\r\n        inherits(Verify, stream.Writable)\r\n\r\n        Verify.prototype._write = function _write(data, _, done) {\r\n          this._hash.update(data)\r\n          done()\r\n        }\r\n\r\n        Verify.prototype.update = function update(data, enc) {\r\n          if (typeof data === 'string') data = new Buffer(data, enc)\r\n\r\n          this._hash.update(data)\r\n          return this\r\n        }\r\n\r\n        Verify.prototype.verify = function verifyMethod(key, sig, enc) {\r\n          if (typeof sig === 'string') sig = new Buffer(sig, enc)\r\n\r\n          this.end()\r\n          var hash = this._hash.digest()\r\n          return verify(sig, hash, key, this._signType, this._tag)\r\n        }\r\n\r\n        function createSign(algorithm) {\r\n          return new Sign(algorithm)\r\n        }\r\n\r\n        function createVerify(algorithm) {\r\n          return new Verify(algorithm)\r\n        }\r\n\r\n        module.exports = {\r\n          Sign: createSign,\r\n          Verify: createVerify,\r\n          createSign: createSign,\r\n          createVerify: createVerify\r\n        }\r\n\r\n      }).call(this, require(\"buffer\").Buffer)\r\n    }, {\r\n      \"./algorithms.json\": 48,\r\n      \"./sign\": 51,\r\n      \"./verify\": 52,\r\n      \"buffer\": 54,\r\n      \"create-hash\": 58,\r\n      \"inherits\": 106,\r\n      \"stream\": 156\r\n    }],\r\n    51: [function (require, module, exports) {\r\n      (function (Buffer) {\r\n        // much of this based on https://github.com/indutny/self-signed/blob/gh-pages/lib/rsa.js\r\n        var createHmac = require('create-hmac')\r\n        var crt = require('browserify-rsa')\r\n        var EC = require('elliptic').ec\r\n        var BN = require('bn.js')\r\n        var parseKeys = require('parse-asn1')\r\n        var curves = require('./curves.json')\r\n\r\n        function sign(hash, key, hashType, signType, tag) {\r\n          var priv = parseKeys(key)\r\n          if (priv.curve) {\r\n            // rsa keys can be interpreted as ecdsa ones in openssl\r\n            if (signType !== 'ecdsa' && signType !== 'ecdsa/rsa') throw new Error('wrong private key type')\r\n            return ecSign(hash, priv)\r\n          } else if (priv.type === 'dsa') {\r\n            if (signType !== 'dsa') throw new Error('wrong private key type')\r\n            return dsaSign(hash, priv, hashType)\r\n          } else {\r\n            if (signType !== 'rsa' && signType !== 'ecdsa/rsa') throw new Error('wrong private key type')\r\n          }\r\n          hash = Buffer.concat([tag, hash])\r\n          var len = priv.modulus.byteLength()\r\n          var pad = [0, 1]\r\n          while (hash.length + pad.length + 1 < len) pad.push(0xff)\r\n          pad.push(0x00)\r\n          var i = -1\r\n          while (++i < hash.length) pad.push(hash[i])\r\n\r\n          var out = crt(pad, priv)\r\n          return out\r\n        }\r\n\r\n        function ecSign(hash, priv) {\r\n          var curveId = curves[priv.curve.join('.')]\r\n          if (!curveId) throw new Error('unknown curve ' + priv.curve.join('.'))\r\n\r\n          var curve = new EC(curveId)\r\n          var key = curve.keyFromPrivate(priv.privateKey)\r\n          var out = key.sign(hash)\r\n\r\n          return new Buffer(out.toDER())\r\n        }\r\n\r\n        function dsaSign(hash, priv, algo) {\r\n          var x = priv.params.priv_key\r\n          var p = priv.params.p\r\n          var q = priv.params.q\r\n          var g = priv.params.g\r\n          var r = new BN(0)\r\n          var k\r\n          var H = bits2int(hash, q).mod(q)\r\n          var s = false\r\n          var kv = getKey(x, q, hash, algo)\r\n          while (s === false) {\r\n            k = makeKey(q, kv, algo)\r\n            r = makeR(g, k, p, q)\r\n            s = k.invm(q).imul(H.add(x.mul(r))).mod(q)\r\n            if (s.cmpn(0) === 0) {\r\n              s = false\r\n              r = new BN(0)\r\n            }\r\n          }\r\n          return toDER(r, s)\r\n        }\r\n\r\n        function toDER(r, s) {\r\n          r = r.toArray()\r\n          s = s.toArray()\r\n\r\n          // Pad values\r\n          if (r[0] & 0x80) r = [0].concat(r)\r\n          if (s[0] & 0x80) s = [0].concat(s)\r\n\r\n          var total = r.length + s.length + 4\r\n          var res = [0x30, total, 0x02, r.length]\r\n          res = res.concat(r, [0x02, s.length], s)\r\n          return new Buffer(res)\r\n        }\r\n\r\n        function getKey(x, q, hash, algo) {\r\n          x = new Buffer(x.toArray())\r\n          if (x.length < q.byteLength()) {\r\n            var zeros = new Buffer(q.byteLength() - x.length)\r\n            zeros.fill(0)\r\n            x = Buffer.concat([zeros, x])\r\n          }\r\n          var hlen = hash.length\r\n          var hbits = bits2octets(hash, q)\r\n          var v = new Buffer(hlen)\r\n          v.fill(1)\r\n          var k = new Buffer(hlen)\r\n          k.fill(0)\r\n          k = createHmac(algo, k).update(v).update(new Buffer([0])).update(x).update(hbits).digest()\r\n          v = createHmac(algo, k).update(v).digest()\r\n          k = createHmac(algo, k).update(v).update(new Buffer([1])).update(x).update(hbits).digest()\r\n          v = createHmac(algo, k).update(v).digest()\r\n          return {\r\n            k: k,\r\n            v: v\r\n          }\r\n        }\r\n\r\n        function bits2int(obits, q) {\r\n          var bits = new BN(obits)\r\n          var shift = (obits.length << 3) - q.bitLength()\r\n          if (shift > 0) bits.ishrn(shift)\r\n          return bits\r\n        }\r\n\r\n        function bits2octets(bits, q) {\r\n          bits = bits2int(bits, q)\r\n          bits = bits.mod(q)\r\n          var out = new Buffer(bits.toArray())\r\n          if (out.length < q.byteLength()) {\r\n            var zeros = new Buffer(q.byteLength() - out.length)\r\n            zeros.fill(0)\r\n            out = Buffer.concat([zeros, out])\r\n          }\r\n          return out\r\n        }\r\n\r\n        function makeKey(q, kv, algo) {\r\n          var t\r\n          var k\r\n\r\n          do {\r\n            t = new Buffer(0)\r\n\r\n            while (t.length * 8 < q.bitLength()) {\r\n              kv.v = createHmac(algo, kv.k).update(kv.v).digest()\r\n              t = Buffer.concat([t, kv.v])\r\n            }\r\n\r\n            k = bits2int(t, q)\r\n            kv.k = createHmac(algo, kv.k).update(kv.v).update(new Buffer([0])).digest()\r\n            kv.v = createHmac(algo, kv.k).update(kv.v).digest()\r\n          } while (k.cmp(q) !== -1)\r\n\r\n          return k\r\n        }\r\n\r\n        function makeR(g, k, p, q) {\r\n          return g.toRed(BN.mont(p)).redPow(k).fromRed().mod(q)\r\n        }\r\n\r\n        module.exports = sign\r\n        module.exports.getKey = getKey\r\n        module.exports.makeKey = makeKey\r\n\r\n      }).call(this, require(\"buffer\").Buffer)\r\n    }, {\r\n      \"./curves.json\": 49,\r\n      \"bn.js\": 23,\r\n      \"browserify-rsa\": 46,\r\n      \"buffer\": 54,\r\n      \"create-hmac\": 60,\r\n      \"elliptic\": 73,\r\n      \"parse-asn1\": 117\r\n    }],\r\n    52: [function (require, module, exports) {\r\n      (function (Buffer) {\r\n        // much of this based on https://github.com/indutny/self-signed/blob/gh-pages/lib/rsa.js\r\n        var BN = require('bn.js')\r\n        var EC = require('elliptic').ec\r\n        var parseKeys = require('parse-asn1')\r\n        var curves = require('./curves.json')\r\n\r\n        function verify(sig, hash, key, signType, tag) {\r\n          var pub = parseKeys(key)\r\n          if (pub.type === 'ec') {\r\n            // rsa keys can be interpreted as ecdsa ones in openssl\r\n            if (signType !== 'ecdsa' && signType !== 'ecdsa/rsa') throw new Error('wrong public key type')\r\n            return ecVerify(sig, hash, pub)\r\n          } else if (pub.type === 'dsa') {\r\n            if (signType !== 'dsa') throw new Error('wrong public key type')\r\n            return dsaVerify(sig, hash, pub)\r\n          } else {\r\n            if (signType !== 'rsa' && signType !== 'ecdsa/rsa') throw new Error('wrong public key type')\r\n          }\r\n          hash = Buffer.concat([tag, hash])\r\n          var len = pub.modulus.byteLength()\r\n          var pad = [1]\r\n          var padNum = 0\r\n          while (hash.length + pad.length + 2 < len) {\r\n            pad.push(0xff)\r\n            padNum++\r\n          }\r\n          pad.push(0x00)\r\n          var i = -1\r\n          while (++i < hash.length) {\r\n            pad.push(hash[i])\r\n          }\r\n          pad = new Buffer(pad)\r\n          var red = BN.mont(pub.modulus)\r\n          sig = new BN(sig).toRed(red)\r\n\r\n          sig = sig.redPow(new BN(pub.publicExponent))\r\n          sig = new Buffer(sig.fromRed().toArray())\r\n          var out = padNum < 8 ? 1 : 0\r\n          len = Math.min(sig.length, pad.length)\r\n          if (sig.length !== pad.length) out = 1\r\n\r\n          i = -1\r\n          while (++i < len) out |= sig[i] ^ pad[i]\r\n          return out === 0\r\n        }\r\n\r\n        function ecVerify(sig, hash, pub) {\r\n          var curveId = curves[pub.data.algorithm.curve.join('.')]\r\n          if (!curveId) throw new Error('unknown curve ' + pub.data.algorithm.curve.join('.'))\r\n\r\n          var curve = new EC(curveId)\r\n          var pubkey = pub.data.subjectPrivateKey.data\r\n\r\n          return curve.verify(hash, sig, pubkey)\r\n        }\r\n\r\n        function dsaVerify(sig, hash, pub) {\r\n          var p = pub.data.p\r\n          var q = pub.data.q\r\n          var g = pub.data.g\r\n          var y = pub.data.pub_key\r\n          var unpacked = parseKeys.signature.decode(sig, 'der')\r\n          var s = unpacked.s\r\n          var r = unpacked.r\r\n          checkValue(s, q)\r\n          checkValue(r, q)\r\n          var montp = BN.mont(p)\r\n          var w = s.invm(q)\r\n          var v = g.toRed(montp)\r\n            .redPow(new BN(hash).mul(w).mod(q))\r\n            .fromRed()\r\n            .mul(y.toRed(montp).redPow(r.mul(w).mod(q)).fromRed())\r\n            .mod(p)\r\n            .mod(q)\r\n          return v.cmp(r) === 0\r\n        }\r\n\r\n        function checkValue(b, q) {\r\n          if (b.cmpn(0) <= 0) throw new Error('invalid sig')\r\n          if (b.cmp(q) >= q) throw new Error('invalid sig')\r\n        }\r\n\r\n        module.exports = verify\r\n\r\n      }).call(this, require(\"buffer\").Buffer)\r\n    }, {\r\n      \"./curves.json\": 49,\r\n      \"bn.js\": 23,\r\n      \"buffer\": 54,\r\n      \"elliptic\": 73,\r\n      \"parse-asn1\": 117\r\n    }],\r\n    53: [function (require, module, exports) {\r\n      (function (Buffer) {\r\n        module.exports = function xor(a, b) {\r\n          var length = Math.min(a.length, b.length)\r\n          var buffer = new Buffer(length)\r\n\r\n          for (var i = 0; i < length; ++i) {\r\n            buffer[i] = a[i] ^ b[i]\r\n          }\r\n\r\n          return buffer\r\n        }\r\n\r\n      }).call(this, require(\"buffer\").Buffer)\r\n    }, {\r\n      \"buffer\": 54\r\n    }],\r\n    54: [function (require, module, exports) {\r\n      /*!\r\n       * The buffer module from node.js, for the browser.\r\n       *\r\n       * @author   Feross Aboukhadijeh <https://feross.org>\r\n       * @license  MIT\r\n       */\r\n      /* eslint-disable no-proto */\r\n\r\n      'use strict'\r\n\r\n      var base64 = require('base64-js')\r\n      var ieee754 = require('ieee754')\r\n\r\n      exports.Buffer = Buffer\r\n      exports.SlowBuffer = SlowBuffer\r\n      exports.INSPECT_MAX_BYTES = 50\r\n\r\n      var K_MAX_LENGTH = 0x7fffffff\r\n      exports.kMaxLength = K_MAX_LENGTH\r\n\r\n      /**\r\n       * If `Buffer.TYPED_ARRAY_SUPPORT`:\r\n       *   === true    Use Uint8Array implementation (fastest)\r\n       *   === false   Print warning and recommend using `buffer` v4.x which has an Object\r\n       *               implementation (most compatible, even IE6)\r\n       *\r\n       * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,\r\n       * Opera 11.6+, iOS 4.2+.\r\n       *\r\n       * We report that the browser does not support typed arrays if the are not subclassable\r\n       * using __proto__. Firefox 4-29 lacks support for adding new properties to `Uint8Array`\r\n       * (See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438). IE 10 lacks support\r\n       * for __proto__ and has a buggy typed array implementation.\r\n       */\r\n      Buffer.TYPED_ARRAY_SUPPORT = typedArraySupport()\r\n\r\n      if (!Buffer.TYPED_ARRAY_SUPPORT && typeof console !== 'undefined' &&\r\n        typeof console.error === 'function') {\r\n        console.error(\r\n          'This browser lacks typed array (Uint8Array) support which is required by ' +\r\n          '`buffer` v5.x. Use `buffer` v4.x if you require old browser support.'\r\n        )\r\n      }\r\n\r\n      function typedArraySupport() {\r\n        // Can typed array instances can be augmented?\r\n        try {\r\n          var arr = new Uint8Array(1)\r\n          arr.__proto__ = {\r\n            __proto__: Uint8Array.prototype,\r\n            foo: function () {\r\n              return 42\r\n            }\r\n          }\r\n          return arr.foo() === 42\r\n        } catch (e) {\r\n          return false\r\n        }\r\n      }\r\n\r\n      Object.defineProperty(Buffer.prototype, 'parent', {\r\n        enumerable: true,\r\n        get: function () {\r\n          if (!Buffer.isBuffer(this)) return undefined\r\n          return this.buffer\r\n        }\r\n      })\r\n\r\n      Object.defineProperty(Buffer.prototype, 'offset', {\r\n        enumerable: true,\r\n        get: function () {\r\n          if (!Buffer.isBuffer(this)) return undefined\r\n          return this.byteOffset\r\n        }\r\n      })\r\n\r\n      function createBuffer(length) {\r\n        if (length > K_MAX_LENGTH) {\r\n          throw new RangeError('The value \"' + length + '\" is invalid for option \"size\"')\r\n        }\r\n        // Return an augmented `Uint8Array` instance\r\n        var buf = new Uint8Array(length)\r\n        buf.__proto__ = Buffer.prototype\r\n        return buf\r\n      }\r\n\r\n      /**\r\n       * The Buffer constructor returns instances of `Uint8Array` that have their\r\n       * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of\r\n       * `Uint8Array`, so the returned instances will have all the node `Buffer` methods\r\n       * and the `Uint8Array` methods. Square bracket notation works as expected -- it\r\n       * returns a single octet.\r\n       *\r\n       * The `Uint8Array` prototype remains unmodified.\r\n       */\r\n\r\n      function Buffer(arg, encodingOrOffset, length) {\r\n        // Common case.\r\n        if (typeof arg === 'number') {\r\n          if (typeof encodingOrOffset === 'string') {\r\n            throw new TypeError(\r\n              'The \"string\" argument must be of type string. Received type number'\r\n            )\r\n          }\r\n          return allocUnsafe(arg)\r\n        }\r\n        return from(arg, encodingOrOffset, length)\r\n      }\r\n\r\n      // Fix subarray() in ES2016. See: https://github.com/feross/buffer/pull/97\r\n      if (typeof Symbol !== 'undefined' && Symbol.species != null &&\r\n        Buffer[Symbol.species] === Buffer) {\r\n        Object.defineProperty(Buffer, Symbol.species, {\r\n          value: null,\r\n          configurable: true,\r\n          enumerable: false,\r\n          writable: false\r\n        })\r\n      }\r\n\r\n      Buffer.poolSize = 8192 // not used by this implementation\r\n\r\n      function from(value, encodingOrOffset, length) {\r\n        if (typeof value === 'string') {\r\n          return fromString(value, encodingOrOffset)\r\n        }\r\n\r\n        if (ArrayBuffer.isView(value)) {\r\n          return fromArrayLike(value)\r\n        }\r\n\r\n        if (value == null) {\r\n          throw TypeError(\r\n            'The first argument must be one of type string, Buffer, ArrayBuffer, Array, ' +\r\n            'or Array-like Object. Received type ' + (typeof value)\r\n          )\r\n        }\r\n\r\n        if (isInstance(value, ArrayBuffer) ||\r\n          (value && isInstance(value.buffer, ArrayBuffer))) {\r\n          return fromArrayBuffer(value, encodingOrOffset, length)\r\n        }\r\n\r\n        if (typeof value === 'number') {\r\n          throw new TypeError(\r\n            'The \"value\" argument must not be of type number. Received type number'\r\n          )\r\n        }\r\n\r\n        var valueOf = value.valueOf && value.valueOf()\r\n        if (valueOf != null && valueOf !== value) {\r\n          return Buffer.from(valueOf, encodingOrOffset, length)\r\n        }\r\n\r\n        var b = fromObject(value)\r\n        if (b) return b\r\n\r\n        if (typeof Symbol !== 'undefined' && Symbol.toPrimitive != null &&\r\n          typeof value[Symbol.toPrimitive] === 'function') {\r\n          return Buffer.from(\r\n            value[Symbol.toPrimitive]('string'), encodingOrOffset, length\r\n          )\r\n        }\r\n\r\n        throw new TypeError(\r\n          'The first argument must be one of type string, Buffer, ArrayBuffer, Array, ' +\r\n          'or Array-like Object. Received type ' + (typeof value)\r\n        )\r\n      }\r\n\r\n      /**\r\n       * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError\r\n       * if value is a number.\r\n       * Buffer.from(str[, encoding])\r\n       * Buffer.from(array)\r\n       * Buffer.from(buffer)\r\n       * Buffer.from(arrayBuffer[, byteOffset[, length]])\r\n       **/\r\n      Buffer.from = function (value, encodingOrOffset, length) {\r\n        return from(value, encodingOrOffset, length)\r\n      }\r\n\r\n      // Note: Change prototype *after* Buffer.from is defined to workaround Chrome bug:\r\n      // https://github.com/feross/buffer/pull/148\r\n      Buffer.prototype.__proto__ = Uint8Array.prototype\r\n      Buffer.__proto__ = Uint8Array\r\n\r\n      function assertSize(size) {\r\n        if (typeof size !== 'number') {\r\n          throw new TypeError('\"size\" argument must be of type number')\r\n        } else if (size < 0) {\r\n          throw new RangeError('The value \"' + size + '\" is invalid for option \"size\"')\r\n        }\r\n      }\r\n\r\n      function alloc(size, fill, encoding) {\r\n        assertSize(size)\r\n        if (size <= 0) {\r\n          return createBuffer(size)\r\n        }\r\n        if (fill !== undefined) {\r\n          // Only pay attention to encoding if it's a string. This\r\n          // prevents accidentally sending in a number that would\r\n          // be interpretted as a start offset.\r\n          return typeof encoding === 'string' ?\r\n            createBuffer(size).fill(fill, encoding) :\r\n            createBuffer(size).fill(fill)\r\n        }\r\n        return createBuffer(size)\r\n      }\r\n\r\n      /**\r\n       * Creates a new filled Buffer instance.\r\n       * alloc(size[, fill[, encoding]])\r\n       **/\r\n      Buffer.alloc = function (size, fill, encoding) {\r\n        return alloc(size, fill, encoding)\r\n      }\r\n\r\n      function allocUnsafe(size) {\r\n        assertSize(size)\r\n        return createBuffer(size < 0 ? 0 : checked(size) | 0)\r\n      }\r\n\r\n      /**\r\n       * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.\r\n       * */\r\n      Buffer.allocUnsafe = function (size) {\r\n        return allocUnsafe(size)\r\n      }\r\n      /**\r\n       * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.\r\n       */\r\n      Buffer.allocUnsafeSlow = function (size) {\r\n        return allocUnsafe(size)\r\n      }\r\n\r\n      function fromString(string, encoding) {\r\n        if (typeof encoding !== 'string' || encoding === '') {\r\n          encoding = 'utf8'\r\n        }\r\n\r\n        if (!Buffer.isEncoding(encoding)) {\r\n          throw new TypeError('Unknown encoding: ' + encoding)\r\n        }\r\n\r\n        var length = byteLength(string, encoding) | 0\r\n        var buf = createBuffer(length)\r\n\r\n        var actual = buf.write(string, encoding)\r\n\r\n        if (actual !== length) {\r\n          // Writing a hex string, for example, that contains invalid characters will\r\n          // cause everything after the first invalid character to be ignored. (e.g.\r\n          // 'abxxcd' will be treated as 'ab')\r\n          buf = buf.slice(0, actual)\r\n        }\r\n\r\n        return buf\r\n      }\r\n\r\n      function fromArrayLike(array) {\r\n        var length = array.length < 0 ? 0 : checked(array.length) | 0\r\n        var buf = createBuffer(length)\r\n        for (var i = 0; i < length; i += 1) {\r\n          buf[i] = array[i] & 255\r\n        }\r\n        return buf\r\n      }\r\n\r\n      function fromArrayBuffer(array, byteOffset, length) {\r\n        if (byteOffset < 0 || array.byteLength < byteOffset) {\r\n          throw new RangeError('\"offset\" is outside of buffer bounds')\r\n        }\r\n\r\n        if (array.byteLength < byteOffset + (length || 0)) {\r\n          throw new RangeError('\"length\" is outside of buffer bounds')\r\n        }\r\n\r\n        var buf\r\n        if (byteOffset === undefined && length === undefined) {\r\n          buf = new Uint8Array(array)\r\n        } else if (length === undefined) {\r\n          buf = new Uint8Array(array, byteOffset)\r\n        } else {\r\n          buf = new Uint8Array(array, byteOffset, length)\r\n        }\r\n\r\n        // Return an augmented `Uint8Array` instance\r\n        buf.__proto__ = Buffer.prototype\r\n        return buf\r\n      }\r\n\r\n      function fromObject(obj) {\r\n        if (Buffer.isBuffer(obj)) {\r\n          var len = checked(obj.length) | 0\r\n          var buf = createBuffer(len)\r\n\r\n          if (buf.length === 0) {\r\n            return buf\r\n          }\r\n\r\n          obj.copy(buf, 0, 0, len)\r\n          return buf\r\n        }\r\n\r\n        if (obj.length !== undefined) {\r\n          if (typeof obj.length !== 'number' || numberIsNaN(obj.length)) {\r\n            return createBuffer(0)\r\n          }\r\n          return fromArrayLike(obj)\r\n        }\r\n\r\n        if (obj.type === 'Buffer' && Array.isArray(obj.data)) {\r\n          return fromArrayLike(obj.data)\r\n        }\r\n      }\r\n\r\n      function checked(length) {\r\n        // Note: cannot use `length < K_MAX_LENGTH` here because that fails when\r\n        // length is NaN (which is otherwise coerced to zero.)\r\n        if (length >= K_MAX_LENGTH) {\r\n          throw new RangeError('Attempt to allocate Buffer larger than maximum ' +\r\n            'size: 0x' + K_MAX_LENGTH.toString(16) + ' bytes')\r\n        }\r\n        return length | 0\r\n      }\r\n\r\n      function SlowBuffer(length) {\r\n        if (+length != length) { // eslint-disable-line eqeqeq\r\n          length = 0\r\n        }\r\n        return Buffer.alloc(+length)\r\n      }\r\n\r\n      Buffer.isBuffer = function isBuffer(b) {\r\n        return b != null && b._isBuffer === true &&\r\n          b !== Buffer.prototype // so Buffer.isBuffer(Buffer.prototype) will be false\r\n      }\r\n\r\n      Buffer.compare = function compare(a, b) {\r\n        if (isInstance(a, Uint8Array)) a = Buffer.from(a, a.offset, a.byteLength)\r\n        if (isInstance(b, Uint8Array)) b = Buffer.from(b, b.offset, b.byteLength)\r\n        if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {\r\n          throw new TypeError(\r\n            'The \"buf1\", \"buf2\" arguments must be one of type Buffer or Uint8Array'\r\n          )\r\n        }\r\n\r\n        if (a === b) return 0\r\n\r\n        var x = a.length\r\n        var y = b.length\r\n\r\n        for (var i = 0, len = Math.min(x, y); i < len; ++i) {\r\n          if (a[i] !== b[i]) {\r\n            x = a[i]\r\n            y = b[i]\r\n            break\r\n          }\r\n        }\r\n\r\n        if (x < y) return -1\r\n        if (y < x) return 1\r\n        return 0\r\n      }\r\n\r\n      Buffer.isEncoding = function isEncoding(encoding) {\r\n        switch (String(encoding).toLowerCase()) {\r\n          case 'hex':\r\n          case 'utf8':\r\n          case 'utf-8':\r\n          case 'ascii':\r\n          case 'latin1':\r\n          case 'binary':\r\n          case 'base64':\r\n          case 'ucs2':\r\n          case 'ucs-2':\r\n          case 'utf16le':\r\n          case 'utf-16le':\r\n            return true\r\n          default:\r\n            return false\r\n        }\r\n      }\r\n\r\n      Buffer.concat = function concat(list, length) {\r\n        if (!Array.isArray(list)) {\r\n          throw new TypeError('\"list\" argument must be an Array of Buffers')\r\n        }\r\n\r\n        if (list.length === 0) {\r\n          return Buffer.alloc(0)\r\n        }\r\n\r\n        var i\r\n        if (length === undefined) {\r\n          length = 0\r\n          for (i = 0; i < list.length; ++i) {\r\n            length += list[i].length\r\n          }\r\n        }\r\n\r\n        var buffer = Buffer.allocUnsafe(length)\r\n        var pos = 0\r\n        for (i = 0; i < list.length; ++i) {\r\n          var buf = list[i]\r\n          if (isInstance(buf, Uint8Array)) {\r\n            buf = Buffer.from(buf)\r\n          }\r\n          if (!Buffer.isBuffer(buf)) {\r\n            throw new TypeError('\"list\" argument must be an Array of Buffers')\r\n          }\r\n          buf.copy(buffer, pos)\r\n          pos += buf.length\r\n        }\r\n        return buffer\r\n      }\r\n\r\n      function byteLength(string, encoding) {\r\n        if (Buffer.isBuffer(string)) {\r\n          return string.length\r\n        }\r\n        if (ArrayBuffer.isView(string) || isInstance(string, ArrayBuffer)) {\r\n          return string.byteLength\r\n        }\r\n        if (typeof string !== 'string') {\r\n          throw new TypeError(\r\n            'The \"string\" argument must be one of type string, Buffer, or ArrayBuffer. ' +\r\n            'Received type ' + typeof string\r\n          )\r\n        }\r\n\r\n        var len = string.length\r\n        var mustMatch = (arguments.length > 2 && arguments[2] === true)\r\n        if (!mustMatch && len === 0) return 0\r\n\r\n        // Use a for loop to avoid recursion\r\n        var loweredCase = false\r\n        for (;;) {\r\n          switch (encoding) {\r\n            case 'ascii':\r\n            case 'latin1':\r\n            case 'binary':\r\n              return len\r\n            case 'utf8':\r\n            case 'utf-8':\r\n              return utf8ToBytes(string).length\r\n            case 'ucs2':\r\n            case 'ucs-2':\r\n            case 'utf16le':\r\n            case 'utf-16le':\r\n              return len * 2\r\n            case 'hex':\r\n              return len >>> 1\r\n            case 'base64':\r\n              return base64ToBytes(string).length\r\n            default:\r\n              if (loweredCase) {\r\n                return mustMatch ? -1 : utf8ToBytes(string).length // assume utf8\r\n              }\r\n              encoding = ('' + encoding).toLowerCase()\r\n              loweredCase = true\r\n          }\r\n        }\r\n      }\r\n      Buffer.byteLength = byteLength\r\n\r\n      function slowToString(encoding, start, end) {\r\n        var loweredCase = false\r\n\r\n        // No need to verify that \"this.length <= MAX_UINT32\" since it's a read-only\r\n        // property of a typed array.\r\n\r\n        // This behaves neither like String nor Uint8Array in that we set start/end\r\n        // to their upper/lower bounds if the value passed is out of range.\r\n        // undefined is handled specially as per ECMA-262 6th Edition,\r\n        // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.\r\n        if (start === undefined || start < 0) {\r\n          start = 0\r\n        }\r\n        // Return early if start > this.length. Done here to prevent potential uint32\r\n        // coercion fail below.\r\n        if (start > this.length) {\r\n          return ''\r\n        }\r\n\r\n        if (end === undefined || end > this.length) {\r\n          end = this.length\r\n        }\r\n\r\n        if (end <= 0) {\r\n          return ''\r\n        }\r\n\r\n        // Force coersion to uint32. This will also coerce falsey/NaN values to 0.\r\n        end >>>= 0\r\n        start >>>= 0\r\n\r\n        if (end <= start) {\r\n          return ''\r\n        }\r\n\r\n        if (!encoding) encoding = 'utf8'\r\n\r\n        while (true) {\r\n          switch (encoding) {\r\n            case 'hex':\r\n              return hexSlice(this, start, end)\r\n\r\n            case 'utf8':\r\n            case 'utf-8':\r\n              return utf8Slice(this, start, end)\r\n\r\n            case 'ascii':\r\n              return asciiSlice(this, start, end)\r\n\r\n            case 'latin1':\r\n            case 'binary':\r\n              return latin1Slice(this, start, end)\r\n\r\n            case 'base64':\r\n              return base64Slice(this, start, end)\r\n\r\n            case 'ucs2':\r\n            case 'ucs-2':\r\n            case 'utf16le':\r\n            case 'utf-16le':\r\n              return utf16leSlice(this, start, end)\r\n\r\n            default:\r\n              if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)\r\n              encoding = (encoding + '').toLowerCase()\r\n              loweredCase = true\r\n          }\r\n        }\r\n      }\r\n\r\n      // This property is used by `Buffer.isBuffer` (and the `is-buffer` npm package)\r\n      // to detect a Buffer instance. It's not possible to use `instanceof Buffer`\r\n      // reliably in a browserify context because there could be multiple different\r\n      // copies of the 'buffer' package in use. This method works even for Buffer\r\n      // instances that were created from another copy of the `buffer` package.\r\n      // See: https://github.com/feross/buffer/issues/154\r\n      Buffer.prototype._isBuffer = true\r\n\r\n      function swap(b, n, m) {\r\n        var i = b[n]\r\n        b[n] = b[m]\r\n        b[m] = i\r\n      }\r\n\r\n      Buffer.prototype.swap16 = function swap16() {\r\n        var len = this.length\r\n        if (len % 2 !== 0) {\r\n          throw new RangeError('Buffer size must be a multiple of 16-bits')\r\n        }\r\n        for (var i = 0; i < len; i += 2) {\r\n          swap(this, i, i + 1)\r\n        }\r\n        return this\r\n      }\r\n\r\n      Buffer.prototype.swap32 = function swap32() {\r\n        var len = this.length\r\n        if (len % 4 !== 0) {\r\n          throw new RangeError('Buffer size must be a multiple of 32-bits')\r\n        }\r\n        for (var i = 0; i < len; i += 4) {\r\n          swap(this, i, i + 3)\r\n          swap(this, i + 1, i + 2)\r\n        }\r\n        return this\r\n      }\r\n\r\n      Buffer.prototype.swap64 = function swap64() {\r\n        var len = this.length\r\n        if (len % 8 !== 0) {\r\n          throw new RangeError('Buffer size must be a multiple of 64-bits')\r\n        }\r\n        for (var i = 0; i < len; i += 8) {\r\n          swap(this, i, i + 7)\r\n          swap(this, i + 1, i + 6)\r\n          swap(this, i + 2, i + 5)\r\n          swap(this, i + 3, i + 4)\r\n        }\r\n        return this\r\n      }\r\n\r\n      Buffer.prototype.toString = function toString() {\r\n        var length = this.length\r\n        if (length === 0) return ''\r\n        if (arguments.length === 0) return utf8Slice(this, 0, length)\r\n        return slowToString.apply(this, arguments)\r\n      }\r\n\r\n      Buffer.prototype.toLocaleString = Buffer.prototype.toString\r\n\r\n      Buffer.prototype.equals = function equals(b) {\r\n        if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')\r\n        if (this === b) return true\r\n        return Buffer.compare(this, b) === 0\r\n      }\r\n\r\n      Buffer.prototype.inspect = function inspect() {\r\n        var str = ''\r\n        var max = exports.INSPECT_MAX_BYTES\r\n        str = this.toString('hex', 0, max).replace(/(.{2})/g, '$1 ').trim()\r\n        if (this.length > max) str += ' ... '\r\n        return '<Buffer ' + str + '>'\r\n      }\r\n\r\n      Buffer.prototype.compare = function compare(target, start, end, thisStart, thisEnd) {\r\n        if (isInstance(target, Uint8Array)) {\r\n          target = Buffer.from(target, target.offset, target.byteLength)\r\n        }\r\n        if (!Buffer.isBuffer(target)) {\r\n          throw new TypeError(\r\n            'The \"target\" argument must be one of type Buffer or Uint8Array. ' +\r\n            'Received type ' + (typeof target)\r\n          )\r\n        }\r\n\r\n        if (start === undefined) {\r\n          start = 0\r\n        }\r\n        if (end === undefined) {\r\n          end = target ? target.length : 0\r\n        }\r\n        if (thisStart === undefined) {\r\n          thisStart = 0\r\n        }\r\n        if (thisEnd === undefined) {\r\n          thisEnd = this.length\r\n        }\r\n\r\n        if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {\r\n          throw new RangeError('out of range index')\r\n        }\r\n\r\n        if (thisStart >= thisEnd && start >= end) {\r\n          return 0\r\n        }\r\n        if (thisStart >= thisEnd) {\r\n          return -1\r\n        }\r\n        if (start >= end) {\r\n          return 1\r\n        }\r\n\r\n        start >>>= 0\r\n        end >>>= 0\r\n        thisStart >>>= 0\r\n        thisEnd >>>= 0\r\n\r\n        if (this === target) return 0\r\n\r\n        var x = thisEnd - thisStart\r\n        var y = end - start\r\n        var len = Math.min(x, y)\r\n\r\n        var thisCopy = this.slice(thisStart, thisEnd)\r\n        var targetCopy = target.slice(start, end)\r\n\r\n        for (var i = 0; i < len; ++i) {\r\n          if (thisCopy[i] !== targetCopy[i]) {\r\n            x = thisCopy[i]\r\n            y = targetCopy[i]\r\n            break\r\n          }\r\n        }\r\n\r\n        if (x < y) return -1\r\n        if (y < x) return 1\r\n        return 0\r\n      }\r\n\r\n      // Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,\r\n      // OR the last index of `val` in `buffer` at offset <= `byteOffset`.\r\n      //\r\n      // Arguments:\r\n      // - buffer - a Buffer to search\r\n      // - val - a string, Buffer, or number\r\n      // - byteOffset - an index into `buffer`; will be clamped to an int32\r\n      // - encoding - an optional encoding, relevant is val is a string\r\n      // - dir - true for indexOf, false for lastIndexOf\r\n      function bidirectionalIndexOf(buffer, val, byteOffset, encoding, dir) {\r\n        // Empty buffer means no match\r\n        if (buffer.length === 0) return -1\r\n\r\n        // Normalize byteOffset\r\n        if (typeof byteOffset === 'string') {\r\n          encoding = byteOffset\r\n          byteOffset = 0\r\n        } else if (byteOffset > 0x7fffffff) {\r\n          byteOffset = 0x7fffffff\r\n        } else if (byteOffset < -0x80000000) {\r\n          byteOffset = -0x80000000\r\n        }\r\n        byteOffset = +byteOffset // Coerce to Number.\r\n        if (numberIsNaN(byteOffset)) {\r\n          // byteOffset: it it's undefined, null, NaN, \"foo\", etc, search whole buffer\r\n          byteOffset = dir ? 0 : (buffer.length - 1)\r\n        }\r\n\r\n        // Normalize byteOffset: negative offsets start from the end of the buffer\r\n        if (byteOffset < 0) byteOffset = buffer.length + byteOffset\r\n        if (byteOffset >= buffer.length) {\r\n          if (dir) return -1\r\n          else byteOffset = buffer.length - 1\r\n        } else if (byteOffset < 0) {\r\n          if (dir) byteOffset = 0\r\n          else return -1\r\n        }\r\n\r\n        // Normalize val\r\n        if (typeof val === 'string') {\r\n          val = Buffer.from(val, encoding)\r\n        }\r\n\r\n        // Finally, search either indexOf (if dir is true) or lastIndexOf\r\n        if (Buffer.isBuffer(val)) {\r\n          // Special case: looking for empty string/buffer always fails\r\n          if (val.length === 0) {\r\n            return -1\r\n          }\r\n          return arrayIndexOf(buffer, val, byteOffset, encoding, dir)\r\n        } else if (typeof val === 'number') {\r\n          val = val & 0xFF // Search for a byte value [0-255]\r\n          if (typeof Uint8Array.prototype.indexOf === 'function') {\r\n            if (dir) {\r\n              return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset)\r\n            } else {\r\n              return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)\r\n            }\r\n          }\r\n          return arrayIndexOf(buffer, [val], byteOffset, encoding, dir)\r\n        }\r\n\r\n        throw new TypeError('val must be string, number or Buffer')\r\n      }\r\n\r\n      function arrayIndexOf(arr, val, byteOffset, encoding, dir) {\r\n        var indexSize = 1\r\n        var arrLength = arr.length\r\n        var valLength = val.length\r\n\r\n        if (encoding !== undefined) {\r\n          encoding = String(encoding).toLowerCase()\r\n          if (encoding === 'ucs2' || encoding === 'ucs-2' ||\r\n            encoding === 'utf16le' || encoding === 'utf-16le') {\r\n            if (arr.length < 2 || val.length < 2) {\r\n              return -1\r\n            }\r\n            indexSize = 2\r\n            arrLength /= 2\r\n            valLength /= 2\r\n            byteOffset /= 2\r\n          }\r\n        }\r\n\r\n        function read(buf, i) {\r\n          if (indexSize === 1) {\r\n            return buf[i]\r\n          } else {\r\n            return buf.readUInt16BE(i * indexSize)\r\n          }\r\n        }\r\n\r\n        var i\r\n        if (dir) {\r\n          var foundIndex = -1\r\n          for (i = byteOffset; i < arrLength; i++) {\r\n            if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {\r\n              if (foundIndex === -1) foundIndex = i\r\n              if (i - foundIndex + 1 === valLength) return foundIndex * indexSize\r\n            } else {\r\n              if (foundIndex !== -1) i -= i - foundIndex\r\n              foundIndex = -1\r\n            }\r\n          }\r\n        } else {\r\n          if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength\r\n          for (i = byteOffset; i >= 0; i--) {\r\n            var found = true\r\n            for (var j = 0; j < valLength; j++) {\r\n              if (read(arr, i + j) !== read(val, j)) {\r\n                found = false\r\n                break\r\n              }\r\n            }\r\n            if (found) return i\r\n          }\r\n        }\r\n\r\n        return -1\r\n      }\r\n\r\n      Buffer.prototype.includes = function includes(val, byteOffset, encoding) {\r\n        return this.indexOf(val, byteOffset, encoding) !== -1\r\n      }\r\n\r\n      Buffer.prototype.indexOf = function indexOf(val, byteOffset, encoding) {\r\n        return bidirectionalIndexOf(this, val, byteOffset, encoding, true)\r\n      }\r\n\r\n      Buffer.prototype.lastIndexOf = function lastIndexOf(val, byteOffset, encoding) {\r\n        return bidirectionalIndexOf(this, val, byteOffset, encoding, false)\r\n      }\r\n\r\n      function hexWrite(buf, string, offset, length) {\r\n        offset = Number(offset) || 0\r\n        var remaining = buf.length - offset\r\n        if (!length) {\r\n          length = remaining\r\n        } else {\r\n          length = Number(length)\r\n          if (length > remaining) {\r\n            length = remaining\r\n          }\r\n        }\r\n\r\n        var strLen = string.length\r\n\r\n        if (length > strLen / 2) {\r\n          length = strLen / 2\r\n        }\r\n        for (var i = 0; i < length; ++i) {\r\n          var parsed = parseInt(string.substr(i * 2, 2), 16)\r\n          if (numberIsNaN(parsed)) return i\r\n          buf[offset + i] = parsed\r\n        }\r\n        return i\r\n      }\r\n\r\n      function utf8Write(buf, string, offset, length) {\r\n        return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)\r\n      }\r\n\r\n      function asciiWrite(buf, string, offset, length) {\r\n        return blitBuffer(asciiToBytes(string), buf, offset, length)\r\n      }\r\n\r\n      function latin1Write(buf, string, offset, length) {\r\n        return asciiWrite(buf, string, offset, length)\r\n      }\r\n\r\n      function base64Write(buf, string, offset, length) {\r\n        return blitBuffer(base64ToBytes(string), buf, offset, length)\r\n      }\r\n\r\n      function ucs2Write(buf, string, offset, length) {\r\n        return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)\r\n      }\r\n\r\n      Buffer.prototype.write = function write(string, offset, length, encoding) {\r\n        // Buffer#write(string)\r\n        if (offset === undefined) {\r\n          encoding = 'utf8'\r\n          length = this.length\r\n          offset = 0\r\n          // Buffer#write(string, encoding)\r\n        } else if (length === undefined && typeof offset === 'string') {\r\n          encoding = offset\r\n          length = this.length\r\n          offset = 0\r\n          // Buffer#write(string, offset[, length][, encoding])\r\n        } else if (isFinite(offset)) {\r\n          offset = offset >>> 0\r\n          if (isFinite(length)) {\r\n            length = length >>> 0\r\n            if (encoding === undefined) encoding = 'utf8'\r\n          } else {\r\n            encoding = length\r\n            length = undefined\r\n          }\r\n        } else {\r\n          throw new Error(\r\n            'Buffer.write(string, encoding, offset[, length]) is no longer supported'\r\n          )\r\n        }\r\n\r\n        var remaining = this.length - offset\r\n        if (length === undefined || length > remaining) length = remaining\r\n\r\n        if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {\r\n          throw new RangeError('Attempt to write outside buffer bounds')\r\n        }\r\n\r\n        if (!encoding) encoding = 'utf8'\r\n\r\n        var loweredCase = false\r\n        for (;;) {\r\n          switch (encoding) {\r\n            case 'hex':\r\n              return hexWrite(this, string, offset, length)\r\n\r\n            case 'utf8':\r\n            case 'utf-8':\r\n              return utf8Write(this, string, offset, length)\r\n\r\n            case 'ascii':\r\n              return asciiWrite(this, string, offset, length)\r\n\r\n            case 'latin1':\r\n            case 'binary':\r\n              return latin1Write(this, string, offset, length)\r\n\r\n            case 'base64':\r\n              // Warning: maxLength not taken into account in base64Write\r\n              return base64Write(this, string, offset, length)\r\n\r\n            case 'ucs2':\r\n            case 'ucs-2':\r\n            case 'utf16le':\r\n            case 'utf-16le':\r\n              return ucs2Write(this, string, offset, length)\r\n\r\n            default:\r\n              if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)\r\n              encoding = ('' + encoding).toLowerCase()\r\n              loweredCase = true\r\n          }\r\n        }\r\n      }\r\n\r\n      Buffer.prototype.toJSON = function toJSON() {\r\n        return {\r\n          type: 'Buffer',\r\n          data: Array.prototype.slice.call(this._arr || this, 0)\r\n        }\r\n      }\r\n\r\n      function base64Slice(buf, start, end) {\r\n        if (start === 0 && end === buf.length) {\r\n          return base64.fromByteArray(buf)\r\n        } else {\r\n          return base64.fromByteArray(buf.slice(start, end))\r\n        }\r\n      }\r\n\r\n      function utf8Slice(buf, start, end) {\r\n        end = Math.min(buf.length, end)\r\n        var res = []\r\n\r\n        var i = start\r\n        while (i < end) {\r\n          var firstByte = buf[i]\r\n          var codePoint = null\r\n          var bytesPerSequence = (firstByte > 0xEF) ? 4 :\r\n            (firstByte > 0xDF) ? 3 :\r\n            (firstByte > 0xBF) ? 2 :\r\n            1\r\n\r\n          if (i + bytesPerSequence <= end) {\r\n            var secondByte, thirdByte, fourthByte, tempCodePoint\r\n\r\n            switch (bytesPerSequence) {\r\n              case 1:\r\n                if (firstByte < 0x80) {\r\n                  codePoint = firstByte\r\n                }\r\n                break\r\n              case 2:\r\n                secondByte = buf[i + 1]\r\n                if ((secondByte & 0xC0) === 0x80) {\r\n                  tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)\r\n                  if (tempCodePoint > 0x7F) {\r\n                    codePoint = tempCodePoint\r\n                  }\r\n                }\r\n                break\r\n              case 3:\r\n                secondByte = buf[i + 1]\r\n                thirdByte = buf[i + 2]\r\n                if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {\r\n                  tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)\r\n                  if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {\r\n                    codePoint = tempCodePoint\r\n                  }\r\n                }\r\n                break\r\n              case 4:\r\n                secondByte = buf[i + 1]\r\n                thirdByte = buf[i + 2]\r\n                fourthByte = buf[i + 3]\r\n                if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {\r\n                  tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)\r\n                  if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {\r\n                    codePoint = tempCodePoint\r\n                  }\r\n                }\r\n            }\r\n          }\r\n\r\n          if (codePoint === null) {\r\n            // we did not generate a valid codePoint so insert a\r\n            // replacement char (U+FFFD) and advance only 1 byte\r\n            codePoint = 0xFFFD\r\n            bytesPerSequence = 1\r\n          } else if (codePoint > 0xFFFF) {\r\n            // encode to utf16 (surrogate pair dance)\r\n            codePoint -= 0x10000\r\n            res.push(codePoint >>> 10 & 0x3FF | 0xD800)\r\n            codePoint = 0xDC00 | codePoint & 0x3FF\r\n          }\r\n\r\n          res.push(codePoint)\r\n          i += bytesPerSequence\r\n        }\r\n\r\n        return decodeCodePointsArray(res)\r\n      }\r\n\r\n      // Based on http://stackoverflow.com/a/22747272/680742, the browser with\r\n      // the lowest limit is Chrome, with 0x10000 args.\r\n      // We go 1 magnitude less, for safety\r\n      var MAX_ARGUMENTS_LENGTH = 0x1000\r\n\r\n      function decodeCodePointsArray(codePoints) {\r\n        var len = codePoints.length\r\n        if (len <= MAX_ARGUMENTS_LENGTH) {\r\n          return String.fromCharCode.apply(String, codePoints) // avoid extra slice()\r\n        }\r\n\r\n        // Decode in chunks to avoid \"call stack size exceeded\".\r\n        var res = ''\r\n        var i = 0\r\n        while (i < len) {\r\n          res += String.fromCharCode.apply(\r\n            String,\r\n            codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)\r\n          )\r\n        }\r\n        return res\r\n      }\r\n\r\n      function asciiSlice(buf, start, end) {\r\n        var ret = ''\r\n        end = Math.min(buf.length, end)\r\n\r\n        for (var i = start; i < end; ++i) {\r\n          ret += String.fromCharCode(buf[i] & 0x7F)\r\n        }\r\n        return ret\r\n      }\r\n\r\n      function latin1Slice(buf, start, end) {\r\n        var ret = ''\r\n        end = Math.min(buf.length, end)\r\n\r\n        for (var i = start; i < end; ++i) {\r\n          ret += String.fromCharCode(buf[i])\r\n        }\r\n        return ret\r\n      }\r\n\r\n      function hexSlice(buf, start, end) {\r\n        var len = buf.length\r\n\r\n        if (!start || start < 0) start = 0\r\n        if (!end || end < 0 || end > len) end = len\r\n\r\n        var out = ''\r\n        for (var i = start; i < end; ++i) {\r\n          out += toHex(buf[i])\r\n        }\r\n        return out\r\n      }\r\n\r\n      function utf16leSlice(buf, start, end) {\r\n        var bytes = buf.slice(start, end)\r\n        var res = ''\r\n        for (var i = 0; i < bytes.length; i += 2) {\r\n          res += String.fromCharCode(bytes[i] + (bytes[i + 1] * 256))\r\n        }\r\n        return res\r\n      }\r\n\r\n      Buffer.prototype.slice = function slice(start, end) {\r\n        var len = this.length\r\n        start = ~~start\r\n        end = end === undefined ? len : ~~end\r\n\r\n        if (start < 0) {\r\n          start += len\r\n          if (start < 0) start = 0\r\n        } else if (start > len) {\r\n          start = len\r\n        }\r\n\r\n        if (end < 0) {\r\n          end += len\r\n          if (end < 0) end = 0\r\n        } else if (end > len) {\r\n          end = len\r\n        }\r\n\r\n        if (end < start) end = start\r\n\r\n        var newBuf = this.subarray(start, end)\r\n        // Return an augmented `Uint8Array` instance\r\n        newBuf.__proto__ = Buffer.prototype\r\n        return newBuf\r\n      }\r\n\r\n      /*\r\n       * Need to make sure that buffer isn't trying to write out of bounds.\r\n       */\r\n      function checkOffset(offset, ext, length) {\r\n        if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')\r\n        if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')\r\n      }\r\n\r\n      Buffer.prototype.readUIntLE = function readUIntLE(offset, byteLength, noAssert) {\r\n        offset = offset >>> 0\r\n        byteLength = byteLength >>> 0\r\n        if (!noAssert) checkOffset(offset, byteLength, this.length)\r\n\r\n        var val = this[offset]\r\n        var mul = 1\r\n        var i = 0\r\n        while (++i < byteLength && (mul *= 0x100)) {\r\n          val += this[offset + i] * mul\r\n        }\r\n\r\n        return val\r\n      }\r\n\r\n      Buffer.prototype.readUIntBE = function readUIntBE(offset, byteLength, noAssert) {\r\n        offset = offset >>> 0\r\n        byteLength = byteLength >>> 0\r\n        if (!noAssert) {\r\n          checkOffset(offset, byteLength, this.length)\r\n        }\r\n\r\n        var val = this[offset + --byteLength]\r\n        var mul = 1\r\n        while (byteLength > 0 && (mul *= 0x100)) {\r\n          val += this[offset + --byteLength] * mul\r\n        }\r\n\r\n        return val\r\n      }\r\n\r\n      Buffer.prototype.readUInt8 = function readUInt8(offset, noAssert) {\r\n        offset = offset >>> 0\r\n        if (!noAssert) checkOffset(offset, 1, this.length)\r\n        return this[offset]\r\n      }\r\n\r\n      Buffer.prototype.readUInt16LE = function readUInt16LE(offset, noAssert) {\r\n        offset = offset >>> 0\r\n        if (!noAssert) checkOffset(offset, 2, this.length)\r\n        return this[offset] | (this[offset + 1] << 8)\r\n      }\r\n\r\n      Buffer.prototype.readUInt16BE = function readUInt16BE(offset, noAssert) {\r\n        offset = offset >>> 0\r\n        if (!noAssert) checkOffset(offset, 2, this.length)\r\n        return (this[offset] << 8) | this[offset + 1]\r\n      }\r\n\r\n      Buffer.prototype.readUInt32LE = function readUInt32LE(offset, noAssert) {\r\n        offset = offset >>> 0\r\n        if (!noAssert) checkOffset(offset, 4, this.length)\r\n\r\n        return ((this[offset]) |\r\n            (this[offset + 1] << 8) |\r\n            (this[offset + 2] << 16)) +\r\n          (this[offset + 3] * 0x1000000)\r\n      }\r\n\r\n      Buffer.prototype.readUInt32BE = function readUInt32BE(offset, noAssert) {\r\n        offset = offset >>> 0\r\n        if (!noAssert) checkOffset(offset, 4, this.length)\r\n\r\n        return (this[offset] * 0x1000000) +\r\n          ((this[offset + 1] << 16) |\r\n            (this[offset + 2] << 8) |\r\n            this[offset + 3])\r\n      }\r\n\r\n      Buffer.prototype.readIntLE = function readIntLE(offset, byteLength, noAssert) {\r\n        offset = offset >>> 0\r\n        byteLength = byteLength >>> 0\r\n        if (!noAssert) checkOffset(offset, byteLength, this.length)\r\n\r\n        var val = this[offset]\r\n        var mul = 1\r\n        var i = 0\r\n        while (++i < byteLength && (mul *= 0x100)) {\r\n          val += this[offset + i] * mul\r\n        }\r\n        mul *= 0x80\r\n\r\n        if (val >= mul) val -= Math.pow(2, 8 * byteLength)\r\n\r\n        return val\r\n      }\r\n\r\n      Buffer.prototype.readIntBE = function readIntBE(offset, byteLength, noAssert) {\r\n        offset = offset >>> 0\r\n        byteLength = byteLength >>> 0\r\n        if (!noAssert) checkOffset(offset, byteLength, this.length)\r\n\r\n        var i = byteLength\r\n        var mul = 1\r\n        var val = this[offset + --i]\r\n        while (i > 0 && (mul *= 0x100)) {\r\n          val += this[offset + --i] * mul\r\n        }\r\n        mul *= 0x80\r\n\r\n        if (val >= mul) val -= Math.pow(2, 8 * byteLength)\r\n\r\n        return val\r\n      }\r\n\r\n      Buffer.prototype.readInt8 = function readInt8(offset, noAssert) {\r\n        offset = offset >>> 0\r\n        if (!noAssert) checkOffset(offset, 1, this.length)\r\n        if (!(this[offset] & 0x80)) return (this[offset])\r\n        return ((0xff - this[offset] + 1) * -1)\r\n      }\r\n\r\n      Buffer.prototype.readInt16LE = function readInt16LE(offset, noAssert) {\r\n        offset = offset >>> 0\r\n        if (!noAssert) checkOffset(offset, 2, this.length)\r\n        var val = this[offset] | (this[offset + 1] << 8)\r\n        return (val & 0x8000) ? val | 0xFFFF0000 : val\r\n      }\r\n\r\n      Buffer.prototype.readInt16BE = function readInt16BE(offset, noAssert) {\r\n        offset = offset >>> 0\r\n        if (!noAssert) checkOffset(offset, 2, this.length)\r\n        var val = this[offset + 1] | (this[offset] << 8)\r\n        return (val & 0x8000) ? val | 0xFFFF0000 : val\r\n      }\r\n\r\n      Buffer.prototype.readInt32LE = function readInt32LE(offset, noAssert) {\r\n        offset = offset >>> 0\r\n        if (!noAssert) checkOffset(offset, 4, this.length)\r\n\r\n        return (this[offset]) |\r\n          (this[offset + 1] << 8) |\r\n          (this[offset + 2] << 16) |\r\n          (this[offset + 3] << 24)\r\n      }\r\n\r\n      Buffer.prototype.readInt32BE = function readInt32BE(offset, noAssert) {\r\n        offset = offset >>> 0\r\n        if (!noAssert) checkOffset(offset, 4, this.length)\r\n\r\n        return (this[offset] << 24) |\r\n          (this[offset + 1] << 16) |\r\n          (this[offset + 2] << 8) |\r\n          (this[offset + 3])\r\n      }\r\n\r\n      Buffer.prototype.readFloatLE = function readFloatLE(offset, noAssert) {\r\n        offset = offset >>> 0\r\n        if (!noAssert) checkOffset(offset, 4, this.length)\r\n        return ieee754.read(this, offset, true, 23, 4)\r\n      }\r\n\r\n      Buffer.prototype.readFloatBE = function readFloatBE(offset, noAssert) {\r\n        offset = offset >>> 0\r\n        if (!noAssert) checkOffset(offset, 4, this.length)\r\n        return ieee754.read(this, offset, false, 23, 4)\r\n      }\r\n\r\n      Buffer.prototype.readDoubleLE = function readDoubleLE(offset, noAssert) {\r\n        offset = offset >>> 0\r\n        if (!noAssert) checkOffset(offset, 8, this.length)\r\n        return ieee754.read(this, offset, true, 52, 8)\r\n      }\r\n\r\n      Buffer.prototype.readDoubleBE = function readDoubleBE(offset, noAssert) {\r\n        offset = offset >>> 0\r\n        if (!noAssert) checkOffset(offset, 8, this.length)\r\n        return ieee754.read(this, offset, false, 52, 8)\r\n      }\r\n\r\n      function checkInt(buf, value, offset, ext, max, min) {\r\n        if (!Buffer.isBuffer(buf)) throw new TypeError('\"buffer\" argument must be a Buffer instance')\r\n        if (value > max || value < min) throw new RangeError('\"value\" argument is out of bounds')\r\n        if (offset + ext > buf.length) throw new RangeError('Index out of range')\r\n      }\r\n\r\n      Buffer.prototype.writeUIntLE = function writeUIntLE(value, offset, byteLength, noAssert) {\r\n        value = +value\r\n        offset = offset >>> 0\r\n        byteLength = byteLength >>> 0\r\n        if (!noAssert) {\r\n          var maxBytes = Math.pow(2, 8 * byteLength) - 1\r\n          checkInt(this, value, offset, byteLength, maxBytes, 0)\r\n        }\r\n\r\n        var mul = 1\r\n        var i = 0\r\n        this[offset] = value & 0xFF\r\n        while (++i < byteLength && (mul *= 0x100)) {\r\n          this[offset + i] = (value / mul) & 0xFF\r\n        }\r\n\r\n        return offset + byteLength\r\n      }\r\n\r\n      Buffer.prototype.writeUIntBE = function writeUIntBE(value, offset, byteLength, noAssert) {\r\n        value = +value\r\n        offset = offset >>> 0\r\n        byteLength = byteLength >>> 0\r\n        if (!noAssert) {\r\n          var maxBytes = Math.pow(2, 8 * byteLength) - 1\r\n          checkInt(this, value, offset, byteLength, maxBytes, 0)\r\n        }\r\n\r\n        var i = byteLength - 1\r\n        var mul = 1\r\n        this[offset + i] = value & 0xFF\r\n        while (--i >= 0 && (mul *= 0x100)) {\r\n          this[offset + i] = (value / mul) & 0xFF\r\n        }\r\n\r\n        return offset + byteLength\r\n      }\r\n\r\n      Buffer.prototype.writeUInt8 = function writeUInt8(value, offset, noAssert) {\r\n        value = +value\r\n        offset = offset >>> 0\r\n        if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)\r\n        this[offset] = (value & 0xff)\r\n        return offset + 1\r\n      }\r\n\r\n      Buffer.prototype.writeUInt16LE = function writeUInt16LE(value, offset, noAssert) {\r\n        value = +value\r\n        offset = offset >>> 0\r\n        if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)\r\n        this[offset] = (value & 0xff)\r\n        this[offset + 1] = (value >>> 8)\r\n        return offset + 2\r\n      }\r\n\r\n      Buffer.prototype.writeUInt16BE = function writeUInt16BE(value, offset, noAssert) {\r\n        value = +value\r\n        offset = offset >>> 0\r\n        if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)\r\n        this[offset] = (value >>> 8)\r\n        this[offset + 1] = (value & 0xff)\r\n        return offset + 2\r\n      }\r\n\r\n      Buffer.prototype.writeUInt32LE = function writeUInt32LE(value, offset, noAssert) {\r\n        value = +value\r\n        offset = offset >>> 0\r\n        if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)\r\n        this[offset + 3] = (value >>> 24)\r\n        this[offset + 2] = (value >>> 16)\r\n        this[offset + 1] = (value >>> 8)\r\n        this[offset] = (value & 0xff)\r\n        return offset + 4\r\n      }\r\n\r\n      Buffer.prototype.writeUInt32BE = function writeUInt32BE(value, offset, noAssert) {\r\n        value = +value\r\n        offset = offset >>> 0\r\n        if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)\r\n        this[offset] = (value >>> 24)\r\n        this[offset + 1] = (value >>> 16)\r\n        this[offset + 2] = (value >>> 8)\r\n        this[offset + 3] = (value & 0xff)\r\n        return offset + 4\r\n      }\r\n\r\n      Buffer.prototype.writeIntLE = function writeIntLE(value, offset, byteLength, noAssert) {\r\n        value = +value\r\n        offset = offset >>> 0\r\n        if (!noAssert) {\r\n          var limit = Math.pow(2, (8 * byteLength) - 1)\r\n\r\n          checkInt(this, value, offset, byteLength, limit - 1, -limit)\r\n        }\r\n\r\n        var i = 0\r\n        var mul = 1\r\n        var sub = 0\r\n        this[offset] = value & 0xFF\r\n        while (++i < byteLength && (mul *= 0x100)) {\r\n          if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {\r\n            sub = 1\r\n          }\r\n          this[offset + i] = ((value / mul) >> 0) - sub & 0xFF\r\n        }\r\n\r\n        return offset + byteLength\r\n      }\r\n\r\n      Buffer.prototype.writeIntBE = function writeIntBE(value, offset, byteLength, noAssert) {\r\n        value = +value\r\n        offset = offset >>> 0\r\n        if (!noAssert) {\r\n          var limit = Math.pow(2, (8 * byteLength) - 1)\r\n\r\n          checkInt(this, value, offset, byteLength, limit - 1, -limit)\r\n        }\r\n\r\n        var i = byteLength - 1\r\n        var mul = 1\r\n        var sub = 0\r\n        this[offset + i] = value & 0xFF\r\n        while (--i >= 0 && (mul *= 0x100)) {\r\n          if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {\r\n            sub = 1\r\n          }\r\n          this[offset + i] = ((value / mul) >> 0) - sub & 0xFF\r\n        }\r\n\r\n        return offset + byteLength\r\n      }\r\n\r\n      Buffer.prototype.writeInt8 = function writeInt8(value, offset, noAssert) {\r\n        value = +value\r\n        offset = offset >>> 0\r\n        if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)\r\n        if (value < 0) value = 0xff + value + 1\r\n        this[offset] = (value & 0xff)\r\n        return offset + 1\r\n      }\r\n\r\n      Buffer.prototype.writeInt16LE = function writeInt16LE(value, offset, noAssert) {\r\n        value = +value\r\n        offset = offset >>> 0\r\n        if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)\r\n        this[offset] = (value & 0xff)\r\n        this[offset + 1] = (value >>> 8)\r\n        return offset + 2\r\n      }\r\n\r\n      Buffer.prototype.writeInt16BE = function writeInt16BE(value, offset, noAssert) {\r\n        value = +value\r\n        offset = offset >>> 0\r\n        if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)\r\n        this[offset] = (value >>> 8)\r\n        this[offset + 1] = (value & 0xff)\r\n        return offset + 2\r\n      }\r\n\r\n      Buffer.prototype.writeInt32LE = function writeInt32LE(value, offset, noAssert) {\r\n        value = +value\r\n        offset = offset >>> 0\r\n        if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)\r\n        this[offset] = (value & 0xff)\r\n        this[offset + 1] = (value >>> 8)\r\n        this[offset + 2] = (value >>> 16)\r\n        this[offset + 3] = (value >>> 24)\r\n        return offset + 4\r\n      }\r\n\r\n      Buffer.prototype.writeInt32BE = function writeInt32BE(value, offset, noAssert) {\r\n        value = +value\r\n        offset = offset >>> 0\r\n        if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)\r\n        if (value < 0) value = 0xffffffff + value + 1\r\n        this[offset] = (value >>> 24)\r\n        this[offset + 1] = (value >>> 16)\r\n        this[offset + 2] = (value >>> 8)\r\n        this[offset + 3] = (value & 0xff)\r\n        return offset + 4\r\n      }\r\n\r\n      function checkIEEE754(buf, value, offset, ext, max, min) {\r\n        if (offset + ext > buf.length) throw new RangeError('Index out of range')\r\n        if (offset < 0) throw new RangeError('Index out of range')\r\n      }\r\n\r\n      function writeFloat(buf, value, offset, littleEndian, noAssert) {\r\n        value = +value\r\n        offset = offset >>> 0\r\n        if (!noAssert) {\r\n          checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)\r\n        }\r\n        ieee754.write(buf, value, offset, littleEndian, 23, 4)\r\n        return offset + 4\r\n      }\r\n\r\n      Buffer.prototype.writeFloatLE = function writeFloatLE(value, offset, noAssert) {\r\n        return writeFloat(this, value, offset, true, noAssert)\r\n      }\r\n\r\n      Buffer.prototype.writeFloatBE = function writeFloatBE(value, offset, noAssert) {\r\n        return writeFloat(this, value, offset, false, noAssert)\r\n      }\r\n\r\n      function writeDouble(buf, value, offset, littleEndian, noAssert) {\r\n        value = +value\r\n        offset = offset >>> 0\r\n        if (!noAssert) {\r\n          checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)\r\n        }\r\n        ieee754.write(buf, value, offset, littleEndian, 52, 8)\r\n        return offset + 8\r\n      }\r\n\r\n      Buffer.prototype.writeDoubleLE = function writeDoubleLE(value, offset, noAssert) {\r\n        return writeDouble(this, value, offset, true, noAssert)\r\n      }\r\n\r\n      Buffer.prototype.writeDoubleBE = function writeDoubleBE(value, offset, noAssert) {\r\n        return writeDouble(this, value, offset, false, noAssert)\r\n      }\r\n\r\n      // copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)\r\n      Buffer.prototype.copy = function copy(target, targetStart, start, end) {\r\n        if (!Buffer.isBuffer(target)) throw new TypeError('argument should be a Buffer')\r\n        if (!start) start = 0\r\n        if (!end && end !== 0) end = this.length\r\n        if (targetStart >= target.length) targetStart = target.length\r\n        if (!targetStart) targetStart = 0\r\n        if (end > 0 && end < start) end = start\r\n\r\n        // Copy 0 bytes; we're done\r\n        if (end === start) return 0\r\n        if (target.length === 0 || this.length === 0) return 0\r\n\r\n        // Fatal error conditions\r\n        if (targetStart < 0) {\r\n          throw new RangeError('targetStart out of bounds')\r\n        }\r\n        if (start < 0 || start >= this.length) throw new RangeError('Index out of range')\r\n        if (end < 0) throw new RangeError('sourceEnd out of bounds')\r\n\r\n        // Are we oob?\r\n        if (end > this.length) end = this.length\r\n        if (target.length - targetStart < end - start) {\r\n          end = target.length - targetStart + start\r\n        }\r\n\r\n        var len = end - start\r\n\r\n        if (this === target && typeof Uint8Array.prototype.copyWithin === 'function') {\r\n          // Use built-in when available, missing from IE11\r\n          this.copyWithin(targetStart, start, end)\r\n        } else if (this === target && start < targetStart && targetStart < end) {\r\n          // descending copy from end\r\n          for (var i = len - 1; i >= 0; --i) {\r\n            target[i + targetStart] = this[i + start]\r\n          }\r\n        } else {\r\n          Uint8Array.prototype.set.call(\r\n            target,\r\n            this.subarray(start, end),\r\n            targetStart\r\n          )\r\n        }\r\n\r\n        return len\r\n      }\r\n\r\n      // Usage:\r\n      //    buffer.fill(number[, offset[, end]])\r\n      //    buffer.fill(buffer[, offset[, end]])\r\n      //    buffer.fill(string[, offset[, end]][, encoding])\r\n      Buffer.prototype.fill = function fill(val, start, end, encoding) {\r\n        // Handle string cases:\r\n        if (typeof val === 'string') {\r\n          if (typeof start === 'string') {\r\n            encoding = start\r\n            start = 0\r\n            end = this.length\r\n          } else if (typeof end === 'string') {\r\n            encoding = end\r\n            end = this.length\r\n          }\r\n          if (encoding !== undefined && typeof encoding !== 'string') {\r\n            throw new TypeError('encoding must be a string')\r\n          }\r\n          if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {\r\n            throw new TypeError('Unknown encoding: ' + encoding)\r\n          }\r\n          if (val.length === 1) {\r\n            var code = val.charCodeAt(0)\r\n            if ((encoding === 'utf8' && code < 128) ||\r\n              encoding === 'latin1') {\r\n              // Fast path: If `val` fits into a single byte, use that numeric value.\r\n              val = code\r\n            }\r\n          }\r\n        } else if (typeof val === 'number') {\r\n          val = val & 255\r\n        }\r\n\r\n        // Invalid ranges are not set to a default, so can range check early.\r\n        if (start < 0 || this.length < start || this.length < end) {\r\n          throw new RangeError('Out of range index')\r\n        }\r\n\r\n        if (end <= start) {\r\n          return this\r\n        }\r\n\r\n        start = start >>> 0\r\n        end = end === undefined ? this.length : end >>> 0\r\n\r\n        if (!val) val = 0\r\n\r\n        var i\r\n        if (typeof val === 'number') {\r\n          for (i = start; i < end; ++i) {\r\n            this[i] = val\r\n          }\r\n        } else {\r\n          var bytes = Buffer.isBuffer(val) ?\r\n            val :\r\n            Buffer.from(val, encoding)\r\n          var len = bytes.length\r\n          if (len === 0) {\r\n            throw new TypeError('The value \"' + val +\r\n              '\" is invalid for argument \"value\"')\r\n          }\r\n          for (i = 0; i < end - start; ++i) {\r\n            this[i + start] = bytes[i % len]\r\n          }\r\n        }\r\n\r\n        return this\r\n      }\r\n\r\n      // HELPER FUNCTIONS\r\n      // ================\r\n\r\n      var INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g\r\n\r\n      function base64clean(str) {\r\n        // Node takes equal signs as end of the Base64 encoding\r\n        str = str.split('=')[0]\r\n        // Node strips out invalid characters like \\n and \\t from the string, base64-js does not\r\n        str = str.trim().replace(INVALID_BASE64_RE, '')\r\n        // Node converts strings with length < 2 to ''\r\n        if (str.length < 2) return ''\r\n        // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not\r\n        while (str.length % 4 !== 0) {\r\n          str = str + '='\r\n        }\r\n        return str\r\n      }\r\n\r\n      function toHex(n) {\r\n        if (n < 16) return '0' + n.toString(16)\r\n        return n.toString(16)\r\n      }\r\n\r\n      function utf8ToBytes(string, units) {\r\n        units = units || Infinity\r\n        var codePoint\r\n        var length = string.length\r\n        var leadSurrogate = null\r\n        var bytes = []\r\n\r\n        for (var i = 0; i < length; ++i) {\r\n          codePoint = string.charCodeAt(i)\r\n\r\n          // is surrogate component\r\n          if (codePoint > 0xD7FF && codePoint < 0xE000) {\r\n            // last char was a lead\r\n            if (!leadSurrogate) {\r\n              // no lead yet\r\n              if (codePoint > 0xDBFF) {\r\n                // unexpected trail\r\n                if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\r\n                continue\r\n              } else if (i + 1 === length) {\r\n                // unpaired lead\r\n                if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\r\n                continue\r\n              }\r\n\r\n              // valid lead\r\n              leadSurrogate = codePoint\r\n\r\n              continue\r\n            }\r\n\r\n            // 2 leads in a row\r\n            if (codePoint < 0xDC00) {\r\n              if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\r\n              leadSurrogate = codePoint\r\n              continue\r\n            }\r\n\r\n            // valid surrogate pair\r\n            codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000\r\n          } else if (leadSurrogate) {\r\n            // valid bmp char, but last char was a lead\r\n            if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\r\n          }\r\n\r\n          leadSurrogate = null\r\n\r\n          // encode utf8\r\n          if (codePoint < 0x80) {\r\n            if ((units -= 1) < 0) break\r\n            bytes.push(codePoint)\r\n          } else if (codePoint < 0x800) {\r\n            if ((units -= 2) < 0) break\r\n            bytes.push(\r\n              codePoint >> 0x6 | 0xC0,\r\n              codePoint & 0x3F | 0x80\r\n            )\r\n          } else if (codePoint < 0x10000) {\r\n            if ((units -= 3) < 0) break\r\n            bytes.push(\r\n              codePoint >> 0xC | 0xE0,\r\n              codePoint >> 0x6 & 0x3F | 0x80,\r\n              codePoint & 0x3F | 0x80\r\n            )\r\n          } else if (codePoint < 0x110000) {\r\n            if ((units -= 4) < 0) break\r\n            bytes.push(\r\n              codePoint >> 0x12 | 0xF0,\r\n              codePoint >> 0xC & 0x3F | 0x80,\r\n              codePoint >> 0x6 & 0x3F | 0x80,\r\n              codePoint & 0x3F | 0x80\r\n            )\r\n          } else {\r\n            throw new Error('Invalid code point')\r\n          }\r\n        }\r\n\r\n        return bytes\r\n      }\r\n\r\n      function asciiToBytes(str) {\r\n        var byteArray = []\r\n        for (var i = 0; i < str.length; ++i) {\r\n          // Node's code seems to be doing this and not & 0x7F..\r\n          byteArray.push(str.charCodeAt(i) & 0xFF)\r\n        }\r\n        return byteArray\r\n      }\r\n\r\n      function utf16leToBytes(str, units) {\r\n        var c, hi, lo\r\n        var byteArray = []\r\n        for (var i = 0; i < str.length; ++i) {\r\n          if ((units -= 2) < 0) break\r\n\r\n          c = str.charCodeAt(i)\r\n          hi = c >> 8\r\n          lo = c % 256\r\n          byteArray.push(lo)\r\n          byteArray.push(hi)\r\n        }\r\n\r\n        return byteArray\r\n      }\r\n\r\n      function base64ToBytes(str) {\r\n        return base64.toByteArray(base64clean(str))\r\n      }\r\n\r\n      function blitBuffer(src, dst, offset, length) {\r\n        for (var i = 0; i < length; ++i) {\r\n          if ((i + offset >= dst.length) || (i >= src.length)) break\r\n          dst[i + offset] = src[i]\r\n        }\r\n        return i\r\n      }\r\n\r\n      // ArrayBuffer or Uint8Array objects from other contexts (i.e. iframes) do not pass\r\n      // the `instanceof` check but they should be treated as of that type.\r\n      // See: https://github.com/feross/buffer/issues/166\r\n      function isInstance(obj, type) {\r\n        return obj instanceof type ||\r\n          (obj != null && obj.constructor != null && obj.constructor.name != null &&\r\n            obj.constructor.name === type.name)\r\n      }\r\n\r\n      function numberIsNaN(obj) {\r\n        // For IE11 support\r\n        return obj !== obj // eslint-disable-line no-self-compare\r\n      }\r\n\r\n    }, {\r\n      \"base64-js\": 21,\r\n      \"ieee754\": 105\r\n    }],\r\n    55: [function (require, module, exports) {\r\n      var Buffer = require('safe-buffer').Buffer\r\n      var Transform = require('stream').Transform\r\n      var StringDecoder = require('string_decoder').StringDecoder\r\n      var inherits = require('inherits')\r\n\r\n      function CipherBase(hashMode) {\r\n        Transform.call(this)\r\n        this.hashMode = typeof hashMode === 'string'\r\n        if (this.hashMode) {\r\n          this[hashMode] = this._finalOrDigest\r\n        } else {\r\n          this.final = this._finalOrDigest\r\n        }\r\n        if (this._final) {\r\n          this.__final = this._final\r\n          this._final = null\r\n        }\r\n        this._decoder = null\r\n        this._encoding = null\r\n      }\r\n      inherits(CipherBase, Transform)\r\n\r\n      CipherBase.prototype.update = function (data, inputEnc, outputEnc) {\r\n        if (typeof data === 'string') {\r\n          data = Buffer.from(data, inputEnc)\r\n        }\r\n\r\n        var outData = this._update(data)\r\n        if (this.hashMode) return this\r\n\r\n        if (outputEnc) {\r\n          outData = this._toString(outData, outputEnc)\r\n        }\r\n\r\n        return outData\r\n      }\r\n\r\n      CipherBase.prototype.setAutoPadding = function () {}\r\n      CipherBase.prototype.getAuthTag = function () {\r\n        throw new Error('trying to get auth tag in unsupported state')\r\n      }\r\n\r\n      CipherBase.prototype.setAuthTag = function () {\r\n        throw new Error('trying to set auth tag in unsupported state')\r\n      }\r\n\r\n      CipherBase.prototype.setAAD = function () {\r\n        throw new Error('trying to set aad in unsupported state')\r\n      }\r\n\r\n      CipherBase.prototype._transform = function (data, _, next) {\r\n        var err\r\n        try {\r\n          if (this.hashMode) {\r\n            this._update(data)\r\n          } else {\r\n            this.push(this._update(data))\r\n          }\r\n        } catch (e) {\r\n          err = e\r\n        } finally {\r\n          next(err)\r\n        }\r\n      }\r\n      CipherBase.prototype._flush = function (done) {\r\n        var err\r\n        try {\r\n          this.push(this.__final())\r\n        } catch (e) {\r\n          err = e\r\n        }\r\n\r\n        done(err)\r\n      }\r\n      CipherBase.prototype._finalOrDigest = function (outputEnc) {\r\n        var outData = this.__final() || Buffer.alloc(0)\r\n        if (outputEnc) {\r\n          outData = this._toString(outData, outputEnc, true)\r\n        }\r\n        return outData\r\n      }\r\n\r\n      CipherBase.prototype._toString = function (value, enc, fin) {\r\n        if (!this._decoder) {\r\n          this._decoder = new StringDecoder(enc)\r\n          this._encoding = enc\r\n        }\r\n\r\n        if (this._encoding !== enc) throw new Error('can\\'t switch encodings')\r\n\r\n        var out = this._decoder.write(value)\r\n        if (fin) {\r\n          out += this._decoder.end()\r\n        }\r\n\r\n        return out\r\n      }\r\n\r\n      module.exports = CipherBase\r\n\r\n    }, {\r\n      \"inherits\": 106,\r\n      \"safe-buffer\": 147,\r\n      \"stream\": 156,\r\n      \"string_decoder\": 157\r\n    }],\r\n    56: [function (require, module, exports) {\r\n      (function (Buffer) {\r\n        // Copyright Joyent, Inc. and other Node contributors.\r\n        //\r\n        // Permission is hereby granted, free of charge, to any person obtaining a\r\n        // copy of this software and associated documentation files (the\r\n        // \"Software\"), to deal in the Software without restriction, including\r\n        // without limitation the rights to use, copy, modify, merge, publish,\r\n        // distribute, sublicense, and/or sell copies of the Software, and to permit\r\n        // persons to whom the Software is furnished to do so, subject to the\r\n        // following conditions:\r\n        //\r\n        // The above copyright notice and this permission notice shall be included\r\n        // in all copies or substantial portions of the Software.\r\n        //\r\n        // THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\r\n        // OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\r\n        // MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\r\n        // NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\r\n        // DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\r\n        // OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\r\n        // USE OR OTHER DEALINGS IN THE SOFTWARE.\r\n\r\n        // NOTE: These type checking functions intentionally don't use `instanceof`\r\n        // because it is fragile and can be easily faked with `Object.create()`.\r\n\r\n        function isArray(arg) {\r\n          if (Array.isArray) {\r\n            return Array.isArray(arg);\r\n          }\r\n          return objectToString(arg) === '[object Array]';\r\n        }\r\n        exports.isArray = isArray;\r\n\r\n        function isBoolean(arg) {\r\n          return typeof arg === 'boolean';\r\n        }\r\n        exports.isBoolean = isBoolean;\r\n\r\n        function isNull(arg) {\r\n          return arg === null;\r\n        }\r\n        exports.isNull = isNull;\r\n\r\n        function isNullOrUndefined(arg) {\r\n          return arg == null;\r\n        }\r\n        exports.isNullOrUndefined = isNullOrUndefined;\r\n\r\n        function isNumber(arg) {\r\n          return typeof arg === 'number';\r\n        }\r\n        exports.isNumber = isNumber;\r\n\r\n        function isString(arg) {\r\n          return typeof arg === 'string';\r\n        }\r\n        exports.isString = isString;\r\n\r\n        function isSymbol(arg) {\r\n          return typeof arg === 'symbol';\r\n        }\r\n        exports.isSymbol = isSymbol;\r\n\r\n        function isUndefined(arg) {\r\n          return arg === void 0;\r\n        }\r\n        exports.isUndefined = isUndefined;\r\n\r\n        function isRegExp(re) {\r\n          return objectToString(re) === '[object RegExp]';\r\n        }\r\n        exports.isRegExp = isRegExp;\r\n\r\n        function isObject(arg) {\r\n          return typeof arg === 'object' && arg !== null;\r\n        }\r\n        exports.isObject = isObject;\r\n\r\n        function isDate(d) {\r\n          return objectToString(d) === '[object Date]';\r\n        }\r\n        exports.isDate = isDate;\r\n\r\n        function isError(e) {\r\n          return (objectToString(e) === '[object Error]' || e instanceof Error);\r\n        }\r\n        exports.isError = isError;\r\n\r\n        function isFunction(arg) {\r\n          return typeof arg === 'function';\r\n        }\r\n        exports.isFunction = isFunction;\r\n\r\n        function isPrimitive(arg) {\r\n          return arg === null ||\r\n            typeof arg === 'boolean' ||\r\n            typeof arg === 'number' ||\r\n            typeof arg === 'string' ||\r\n            typeof arg === 'symbol' || // ES6 symbol\r\n            typeof arg === 'undefined';\r\n        }\r\n        exports.isPrimitive = isPrimitive;\r\n\r\n        exports.isBuffer = Buffer.isBuffer;\r\n\r\n        function objectToString(o) {\r\n          return Object.prototype.toString.call(o);\r\n        }\r\n\r\n      }).call(this, {\r\n        \"isBuffer\": require(\"../../is-buffer/index.js\")\r\n      })\r\n    }, {\r\n      \"../../is-buffer/index.js\": 107\r\n    }],\r\n    57: [function (require, module, exports) {\r\n      (function (Buffer) {\r\n        var elliptic = require('elliptic')\r\n        var BN = require('bn.js')\r\n\r\n        module.exports = function createECDH(curve) {\r\n          return new ECDH(curve)\r\n        }\r\n\r\n        var aliases = {\r\n          secp256k1: {\r\n            name: 'secp256k1',\r\n            byteLength: 32\r\n          },\r\n          secp224r1: {\r\n            name: 'p224',\r\n            byteLength: 28\r\n          },\r\n          prime256v1: {\r\n            name: 'p256',\r\n            byteLength: 32\r\n          },\r\n          prime192v1: {\r\n            name: 'p192',\r\n            byteLength: 24\r\n          },\r\n          ed25519: {\r\n            name: 'ed25519',\r\n            byteLength: 32\r\n          },\r\n          secp384r1: {\r\n            name: 'p384',\r\n            byteLength: 48\r\n          },\r\n          secp521r1: {\r\n            name: 'p521',\r\n            byteLength: 66\r\n          }\r\n        }\r\n\r\n        aliases.p224 = aliases.secp224r1\r\n        aliases.p256 = aliases.secp256r1 = aliases.prime256v1\r\n        aliases.p192 = aliases.secp192r1 = aliases.prime192v1\r\n        aliases.p384 = aliases.secp384r1\r\n        aliases.p521 = aliases.secp521r1\r\n\r\n        function ECDH(curve) {\r\n          this.curveType = aliases[curve]\r\n          if (!this.curveType) {\r\n            this.curveType = {\r\n              name: curve\r\n            }\r\n          }\r\n          this.curve = new elliptic.ec(this.curveType.name) // eslint-disable-line new-cap\r\n          this.keys = void 0\r\n        }\r\n\r\n        ECDH.prototype.generateKeys = function (enc, format) {\r\n          this.keys = this.curve.genKeyPair()\r\n          return this.getPublicKey(enc, format)\r\n        }\r\n\r\n        ECDH.prototype.computeSecret = function (other, inenc, enc) {\r\n          inenc = inenc || 'utf8'\r\n          if (!Buffer.isBuffer(other)) {\r\n            other = new Buffer(other, inenc)\r\n          }\r\n          var otherPub = this.curve.keyFromPublic(other).getPublic()\r\n          var out = otherPub.mul(this.keys.getPrivate()).getX()\r\n          return formatReturnValue(out, enc, this.curveType.byteLength)\r\n        }\r\n\r\n        ECDH.prototype.getPublicKey = function (enc, format) {\r\n          var key = this.keys.getPublic(format === 'compressed', true)\r\n          if (format === 'hybrid') {\r\n            if (key[key.length - 1] % 2) {\r\n              key[0] = 7\r\n            } else {\r\n              key[0] = 6\r\n            }\r\n          }\r\n          return formatReturnValue(key, enc)\r\n        }\r\n\r\n        ECDH.prototype.getPrivateKey = function (enc) {\r\n          return formatReturnValue(this.keys.getPrivate(), enc)\r\n        }\r\n\r\n        ECDH.prototype.setPublicKey = function (pub, enc) {\r\n          enc = enc || 'utf8'\r\n          if (!Buffer.isBuffer(pub)) {\r\n            pub = new Buffer(pub, enc)\r\n          }\r\n          this.keys._importPublic(pub)\r\n          return this\r\n        }\r\n\r\n        ECDH.prototype.setPrivateKey = function (priv, enc) {\r\n          enc = enc || 'utf8'\r\n          if (!Buffer.isBuffer(priv)) {\r\n            priv = new Buffer(priv, enc)\r\n          }\r\n\r\n          var _priv = new BN(priv)\r\n          _priv = _priv.toString(16)\r\n          this.keys = this.curve.genKeyPair()\r\n          this.keys._importPrivate(_priv)\r\n          return this\r\n        }\r\n\r\n        function formatReturnValue(bn, enc, len) {\r\n          if (!Array.isArray(bn)) {\r\n            bn = bn.toArray()\r\n          }\r\n          var buf = new Buffer(bn)\r\n          if (len && buf.length < len) {\r\n            var zeros = new Buffer(len - buf.length)\r\n            zeros.fill(0)\r\n            buf = Buffer.concat([zeros, buf])\r\n          }\r\n          if (!enc) {\r\n            return buf\r\n          } else {\r\n            return buf.toString(enc)\r\n          }\r\n        }\r\n\r\n      }).call(this, require(\"buffer\").Buffer)\r\n    }, {\r\n      \"bn.js\": 23,\r\n      \"buffer\": 54,\r\n      \"elliptic\": 73\r\n    }],\r\n    58: [function (require, module, exports) {\r\n      'use strict'\r\n      var inherits = require('inherits')\r\n      var MD5 = require('md5.js')\r\n      var RIPEMD160 = require('ripemd160')\r\n      var sha = require('sha.js')\r\n      var Base = require('cipher-base')\r\n\r\n      function Hash(hash) {\r\n        Base.call(this, 'digest')\r\n\r\n        this._hash = hash\r\n      }\r\n\r\n      inherits(Hash, Base)\r\n\r\n      Hash.prototype._update = function (data) {\r\n        this._hash.update(data)\r\n      }\r\n\r\n      Hash.prototype._final = function () {\r\n        return this._hash.digest()\r\n      }\r\n\r\n      module.exports = function createHash(alg) {\r\n        alg = alg.toLowerCase()\r\n        if (alg === 'md5') return new MD5()\r\n        if (alg === 'rmd160' || alg === 'ripemd160') return new RIPEMD160()\r\n\r\n        return new Hash(sha(alg))\r\n      }\r\n\r\n    }, {\r\n      \"cipher-base\": 55,\r\n      \"inherits\": 106,\r\n      \"md5.js\": 109,\r\n      \"ripemd160\": 146,\r\n      \"sha.js\": 149\r\n    }],\r\n    59: [function (require, module, exports) {\r\n      var MD5 = require('md5.js')\r\n\r\n      module.exports = function (buffer) {\r\n        return new MD5().update(buffer).digest()\r\n      }\r\n\r\n    }, {\r\n      \"md5.js\": 109\r\n    }],\r\n    60: [function (require, module, exports) {\r\n      'use strict'\r\n      var inherits = require('inherits')\r\n      var Legacy = require('./legacy')\r\n      var Base = require('cipher-base')\r\n      var Buffer = require('safe-buffer').Buffer\r\n      var md5 = require('create-hash/md5')\r\n      var RIPEMD160 = require('ripemd160')\r\n\r\n      var sha = require('sha.js')\r\n\r\n      var ZEROS = Buffer.alloc(128)\r\n\r\n      function Hmac(alg, key) {\r\n        Base.call(this, 'digest')\r\n        if (typeof key === 'string') {\r\n          key = Buffer.from(key)\r\n        }\r\n\r\n        var blocksize = (alg === 'sha512' || alg === 'sha384') ? 128 : 64\r\n\r\n        this._alg = alg\r\n        this._key = key\r\n        if (key.length > blocksize) {\r\n          var hash = alg === 'rmd160' ? new RIPEMD160() : sha(alg)\r\n          key = hash.update(key).digest()\r\n        } else if (key.length < blocksize) {\r\n          key = Buffer.concat([key, ZEROS], blocksize)\r\n        }\r\n\r\n        var ipad = this._ipad = Buffer.allocUnsafe(blocksize)\r\n        var opad = this._opad = Buffer.allocUnsafe(blocksize)\r\n\r\n        for (var i = 0; i < blocksize; i++) {\r\n          ipad[i] = key[i] ^ 0x36\r\n          opad[i] = key[i] ^ 0x5C\r\n        }\r\n        this._hash = alg === 'rmd160' ? new RIPEMD160() : sha(alg)\r\n        this._hash.update(ipad)\r\n      }\r\n\r\n      inherits(Hmac, Base)\r\n\r\n      Hmac.prototype._update = function (data) {\r\n        this._hash.update(data)\r\n      }\r\n\r\n      Hmac.prototype._final = function () {\r\n        var h = this._hash.digest()\r\n        var hash = this._alg === 'rmd160' ? new RIPEMD160() : sha(this._alg)\r\n        return hash.update(this._opad).update(h).digest()\r\n      }\r\n\r\n      module.exports = function createHmac(alg, key) {\r\n        alg = alg.toLowerCase()\r\n        if (alg === 'rmd160' || alg === 'ripemd160') {\r\n          return new Hmac('rmd160', key)\r\n        }\r\n        if (alg === 'md5') {\r\n          return new Legacy(md5, key)\r\n        }\r\n        return new Hmac(alg, key)\r\n      }\r\n\r\n    }, {\r\n      \"./legacy\": 61,\r\n      \"cipher-base\": 55,\r\n      \"create-hash/md5\": 59,\r\n      \"inherits\": 106,\r\n      \"ripemd160\": 146,\r\n      \"safe-buffer\": 147,\r\n      \"sha.js\": 149\r\n    }],\r\n    61: [function (require, module, exports) {\r\n      'use strict'\r\n      var inherits = require('inherits')\r\n      var Buffer = require('safe-buffer').Buffer\r\n\r\n      var Base = require('cipher-base')\r\n\r\n      var ZEROS = Buffer.alloc(128)\r\n      var blocksize = 64\r\n\r\n      function Hmac(alg, key) {\r\n        Base.call(this, 'digest')\r\n        if (typeof key === 'string') {\r\n          key = Buffer.from(key)\r\n        }\r\n\r\n        this._alg = alg\r\n        this._key = key\r\n\r\n        if (key.length > blocksize) {\r\n          key = alg(key)\r\n        } else if (key.length < blocksize) {\r\n          key = Buffer.concat([key, ZEROS], blocksize)\r\n        }\r\n\r\n        var ipad = this._ipad = Buffer.allocUnsafe(blocksize)\r\n        var opad = this._opad = Buffer.allocUnsafe(blocksize)\r\n\r\n        for (var i = 0; i < blocksize; i++) {\r\n          ipad[i] = key[i] ^ 0x36\r\n          opad[i] = key[i] ^ 0x5C\r\n        }\r\n\r\n        this._hash = [ipad]\r\n      }\r\n\r\n      inherits(Hmac, Base)\r\n\r\n      Hmac.prototype._update = function (data) {\r\n        this._hash.push(data)\r\n      }\r\n\r\n      Hmac.prototype._final = function () {\r\n        var h = this._alg(Buffer.concat(this._hash))\r\n        return this._alg(Buffer.concat([this._opad, h]))\r\n      }\r\n      module.exports = Hmac\r\n\r\n    }, {\r\n      \"cipher-base\": 55,\r\n      \"inherits\": 106,\r\n      \"safe-buffer\": 147\r\n    }],\r\n    62: [function (require, module, exports) {\r\n      'use strict'\r\n\r\n      exports.randomBytes = exports.rng = exports.pseudoRandomBytes = exports.prng = require('randombytes')\r\n      exports.createHash = exports.Hash = require('create-hash')\r\n      exports.createHmac = exports.Hmac = require('create-hmac')\r\n\r\n      var algos = require('browserify-sign/algos')\r\n      var algoKeys = Object.keys(algos)\r\n      var hashes = ['sha1', 'sha224', 'sha256', 'sha384', 'sha512', 'md5', 'rmd160'].concat(algoKeys)\r\n      exports.getHashes = function () {\r\n        return hashes\r\n      }\r\n\r\n      var p = require('pbkdf2')\r\n      exports.pbkdf2 = p.pbkdf2\r\n      exports.pbkdf2Sync = p.pbkdf2Sync\r\n\r\n      var aes = require('browserify-cipher')\r\n\r\n      exports.Cipher = aes.Cipher\r\n      exports.createCipher = aes.createCipher\r\n      exports.Cipheriv = aes.Cipheriv\r\n      exports.createCipheriv = aes.createCipheriv\r\n      exports.Decipher = aes.Decipher\r\n      exports.createDecipher = aes.createDecipher\r\n      exports.Decipheriv = aes.Decipheriv\r\n      exports.createDecipheriv = aes.createDecipheriv\r\n      exports.getCiphers = aes.getCiphers\r\n      exports.listCiphers = aes.listCiphers\r\n\r\n      var dh = require('diffie-hellman')\r\n\r\n      exports.DiffieHellmanGroup = dh.DiffieHellmanGroup\r\n      exports.createDiffieHellmanGroup = dh.createDiffieHellmanGroup\r\n      exports.getDiffieHellman = dh.getDiffieHellman\r\n      exports.createDiffieHellman = dh.createDiffieHellman\r\n      exports.DiffieHellman = dh.DiffieHellman\r\n\r\n      var sign = require('browserify-sign')\r\n\r\n      exports.createSign = sign.createSign\r\n      exports.Sign = sign.Sign\r\n      exports.createVerify = sign.createVerify\r\n      exports.Verify = sign.Verify\r\n\r\n      exports.createECDH = require('create-ecdh')\r\n\r\n      var publicEncrypt = require('public-encrypt')\r\n\r\n      exports.publicEncrypt = publicEncrypt.publicEncrypt\r\n      exports.privateEncrypt = publicEncrypt.privateEncrypt\r\n      exports.publicDecrypt = publicEncrypt.publicDecrypt\r\n      exports.privateDecrypt = publicEncrypt.privateDecrypt\r\n\r\n      // the least I can do is make error messages for the rest of the node.js/crypto api.\r\n      // ;[\r\n      //   'createCredentials'\r\n      // ].forEach(function (name) {\r\n      //   exports[name] = function () {\r\n      //     throw new Error([\r\n      //       'sorry, ' + name + ' is not implemented yet',\r\n      //       'we accept pull requests',\r\n      //       'https://github.com/crypto-browserify/crypto-browserify'\r\n      //     ].join('\\n'))\r\n      //   }\r\n      // })\r\n\r\n      var rf = require('randomfill')\r\n\r\n      exports.randomFill = rf.randomFill\r\n      exports.randomFillSync = rf.randomFillSync\r\n\r\n      exports.createCredentials = function () {\r\n        throw new Error([\r\n          'sorry, createCredentials is not implemented yet',\r\n          'we accept pull requests',\r\n          'https://github.com/crypto-browserify/crypto-browserify'\r\n        ].join('\\n'))\r\n      }\r\n\r\n      exports.constants = {\r\n        'DH_CHECK_P_NOT_SAFE_PRIME': 2,\r\n        'DH_CHECK_P_NOT_PRIME': 1,\r\n        'DH_UNABLE_TO_CHECK_GENERATOR': 4,\r\n        'DH_NOT_SUITABLE_GENERATOR': 8,\r\n        'NPN_ENABLED': 1,\r\n        'ALPN_ENABLED': 1,\r\n        'RSA_PKCS1_PADDING': 1,\r\n        'RSA_SSLV23_PADDING': 2,\r\n        'RSA_NO_PADDING': 3,\r\n        'RSA_PKCS1_OAEP_PADDING': 4,\r\n        'RSA_X931_PADDING': 5,\r\n        'RSA_PKCS1_PSS_PADDING': 6,\r\n        'POINT_CONVERSION_COMPRESSED': 2,\r\n        'POINT_CONVERSION_UNCOMPRESSED': 4,\r\n        'POINT_CONVERSION_HYBRID': 6\r\n      }\r\n\r\n    }, {\r\n      \"browserify-cipher\": 43,\r\n      \"browserify-sign\": 50,\r\n      \"browserify-sign/algos\": 47,\r\n      \"create-ecdh\": 57,\r\n      \"create-hash\": 58,\r\n      \"create-hmac\": 60,\r\n      \"diffie-hellman\": 69,\r\n      \"pbkdf2\": 118,\r\n      \"public-encrypt\": 125,\r\n      \"randombytes\": 131,\r\n      \"randomfill\": 132\r\n    }],\r\n    63: [function (require, module, exports) {\r\n      'use strict';\r\n\r\n      exports.utils = require('./des/utils');\r\n      exports.Cipher = require('./des/cipher');\r\n      exports.DES = require('./des/des');\r\n      exports.CBC = require('./des/cbc');\r\n      exports.EDE = require('./des/ede');\r\n\r\n    }, {\r\n      \"./des/cbc\": 64,\r\n      \"./des/cipher\": 65,\r\n      \"./des/des\": 66,\r\n      \"./des/ede\": 67,\r\n      \"./des/utils\": 68\r\n    }],\r\n    64: [function (require, module, exports) {\r\n      'use strict';\r\n\r\n      var assert = require('minimalistic-assert');\r\n      var inherits = require('inherits');\r\n\r\n      var proto = {};\r\n\r\n      function CBCState(iv) {\r\n        assert.equal(iv.length, 8, 'Invalid IV length');\r\n\r\n        this.iv = new Array(8);\r\n        for (var i = 0; i < this.iv.length; i++)\r\n          this.iv[i] = iv[i];\r\n      }\r\n\r\n      function instantiate(Base) {\r\n        function CBC(options) {\r\n          Base.call(this, options);\r\n          this._cbcInit();\r\n        }\r\n        inherits(CBC, Base);\r\n\r\n        var keys = Object.keys(proto);\r\n        for (var i = 0; i < keys.length; i++) {\r\n          var key = keys[i];\r\n          CBC.prototype[key] = proto[key];\r\n        }\r\n\r\n        CBC.create = function create(options) {\r\n          return new CBC(options);\r\n        };\r\n\r\n        return CBC;\r\n      }\r\n\r\n      exports.instantiate = instantiate;\r\n\r\n      proto._cbcInit = function _cbcInit() {\r\n        var state = new CBCState(this.options.iv);\r\n        this._cbcState = state;\r\n      };\r\n\r\n      proto._update = function _update(inp, inOff, out, outOff) {\r\n        var state = this._cbcState;\r\n        var superProto = this.constructor.super_.prototype;\r\n\r\n        var iv = state.iv;\r\n        if (this.type === 'encrypt') {\r\n          for (var i = 0; i < this.blockSize; i++)\r\n            iv[i] ^= inp[inOff + i];\r\n\r\n          superProto._update.call(this, iv, 0, out, outOff);\r\n\r\n          for (var i = 0; i < this.blockSize; i++)\r\n            iv[i] = out[outOff + i];\r\n        } else {\r\n          superProto._update.call(this, inp, inOff, out, outOff);\r\n\r\n          for (var i = 0; i < this.blockSize; i++)\r\n            out[outOff + i] ^= iv[i];\r\n\r\n          for (var i = 0; i < this.blockSize; i++)\r\n            iv[i] = inp[inOff + i];\r\n        }\r\n      };\r\n\r\n    }, {\r\n      \"inherits\": 106,\r\n      \"minimalistic-assert\": 111\r\n    }],\r\n    65: [function (require, module, exports) {\r\n      'use strict';\r\n\r\n      var assert = require('minimalistic-assert');\r\n\r\n      function Cipher(options) {\r\n        this.options = options;\r\n\r\n        this.type = this.options.type;\r\n        this.blockSize = 8;\r\n        this._init();\r\n\r\n        this.buffer = new Array(this.blockSize);\r\n        this.bufferOff = 0;\r\n      }\r\n      module.exports = Cipher;\r\n\r\n      Cipher.prototype._init = function _init() {\r\n        // Might be overrided\r\n      };\r\n\r\n      Cipher.prototype.update = function update(data) {\r\n        if (data.length === 0)\r\n          return [];\r\n\r\n        if (this.type === 'decrypt')\r\n          return this._updateDecrypt(data);\r\n        else\r\n          return this._updateEncrypt(data);\r\n      };\r\n\r\n      Cipher.prototype._buffer = function _buffer(data, off) {\r\n        // Append data to buffer\r\n        var min = Math.min(this.buffer.length - this.bufferOff, data.length - off);\r\n        for (var i = 0; i < min; i++)\r\n          this.buffer[this.bufferOff + i] = data[off + i];\r\n        this.bufferOff += min;\r\n\r\n        // Shift next\r\n        return min;\r\n      };\r\n\r\n      Cipher.prototype._flushBuffer = function _flushBuffer(out, off) {\r\n        this._update(this.buffer, 0, out, off);\r\n        this.bufferOff = 0;\r\n        return this.blockSize;\r\n      };\r\n\r\n      Cipher.prototype._updateEncrypt = function _updateEncrypt(data) {\r\n        var inputOff = 0;\r\n        var outputOff = 0;\r\n\r\n        var count = ((this.bufferOff + data.length) / this.blockSize) | 0;\r\n        var out = new Array(count * this.blockSize);\r\n\r\n        if (this.bufferOff !== 0) {\r\n          inputOff += this._buffer(data, inputOff);\r\n\r\n          if (this.bufferOff === this.buffer.length)\r\n            outputOff += this._flushBuffer(out, outputOff);\r\n        }\r\n\r\n        // Write blocks\r\n        var max = data.length - ((data.length - inputOff) % this.blockSize);\r\n        for (; inputOff < max; inputOff += this.blockSize) {\r\n          this._update(data, inputOff, out, outputOff);\r\n          outputOff += this.blockSize;\r\n        }\r\n\r\n        // Queue rest\r\n        for (; inputOff < data.length; inputOff++, this.bufferOff++)\r\n          this.buffer[this.bufferOff] = data[inputOff];\r\n\r\n        return out;\r\n      };\r\n\r\n      Cipher.prototype._updateDecrypt = function _updateDecrypt(data) {\r\n        var inputOff = 0;\r\n        var outputOff = 0;\r\n\r\n        var count = Math.ceil((this.bufferOff + data.length) / this.blockSize) - 1;\r\n        var out = new Array(count * this.blockSize);\r\n\r\n        // TODO(indutny): optimize it, this is far from optimal\r\n        for (; count > 0; count--) {\r\n          inputOff += this._buffer(data, inputOff);\r\n          outputOff += this._flushBuffer(out, outputOff);\r\n        }\r\n\r\n        // Buffer rest of the input\r\n        inputOff += this._buffer(data, inputOff);\r\n\r\n        return out;\r\n      };\r\n\r\n      Cipher.prototype.final = function final(buffer) {\r\n        var first;\r\n        if (buffer)\r\n          first = this.update(buffer);\r\n\r\n        var last;\r\n        if (this.type === 'encrypt')\r\n          last = this._finalEncrypt();\r\n        else\r\n          last = this._finalDecrypt();\r\n\r\n        if (first)\r\n          return first.concat(last);\r\n        else\r\n          return last;\r\n      };\r\n\r\n      Cipher.prototype._pad = function _pad(buffer, off) {\r\n        if (off === 0)\r\n          return false;\r\n\r\n        while (off < buffer.length)\r\n          buffer[off++] = 0;\r\n\r\n        return true;\r\n      };\r\n\r\n      Cipher.prototype._finalEncrypt = function _finalEncrypt() {\r\n        if (!this._pad(this.buffer, this.bufferOff))\r\n          return [];\r\n\r\n        var out = new Array(this.blockSize);\r\n        this._update(this.buffer, 0, out, 0);\r\n        return out;\r\n      };\r\n\r\n      Cipher.prototype._unpad = function _unpad(buffer) {\r\n        return buffer;\r\n      };\r\n\r\n      Cipher.prototype._finalDecrypt = function _finalDecrypt() {\r\n        assert.equal(this.bufferOff, this.blockSize, 'Not enough data to decrypt');\r\n        var out = new Array(this.blockSize);\r\n        this._flushBuffer(out, 0);\r\n\r\n        return this._unpad(out);\r\n      };\r\n\r\n    }, {\r\n      \"minimalistic-assert\": 111\r\n    }],\r\n    66: [function (require, module, exports) {\r\n      'use strict';\r\n\r\n      var assert = require('minimalistic-assert');\r\n      var inherits = require('inherits');\r\n\r\n      var des = require('../des');\r\n      var utils = des.utils;\r\n      var Cipher = des.Cipher;\r\n\r\n      function DESState() {\r\n        this.tmp = new Array(2);\r\n        this.keys = null;\r\n      }\r\n\r\n      function DES(options) {\r\n        Cipher.call(this, options);\r\n\r\n        var state = new DESState();\r\n        this._desState = state;\r\n\r\n        this.deriveKeys(state, options.key);\r\n      }\r\n      inherits(DES, Cipher);\r\n      module.exports = DES;\r\n\r\n      DES.create = function create(options) {\r\n        return new DES(options);\r\n      };\r\n\r\n      var shiftTable = [\r\n        1, 1, 2, 2, 2, 2, 2, 2,\r\n        1, 2, 2, 2, 2, 2, 2, 1\r\n      ];\r\n\r\n      DES.prototype.deriveKeys = function deriveKeys(state, key) {\r\n        state.keys = new Array(16 * 2);\r\n\r\n        assert.equal(key.length, this.blockSize, 'Invalid key length');\r\n\r\n        var kL = utils.readUInt32BE(key, 0);\r\n        var kR = utils.readUInt32BE(key, 4);\r\n\r\n        utils.pc1(kL, kR, state.tmp, 0);\r\n        kL = state.tmp[0];\r\n        kR = state.tmp[1];\r\n        for (var i = 0; i < state.keys.length; i += 2) {\r\n          var shift = shiftTable[i >>> 1];\r\n          kL = utils.r28shl(kL, shift);\r\n          kR = utils.r28shl(kR, shift);\r\n          utils.pc2(kL, kR, state.keys, i);\r\n        }\r\n      };\r\n\r\n      DES.prototype._update = function _update(inp, inOff, out, outOff) {\r\n        var state = this._desState;\r\n\r\n        var l = utils.readUInt32BE(inp, inOff);\r\n        var r = utils.readUInt32BE(inp, inOff + 4);\r\n\r\n        // Initial Permutation\r\n        utils.ip(l, r, state.tmp, 0);\r\n        l = state.tmp[0];\r\n        r = state.tmp[1];\r\n\r\n        if (this.type === 'encrypt')\r\n          this._encrypt(state, l, r, state.tmp, 0);\r\n        else\r\n          this._decrypt(state, l, r, state.tmp, 0);\r\n\r\n        l = state.tmp[0];\r\n        r = state.tmp[1];\r\n\r\n        utils.writeUInt32BE(out, l, outOff);\r\n        utils.writeUInt32BE(out, r, outOff + 4);\r\n      };\r\n\r\n      DES.prototype._pad = function _pad(buffer, off) {\r\n        var value = buffer.length - off;\r\n        for (var i = off; i < buffer.length; i++)\r\n          buffer[i] = value;\r\n\r\n        return true;\r\n      };\r\n\r\n      DES.prototype._unpad = function _unpad(buffer) {\r\n        var pad = buffer[buffer.length - 1];\r\n        for (var i = buffer.length - pad; i < buffer.length; i++)\r\n          assert.equal(buffer[i], pad);\r\n\r\n        return buffer.slice(0, buffer.length - pad);\r\n      };\r\n\r\n      DES.prototype._encrypt = function _encrypt(state, lStart, rStart, out, off) {\r\n        var l = lStart;\r\n        var r = rStart;\r\n\r\n        // Apply f() x16 times\r\n        for (var i = 0; i < state.keys.length; i += 2) {\r\n          var keyL = state.keys[i];\r\n          var keyR = state.keys[i + 1];\r\n\r\n          // f(r, k)\r\n          utils.expand(r, state.tmp, 0);\r\n\r\n          keyL ^= state.tmp[0];\r\n          keyR ^= state.tmp[1];\r\n          var s = utils.substitute(keyL, keyR);\r\n          var f = utils.permute(s);\r\n\r\n          var t = r;\r\n          r = (l ^ f) >>> 0;\r\n          l = t;\r\n        }\r\n\r\n        // Reverse Initial Permutation\r\n        utils.rip(r, l, out, off);\r\n      };\r\n\r\n      DES.prototype._decrypt = function _decrypt(state, lStart, rStart, out, off) {\r\n        var l = rStart;\r\n        var r = lStart;\r\n\r\n        // Apply f() x16 times\r\n        for (var i = state.keys.length - 2; i >= 0; i -= 2) {\r\n          var keyL = state.keys[i];\r\n          var keyR = state.keys[i + 1];\r\n\r\n          // f(r, k)\r\n          utils.expand(l, state.tmp, 0);\r\n\r\n          keyL ^= state.tmp[0];\r\n          keyR ^= state.tmp[1];\r\n          var s = utils.substitute(keyL, keyR);\r\n          var f = utils.permute(s);\r\n\r\n          var t = l;\r\n          l = (r ^ f) >>> 0;\r\n          r = t;\r\n        }\r\n\r\n        // Reverse Initial Permutation\r\n        utils.rip(l, r, out, off);\r\n      };\r\n\r\n    }, {\r\n      \"../des\": 63,\r\n      \"inherits\": 106,\r\n      \"minimalistic-assert\": 111\r\n    }],\r\n    67: [function (require, module, exports) {\r\n      'use strict';\r\n\r\n      var assert = require('minimalistic-assert');\r\n      var inherits = require('inherits');\r\n\r\n      var des = require('../des');\r\n      var Cipher = des.Cipher;\r\n      var DES = des.DES;\r\n\r\n      function EDEState(type, key) {\r\n        assert.equal(key.length, 24, 'Invalid key length');\r\n\r\n        var k1 = key.slice(0, 8);\r\n        var k2 = key.slice(8, 16);\r\n        var k3 = key.slice(16, 24);\r\n\r\n        if (type === 'encrypt') {\r\n          this.ciphers = [\r\n            DES.create({\r\n              type: 'encrypt',\r\n              key: k1\r\n            }),\r\n            DES.create({\r\n              type: 'decrypt',\r\n              key: k2\r\n            }),\r\n            DES.create({\r\n              type: 'encrypt',\r\n              key: k3\r\n            })\r\n          ];\r\n        } else {\r\n          this.ciphers = [\r\n            DES.create({\r\n              type: 'decrypt',\r\n              key: k3\r\n            }),\r\n            DES.create({\r\n              type: 'encrypt',\r\n              key: k2\r\n            }),\r\n            DES.create({\r\n              type: 'decrypt',\r\n              key: k1\r\n            })\r\n          ];\r\n        }\r\n      }\r\n\r\n      function EDE(options) {\r\n        Cipher.call(this, options);\r\n\r\n        var state = new EDEState(this.type, this.options.key);\r\n        this._edeState = state;\r\n      }\r\n      inherits(EDE, Cipher);\r\n\r\n      module.exports = EDE;\r\n\r\n      EDE.create = function create(options) {\r\n        return new EDE(options);\r\n      };\r\n\r\n      EDE.prototype._update = function _update(inp, inOff, out, outOff) {\r\n        var state = this._edeState;\r\n\r\n        state.ciphers[0]._update(inp, inOff, out, outOff);\r\n        state.ciphers[1]._update(out, outOff, out, outOff);\r\n        state.ciphers[2]._update(out, outOff, out, outOff);\r\n      };\r\n\r\n      EDE.prototype._pad = DES.prototype._pad;\r\n      EDE.prototype._unpad = DES.prototype._unpad;\r\n\r\n    }, {\r\n      \"../des\": 63,\r\n      \"inherits\": 106,\r\n      \"minimalistic-assert\": 111\r\n    }],\r\n    68: [function (require, module, exports) {\r\n      'use strict';\r\n\r\n      exports.readUInt32BE = function readUInt32BE(bytes, off) {\r\n        var res = (bytes[0 + off] << 24) |\r\n          (bytes[1 + off] << 16) |\r\n          (bytes[2 + off] << 8) |\r\n          bytes[3 + off];\r\n        return res >>> 0;\r\n      };\r\n\r\n      exports.writeUInt32BE = function writeUInt32BE(bytes, value, off) {\r\n        bytes[0 + off] = value >>> 24;\r\n        bytes[1 + off] = (value >>> 16) & 0xff;\r\n        bytes[2 + off] = (value >>> 8) & 0xff;\r\n        bytes[3 + off] = value & 0xff;\r\n      };\r\n\r\n      exports.ip = function ip(inL, inR, out, off) {\r\n        var outL = 0;\r\n        var outR = 0;\r\n\r\n        for (var i = 6; i >= 0; i -= 2) {\r\n          for (var j = 0; j <= 24; j += 8) {\r\n            outL <<= 1;\r\n            outL |= (inR >>> (j + i)) & 1;\r\n          }\r\n          for (var j = 0; j <= 24; j += 8) {\r\n            outL <<= 1;\r\n            outL |= (inL >>> (j + i)) & 1;\r\n          }\r\n        }\r\n\r\n        for (var i = 6; i >= 0; i -= 2) {\r\n          for (var j = 1; j <= 25; j += 8) {\r\n            outR <<= 1;\r\n            outR |= (inR >>> (j + i)) & 1;\r\n          }\r\n          for (var j = 1; j <= 25; j += 8) {\r\n            outR <<= 1;\r\n            outR |= (inL >>> (j + i)) & 1;\r\n          }\r\n        }\r\n\r\n        out[off + 0] = outL >>> 0;\r\n        out[off + 1] = outR >>> 0;\r\n      };\r\n\r\n      exports.rip = function rip(inL, inR, out, off) {\r\n        var outL = 0;\r\n        var outR = 0;\r\n\r\n        for (var i = 0; i < 4; i++) {\r\n          for (var j = 24; j >= 0; j -= 8) {\r\n            outL <<= 1;\r\n            outL |= (inR >>> (j + i)) & 1;\r\n            outL <<= 1;\r\n            outL |= (inL >>> (j + i)) & 1;\r\n          }\r\n        }\r\n        for (var i = 4; i < 8; i++) {\r\n          for (var j = 24; j >= 0; j -= 8) {\r\n            outR <<= 1;\r\n            outR |= (inR >>> (j + i)) & 1;\r\n            outR <<= 1;\r\n            outR |= (inL >>> (j + i)) & 1;\r\n          }\r\n        }\r\n\r\n        out[off + 0] = outL >>> 0;\r\n        out[off + 1] = outR >>> 0;\r\n      };\r\n\r\n      exports.pc1 = function pc1(inL, inR, out, off) {\r\n        var outL = 0;\r\n        var outR = 0;\r\n\r\n        // 7, 15, 23, 31, 39, 47, 55, 63\r\n        // 6, 14, 22, 30, 39, 47, 55, 63\r\n        // 5, 13, 21, 29, 39, 47, 55, 63\r\n        // 4, 12, 20, 28\r\n        for (var i = 7; i >= 5; i--) {\r\n          for (var j = 0; j <= 24; j += 8) {\r\n            outL <<= 1;\r\n            outL |= (inR >> (j + i)) & 1;\r\n          }\r\n          for (var j = 0; j <= 24; j += 8) {\r\n            outL <<= 1;\r\n            outL |= (inL >> (j + i)) & 1;\r\n          }\r\n        }\r\n        for (var j = 0; j <= 24; j += 8) {\r\n          outL <<= 1;\r\n          outL |= (inR >> (j + i)) & 1;\r\n        }\r\n\r\n        // 1, 9, 17, 25, 33, 41, 49, 57\r\n        // 2, 10, 18, 26, 34, 42, 50, 58\r\n        // 3, 11, 19, 27, 35, 43, 51, 59\r\n        // 36, 44, 52, 60\r\n        for (var i = 1; i <= 3; i++) {\r\n          for (var j = 0; j <= 24; j += 8) {\r\n            outR <<= 1;\r\n            outR |= (inR >> (j + i)) & 1;\r\n          }\r\n          for (var j = 0; j <= 24; j += 8) {\r\n            outR <<= 1;\r\n            outR |= (inL >> (j + i)) & 1;\r\n          }\r\n        }\r\n        for (var j = 0; j <= 24; j += 8) {\r\n          outR <<= 1;\r\n          outR |= (inL >> (j + i)) & 1;\r\n        }\r\n\r\n        out[off + 0] = outL >>> 0;\r\n        out[off + 1] = outR >>> 0;\r\n      };\r\n\r\n      exports.r28shl = function r28shl(num, shift) {\r\n        return ((num << shift) & 0xfffffff) | (num >>> (28 - shift));\r\n      };\r\n\r\n      var pc2table = [\r\n        // inL => outL\r\n        14, 11, 17, 4, 27, 23, 25, 0,\r\n        13, 22, 7, 18, 5, 9, 16, 24,\r\n        2, 20, 12, 21, 1, 8, 15, 26,\r\n\r\n        // inR => outR\r\n        15, 4, 25, 19, 9, 1, 26, 16,\r\n        5, 11, 23, 8, 12, 7, 17, 0,\r\n        22, 3, 10, 14, 6, 20, 27, 24\r\n      ];\r\n\r\n      exports.pc2 = function pc2(inL, inR, out, off) {\r\n        var outL = 0;\r\n        var outR = 0;\r\n\r\n        var len = pc2table.length >>> 1;\r\n        for (var i = 0; i < len; i++) {\r\n          outL <<= 1;\r\n          outL |= (inL >>> pc2table[i]) & 0x1;\r\n        }\r\n        for (var i = len; i < pc2table.length; i++) {\r\n          outR <<= 1;\r\n          outR |= (inR >>> pc2table[i]) & 0x1;\r\n        }\r\n\r\n        out[off + 0] = outL >>> 0;\r\n        out[off + 1] = outR >>> 0;\r\n      };\r\n\r\n      exports.expand = function expand(r, out, off) {\r\n        var outL = 0;\r\n        var outR = 0;\r\n\r\n        outL = ((r & 1) << 5) | (r >>> 27);\r\n        for (var i = 23; i >= 15; i -= 4) {\r\n          outL <<= 6;\r\n          outL |= (r >>> i) & 0x3f;\r\n        }\r\n        for (var i = 11; i >= 3; i -= 4) {\r\n          outR |= (r >>> i) & 0x3f;\r\n          outR <<= 6;\r\n        }\r\n        outR |= ((r & 0x1f) << 1) | (r >>> 31);\r\n\r\n        out[off + 0] = outL >>> 0;\r\n        out[off + 1] = outR >>> 0;\r\n      };\r\n\r\n      var sTable = [\r\n        14, 0, 4, 15, 13, 7, 1, 4, 2, 14, 15, 2, 11, 13, 8, 1,\r\n        3, 10, 10, 6, 6, 12, 12, 11, 5, 9, 9, 5, 0, 3, 7, 8,\r\n        4, 15, 1, 12, 14, 8, 8, 2, 13, 4, 6, 9, 2, 1, 11, 7,\r\n        15, 5, 12, 11, 9, 3, 7, 14, 3, 10, 10, 0, 5, 6, 0, 13,\r\n\r\n        15, 3, 1, 13, 8, 4, 14, 7, 6, 15, 11, 2, 3, 8, 4, 14,\r\n        9, 12, 7, 0, 2, 1, 13, 10, 12, 6, 0, 9, 5, 11, 10, 5,\r\n        0, 13, 14, 8, 7, 10, 11, 1, 10, 3, 4, 15, 13, 4, 1, 2,\r\n        5, 11, 8, 6, 12, 7, 6, 12, 9, 0, 3, 5, 2, 14, 15, 9,\r\n\r\n        10, 13, 0, 7, 9, 0, 14, 9, 6, 3, 3, 4, 15, 6, 5, 10,\r\n        1, 2, 13, 8, 12, 5, 7, 14, 11, 12, 4, 11, 2, 15, 8, 1,\r\n        13, 1, 6, 10, 4, 13, 9, 0, 8, 6, 15, 9, 3, 8, 0, 7,\r\n        11, 4, 1, 15, 2, 14, 12, 3, 5, 11, 10, 5, 14, 2, 7, 12,\r\n\r\n        7, 13, 13, 8, 14, 11, 3, 5, 0, 6, 6, 15, 9, 0, 10, 3,\r\n        1, 4, 2, 7, 8, 2, 5, 12, 11, 1, 12, 10, 4, 14, 15, 9,\r\n        10, 3, 6, 15, 9, 0, 0, 6, 12, 10, 11, 1, 7, 13, 13, 8,\r\n        15, 9, 1, 4, 3, 5, 14, 11, 5, 12, 2, 7, 8, 2, 4, 14,\r\n\r\n        2, 14, 12, 11, 4, 2, 1, 12, 7, 4, 10, 7, 11, 13, 6, 1,\r\n        8, 5, 5, 0, 3, 15, 15, 10, 13, 3, 0, 9, 14, 8, 9, 6,\r\n        4, 11, 2, 8, 1, 12, 11, 7, 10, 1, 13, 14, 7, 2, 8, 13,\r\n        15, 6, 9, 15, 12, 0, 5, 9, 6, 10, 3, 4, 0, 5, 14, 3,\r\n\r\n        12, 10, 1, 15, 10, 4, 15, 2, 9, 7, 2, 12, 6, 9, 8, 5,\r\n        0, 6, 13, 1, 3, 13, 4, 14, 14, 0, 7, 11, 5, 3, 11, 8,\r\n        9, 4, 14, 3, 15, 2, 5, 12, 2, 9, 8, 5, 12, 15, 3, 10,\r\n        7, 11, 0, 14, 4, 1, 10, 7, 1, 6, 13, 0, 11, 8, 6, 13,\r\n\r\n        4, 13, 11, 0, 2, 11, 14, 7, 15, 4, 0, 9, 8, 1, 13, 10,\r\n        3, 14, 12, 3, 9, 5, 7, 12, 5, 2, 10, 15, 6, 8, 1, 6,\r\n        1, 6, 4, 11, 11, 13, 13, 8, 12, 1, 3, 4, 7, 10, 14, 7,\r\n        10, 9, 15, 5, 6, 0, 8, 15, 0, 14, 5, 2, 9, 3, 2, 12,\r\n\r\n        13, 1, 2, 15, 8, 13, 4, 8, 6, 10, 15, 3, 11, 7, 1, 4,\r\n        10, 12, 9, 5, 3, 6, 14, 11, 5, 0, 0, 14, 12, 9, 7, 2,\r\n        7, 2, 11, 1, 4, 14, 1, 7, 9, 4, 12, 10, 14, 8, 2, 13,\r\n        0, 15, 6, 12, 10, 9, 13, 0, 15, 3, 3, 5, 5, 6, 8, 11\r\n      ];\r\n\r\n      exports.substitute = function substitute(inL, inR) {\r\n        var out = 0;\r\n        for (var i = 0; i < 4; i++) {\r\n          var b = (inL >>> (18 - i * 6)) & 0x3f;\r\n          var sb = sTable[i * 0x40 + b];\r\n\r\n          out <<= 4;\r\n          out |= sb;\r\n        }\r\n        for (var i = 0; i < 4; i++) {\r\n          var b = (inR >>> (18 - i * 6)) & 0x3f;\r\n          var sb = sTable[4 * 0x40 + i * 0x40 + b];\r\n\r\n          out <<= 4;\r\n          out |= sb;\r\n        }\r\n        return out >>> 0;\r\n      };\r\n\r\n      var permuteTable = [\r\n        16, 25, 12, 11, 3, 20, 4, 15, 31, 17, 9, 6, 27, 14, 1, 22,\r\n        30, 24, 8, 18, 0, 5, 29, 23, 13, 19, 2, 26, 10, 21, 28, 7\r\n      ];\r\n\r\n      exports.permute = function permute(num) {\r\n        var out = 0;\r\n        for (var i = 0; i < permuteTable.length; i++) {\r\n          out <<= 1;\r\n          out |= (num >>> permuteTable[i]) & 0x1;\r\n        }\r\n        return out >>> 0;\r\n      };\r\n\r\n      exports.padSplit = function padSplit(num, size, group) {\r\n        var str = num.toString(2);\r\n        while (str.length < size)\r\n          str = '0' + str;\r\n\r\n        var out = [];\r\n        for (var i = 0; i < size; i += group)\r\n          out.push(str.slice(i, i + group));\r\n        return out.join(' ');\r\n      };\r\n\r\n    }, {}],\r\n    69: [function (require, module, exports) {\r\n      (function (Buffer) {\r\n        var generatePrime = require('./lib/generatePrime')\r\n        var primes = require('./lib/primes.json')\r\n\r\n        var DH = require('./lib/dh')\r\n\r\n        function getDiffieHellman(mod) {\r\n          var prime = new Buffer(primes[mod].prime, 'hex')\r\n          var gen = new Buffer(primes[mod].gen, 'hex')\r\n\r\n          return new DH(prime, gen)\r\n        }\r\n\r\n        var ENCODINGS = {\r\n          'binary': true,\r\n          'hex': true,\r\n          'base64': true\r\n        }\r\n\r\n        function createDiffieHellman(prime, enc, generator, genc) {\r\n          if (Buffer.isBuffer(enc) || ENCODINGS[enc] === undefined) {\r\n            return createDiffieHellman(prime, 'binary', enc, generator)\r\n          }\r\n\r\n          enc = enc || 'binary'\r\n          genc = genc || 'binary'\r\n          generator = generator || new Buffer([2])\r\n\r\n          if (!Buffer.isBuffer(generator)) {\r\n            generator = new Buffer(generator, genc)\r\n          }\r\n\r\n          if (typeof prime === 'number') {\r\n            return new DH(generatePrime(prime, generator), generator, true)\r\n          }\r\n\r\n          if (!Buffer.isBuffer(prime)) {\r\n            prime = new Buffer(prime, enc)\r\n          }\r\n\r\n          return new DH(prime, generator, true)\r\n        }\r\n\r\n        exports.DiffieHellmanGroup = exports.createDiffieHellmanGroup = exports.getDiffieHellman = getDiffieHellman\r\n        exports.createDiffieHellman = exports.DiffieHellman = createDiffieHellman\r\n\r\n      }).call(this, require(\"buffer\").Buffer)\r\n    }, {\r\n      \"./lib/dh\": 70,\r\n      \"./lib/generatePrime\": 71,\r\n      \"./lib/primes.json\": 72,\r\n      \"buffer\": 54\r\n    }],\r\n    70: [function (require, module, exports) {\r\n      (function (Buffer) {\r\n        var BN = require('bn.js');\r\n        var MillerRabin = require('miller-rabin');\r\n        var millerRabin = new MillerRabin();\r\n        var TWENTYFOUR = new BN(24);\r\n        var ELEVEN = new BN(11);\r\n        var TEN = new BN(10);\r\n        var THREE = new BN(3);\r\n        var SEVEN = new BN(7);\r\n        var primes = require('./generatePrime');\r\n        var randomBytes = require('randombytes');\r\n        module.exports = DH;\r\n\r\n        function setPublicKey(pub, enc) {\r\n          enc = enc || 'utf8';\r\n          if (!Buffer.isBuffer(pub)) {\r\n            pub = new Buffer(pub, enc);\r\n          }\r\n          this._pub = new BN(pub);\r\n          return this;\r\n        }\r\n\r\n        function setPrivateKey(priv, enc) {\r\n          enc = enc || 'utf8';\r\n          if (!Buffer.isBuffer(priv)) {\r\n            priv = new Buffer(priv, enc);\r\n          }\r\n          this._priv = new BN(priv);\r\n          return this;\r\n        }\r\n\r\n        var primeCache = {};\r\n\r\n        function checkPrime(prime, generator) {\r\n          var gen = generator.toString('hex');\r\n          var hex = [gen, prime.toString(16)].join('_');\r\n          if (hex in primeCache) {\r\n            return primeCache[hex];\r\n          }\r\n          var error = 0;\r\n\r\n          if (prime.isEven() ||\r\n            !primes.simpleSieve ||\r\n            !primes.fermatTest(prime) ||\r\n            !millerRabin.test(prime)) {\r\n            //not a prime so +1\r\n            error += 1;\r\n\r\n            if (gen === '02' || gen === '05') {\r\n              // we'd be able to check the generator\r\n              // it would fail so +8\r\n              error += 8;\r\n            } else {\r\n              //we wouldn't be able to test the generator\r\n              // so +4\r\n              error += 4;\r\n            }\r\n            primeCache[hex] = error;\r\n            return error;\r\n          }\r\n          if (!millerRabin.test(prime.shrn(1))) {\r\n            //not a safe prime\r\n            error += 2;\r\n          }\r\n          var rem;\r\n          switch (gen) {\r\n            case '02':\r\n              if (prime.mod(TWENTYFOUR).cmp(ELEVEN)) {\r\n                // unsuidable generator\r\n                error += 8;\r\n              }\r\n              break;\r\n            case '05':\r\n              rem = prime.mod(TEN);\r\n              if (rem.cmp(THREE) && rem.cmp(SEVEN)) {\r\n                // prime mod 10 needs to equal 3 or 7\r\n                error += 8;\r\n              }\r\n              break;\r\n            default:\r\n              error += 4;\r\n          }\r\n          primeCache[hex] = error;\r\n          return error;\r\n        }\r\n\r\n        function DH(prime, generator, malleable) {\r\n          this.setGenerator(generator);\r\n          this.__prime = new BN(prime);\r\n          this._prime = BN.mont(this.__prime);\r\n          this._primeLen = prime.length;\r\n          this._pub = undefined;\r\n          this._priv = undefined;\r\n          this._primeCode = undefined;\r\n          if (malleable) {\r\n            this.setPublicKey = setPublicKey;\r\n            this.setPrivateKey = setPrivateKey;\r\n          } else {\r\n            this._primeCode = 8;\r\n          }\r\n        }\r\n        Object.defineProperty(DH.prototype, 'verifyError', {\r\n          enumerable: true,\r\n          get: function () {\r\n            if (typeof this._primeCode !== 'number') {\r\n              this._primeCode = checkPrime(this.__prime, this.__gen);\r\n            }\r\n            return this._primeCode;\r\n          }\r\n        });\r\n        DH.prototype.generateKeys = function () {\r\n          if (!this._priv) {\r\n            this._priv = new BN(randomBytes(this._primeLen));\r\n          }\r\n          this._pub = this._gen.toRed(this._prime).redPow(this._priv).fromRed();\r\n          return this.getPublicKey();\r\n        };\r\n\r\n        DH.prototype.computeSecret = function (other) {\r\n          other = new BN(other);\r\n          other = other.toRed(this._prime);\r\n          var secret = other.redPow(this._priv).fromRed();\r\n          var out = new Buffer(secret.toArray());\r\n          var prime = this.getPrime();\r\n          if (out.length < prime.length) {\r\n            var front = new Buffer(prime.length - out.length);\r\n            front.fill(0);\r\n            out = Buffer.concat([front, out]);\r\n          }\r\n          return out;\r\n        };\r\n\r\n        DH.prototype.getPublicKey = function getPublicKey(enc) {\r\n          return formatReturnValue(this._pub, enc);\r\n        };\r\n\r\n        DH.prototype.getPrivateKey = function getPrivateKey(enc) {\r\n          return formatReturnValue(this._priv, enc);\r\n        };\r\n\r\n        DH.prototype.getPrime = function (enc) {\r\n          return formatReturnValue(this.__prime, enc);\r\n        };\r\n\r\n        DH.prototype.getGenerator = function (enc) {\r\n          return formatReturnValue(this._gen, enc);\r\n        };\r\n\r\n        DH.prototype.setGenerator = function (gen, enc) {\r\n          enc = enc || 'utf8';\r\n          if (!Buffer.isBuffer(gen)) {\r\n            gen = new Buffer(gen, enc);\r\n          }\r\n          this.__gen = gen;\r\n          this._gen = new BN(gen);\r\n          return this;\r\n        };\r\n\r\n        function formatReturnValue(bn, enc) {\r\n          var buf = new Buffer(bn.toArray());\r\n          if (!enc) {\r\n            return buf;\r\n          } else {\r\n            return buf.toString(enc);\r\n          }\r\n        }\r\n\r\n      }).call(this, require(\"buffer\").Buffer)\r\n    }, {\r\n      \"./generatePrime\": 71,\r\n      \"bn.js\": 23,\r\n      \"buffer\": 54,\r\n      \"miller-rabin\": 110,\r\n      \"randombytes\": 131\r\n    }],\r\n    71: [function (require, module, exports) {\r\n      var randomBytes = require('randombytes');\r\n      module.exports = findPrime;\r\n      findPrime.simpleSieve = simpleSieve;\r\n      findPrime.fermatTest = fermatTest;\r\n      var BN = require('bn.js');\r\n      var TWENTYFOUR = new BN(24);\r\n      var MillerRabin = require('miller-rabin');\r\n      var millerRabin = new MillerRabin();\r\n      var ONE = new BN(1);\r\n      var TWO = new BN(2);\r\n      var FIVE = new BN(5);\r\n      var SIXTEEN = new BN(16);\r\n      var EIGHT = new BN(8);\r\n      var TEN = new BN(10);\r\n      var THREE = new BN(3);\r\n      var SEVEN = new BN(7);\r\n      var ELEVEN = new BN(11);\r\n      var FOUR = new BN(4);\r\n      var TWELVE = new BN(12);\r\n      var primes = null;\r\n\r\n      function _getPrimes() {\r\n        if (primes !== null)\r\n          return primes;\r\n\r\n        var limit = 0x100000;\r\n        var res = [];\r\n        res[0] = 2;\r\n        for (var i = 1, k = 3; k < limit; k += 2) {\r\n          var sqrt = Math.ceil(Math.sqrt(k));\r\n          for (var j = 0; j < i && res[j] <= sqrt; j++)\r\n            if (k % res[j] === 0)\r\n              break;\r\n\r\n          if (i !== j && res[j] <= sqrt)\r\n            continue;\r\n\r\n          res[i++] = k;\r\n        }\r\n        primes = res;\r\n        return res;\r\n      }\r\n\r\n      function simpleSieve(p) {\r\n        var primes = _getPrimes();\r\n\r\n        for (var i = 0; i < primes.length; i++)\r\n          if (p.modn(primes[i]) === 0) {\r\n            if (p.cmpn(primes[i]) === 0) {\r\n              return true;\r\n            } else {\r\n              return false;\r\n            }\r\n          }\r\n\r\n        return true;\r\n      }\r\n\r\n      function fermatTest(p) {\r\n        var red = BN.mont(p);\r\n        return TWO.toRed(red).redPow(p.subn(1)).fromRed().cmpn(1) === 0;\r\n      }\r\n\r\n      function findPrime(bits, gen) {\r\n        if (bits < 16) {\r\n          // this is what openssl does\r\n          if (gen === 2 || gen === 5) {\r\n            return new BN([0x8c, 0x7b]);\r\n          } else {\r\n            return new BN([0x8c, 0x27]);\r\n          }\r\n        }\r\n        gen = new BN(gen);\r\n\r\n        var num, n2;\r\n\r\n        while (true) {\r\n          num = new BN(randomBytes(Math.ceil(bits / 8)));\r\n          while (num.bitLength() > bits) {\r\n            num.ishrn(1);\r\n          }\r\n          if (num.isEven()) {\r\n            num.iadd(ONE);\r\n          }\r\n          if (!num.testn(1)) {\r\n            num.iadd(TWO);\r\n          }\r\n          if (!gen.cmp(TWO)) {\r\n            while (num.mod(TWENTYFOUR).cmp(ELEVEN)) {\r\n              num.iadd(FOUR);\r\n            }\r\n          } else if (!gen.cmp(FIVE)) {\r\n            while (num.mod(TEN).cmp(THREE)) {\r\n              num.iadd(FOUR);\r\n            }\r\n          }\r\n          n2 = num.shrn(1);\r\n          if (simpleSieve(n2) && simpleSieve(num) &&\r\n            fermatTest(n2) && fermatTest(num) &&\r\n            millerRabin.test(n2) && millerRabin.test(num)) {\r\n            return num;\r\n          }\r\n        }\r\n\r\n      }\r\n\r\n    }, {\r\n      \"bn.js\": 23,\r\n      \"miller-rabin\": 110,\r\n      \"randombytes\": 131\r\n    }],\r\n    72: [function (require, module, exports) {\r\n      module.exports = {\r\n        \"modp1\": {\r\n          \"gen\": \"02\",\r\n          \"prime\": \"ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a63a3620ffffffffffffffff\"\r\n        },\r\n        \"modp2\": {\r\n          \"gen\": \"02\",\r\n          \"prime\": \"ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece65381ffffffffffffffff\"\r\n        },\r\n        \"modp5\": {\r\n          \"gen\": \"02\",\r\n          \"prime\": \"ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca237327ffffffffffffffff\"\r\n        },\r\n        \"modp14\": {\r\n          \"gen\": \"02\",\r\n          \"prime\": \"ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aacaa68ffffffffffffffff\"\r\n        },\r\n        \"modp15\": {\r\n          \"gen\": \"02\",\r\n          \"prime\": \"ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aaac42dad33170d04507a33a85521abdf1cba64ecfb850458dbef0a8aea71575d060c7db3970f85a6e1e4c7abf5ae8cdb0933d71e8c94e04a25619dcee3d2261ad2ee6bf12ffa06d98a0864d87602733ec86a64521f2b18177b200cbbe117577a615d6c770988c0bad946e208e24fa074e5ab3143db5bfce0fd108e4b82d120a93ad2caffffffffffffffff\"\r\n        },\r\n        \"modp16\": {\r\n          \"gen\": \"02\",\r\n          \"prime\": \"ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aaac42dad33170d04507a33a85521abdf1cba64ecfb850458dbef0a8aea71575d060c7db3970f85a6e1e4c7abf5ae8cdb0933d71e8c94e04a25619dcee3d2261ad2ee6bf12ffa06d98a0864d87602733ec86a64521f2b18177b200cbbe117577a615d6c770988c0bad946e208e24fa074e5ab3143db5bfce0fd108e4b82d120a92108011a723c12a787e6d788719a10bdba5b2699c327186af4e23c1a946834b6150bda2583e9ca2ad44ce8dbbbc2db04de8ef92e8efc141fbecaa6287c59474e6bc05d99b2964fa090c3a2233ba186515be7ed1f612970cee2d7afb81bdd762170481cd0069127d5b05aa993b4ea988d8fddc186ffb7dc90a6c08f4df435c934063199ffffffffffffffff\"\r\n        },\r\n        \"modp17\": {\r\n          \"gen\": \"02\",\r\n          \"prime\": \"ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aaac42dad33170d04507a33a85521abdf1cba64ecfb850458dbef0a8aea71575d060c7db3970f85a6e1e4c7abf5ae8cdb0933d71e8c94e04a25619dcee3d2261ad2ee6bf12ffa06d98a0864d87602733ec86a64521f2b18177b200cbbe117577a615d6c770988c0bad946e208e24fa074e5ab3143db5bfce0fd108e4b82d120a92108011a723c12a787e6d788719a10bdba5b2699c327186af4e23c1a946834b6150bda2583e9ca2ad44ce8dbbbc2db04de8ef92e8efc141fbecaa6287c59474e6bc05d99b2964fa090c3a2233ba186515be7ed1f612970cee2d7afb81bdd762170481cd0069127d5b05aa993b4ea988d8fddc186ffb7dc90a6c08f4df435c93402849236c3fab4d27c7026c1d4dcb2602646dec9751e763dba37bdf8ff9406ad9e530ee5db382f413001aeb06a53ed9027d831179727b0865a8918da3edbebcf9b14ed44ce6cbaced4bb1bdb7f1447e6cc254b332051512bd7af426fb8f401378cd2bf5983ca01c64b92ecf032ea15d1721d03f482d7ce6e74fef6d55e702f46980c82b5a84031900b1c9e59e7c97fbec7e8f323a97a7e36cc88be0f1d45b7ff585ac54bd407b22b4154aacc8f6d7ebf48e1d814cc5ed20f8037e0a79715eef29be32806a1d58bb7c5da76f550aa3d8a1fbff0eb19ccb1a313d55cda56c9ec2ef29632387fe8d76e3c0468043e8f663f4860ee12bf2d5b0b7474d6e694f91e6dcc4024ffffffffffffffff\"\r\n        },\r\n        \"modp18\": {\r\n          \"gen\": \"02\",\r\n          \"prime\": \"ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aaac42dad33170d04507a33a85521abdf1cba64ecfb850458dbef0a8aea71575d060c7db3970f85a6e1e4c7abf5ae8cdb0933d71e8c94e04a25619dcee3d2261ad2ee6bf12ffa06d98a0864d87602733ec86a64521f2b18177b200cbbe117577a615d6c770988c0bad946e208e24fa074e5ab3143db5bfce0fd108e4b82d120a92108011a723c12a787e6d788719a10bdba5b2699c327186af4e23c1a946834b6150bda2583e9ca2ad44ce8dbbbc2db04de8ef92e8efc141fbecaa6287c59474e6bc05d99b2964fa090c3a2233ba186515be7ed1f612970cee2d7afb81bdd762170481cd0069127d5b05aa993b4ea988d8fddc186ffb7dc90a6c08f4df435c93402849236c3fab4d27c7026c1d4dcb2602646dec9751e763dba37bdf8ff9406ad9e530ee5db382f413001aeb06a53ed9027d831179727b0865a8918da3edbebcf9b14ed44ce6cbaced4bb1bdb7f1447e6cc254b332051512bd7af426fb8f401378cd2bf5983ca01c64b92ecf032ea15d1721d03f482d7ce6e74fef6d55e702f46980c82b5a84031900b1c9e59e7c97fbec7e8f323a97a7e36cc88be0f1d45b7ff585ac54bd407b22b4154aacc8f6d7ebf48e1d814cc5ed20f8037e0a79715eef29be32806a1d58bb7c5da76f550aa3d8a1fbff0eb19ccb1a313d55cda56c9ec2ef29632387fe8d76e3c0468043e8f663f4860ee12bf2d5b0b7474d6e694f91e6dbe115974a3926f12fee5e438777cb6a932df8cd8bec4d073b931ba3bc832b68d9dd300741fa7bf8afc47ed2576f6936ba424663aab639c5ae4f5683423b4742bf1c978238f16cbe39d652de3fdb8befc848ad922222e04a4037c0713eb57a81a23f0c73473fc646cea306b4bcbc8862f8385ddfa9d4b7fa2c087e879683303ed5bdd3a062b3cf5b3a278a66d2a13f83f44f82ddf310ee074ab6a364597e899a0255dc164f31cc50846851df9ab48195ded7ea1b1d510bd7ee74d73faf36bc31ecfa268359046f4eb879f924009438b481c6cd7889a002ed5ee382bc9190da6fc026e479558e4475677e9aa9e3050e2765694dfc81f56e880b96e7160c980dd98edd3dfffffffffffffffff\"\r\n        }\r\n      }\r\n    }, {}],\r\n    73: [function (require, module, exports) {\r\n      'use strict';\r\n\r\n      var elliptic = exports;\r\n\r\n      elliptic.version = require('../package.json').version;\r\n      elliptic.utils = require('./elliptic/utils');\r\n      elliptic.rand = require('brorand');\r\n      elliptic.curve = require('./elliptic/curve');\r\n      elliptic.curves = require('./elliptic/curves');\r\n\r\n      // Protocols\r\n      elliptic.ec = require('./elliptic/ec');\r\n      elliptic.eddsa = require('./elliptic/eddsa');\r\n\r\n    }, {\r\n      \"../package.json\": 88,\r\n      \"./elliptic/curve\": 76,\r\n      \"./elliptic/curves\": 79,\r\n      \"./elliptic/ec\": 80,\r\n      \"./elliptic/eddsa\": 83,\r\n      \"./elliptic/utils\": 87,\r\n      \"brorand\": 24\r\n    }],\r\n    74: [function (require, module, exports) {\r\n      'use strict';\r\n\r\n      var BN = require('bn.js');\r\n      var elliptic = require('../../elliptic');\r\n      var utils = elliptic.utils;\r\n      var getNAF = utils.getNAF;\r\n      var getJSF = utils.getJSF;\r\n      var assert = utils.assert;\r\n\r\n      function BaseCurve(type, conf) {\r\n        this.type = type;\r\n        this.p = new BN(conf.p, 16);\r\n\r\n        // Use Montgomery, when there is no fast reduction for the prime\r\n        this.red = conf.prime ? BN.red(conf.prime) : BN.mont(this.p);\r\n\r\n        // Useful for many curves\r\n        this.zero = new BN(0).toRed(this.red);\r\n        this.one = new BN(1).toRed(this.red);\r\n        this.two = new BN(2).toRed(this.red);\r\n\r\n        // Curve configuration, optional\r\n        this.n = conf.n && new BN(conf.n, 16);\r\n        this.g = conf.g && this.pointFromJSON(conf.g, conf.gRed);\r\n\r\n        // Temporary arrays\r\n        this._wnafT1 = new Array(4);\r\n        this._wnafT2 = new Array(4);\r\n        this._wnafT3 = new Array(4);\r\n        this._wnafT4 = new Array(4);\r\n\r\n        // Generalized Greg Maxwell's trick\r\n        var adjustCount = this.n && this.p.div(this.n);\r\n        if (!adjustCount || adjustCount.cmpn(100) > 0) {\r\n          this.redN = null;\r\n        } else {\r\n          this._maxwellTrick = true;\r\n          this.redN = this.n.toRed(this.red);\r\n        }\r\n      }\r\n      module.exports = BaseCurve;\r\n\r\n      BaseCurve.prototype.point = function point() {\r\n        throw new Error('Not implemented');\r\n      };\r\n\r\n      BaseCurve.prototype.validate = function validate() {\r\n        throw new Error('Not implemented');\r\n      };\r\n\r\n      BaseCurve.prototype._fixedNafMul = function _fixedNafMul(p, k) {\r\n        assert(p.precomputed);\r\n        var doubles = p._getDoubles();\r\n\r\n        var naf = getNAF(k, 1);\r\n        var I = (1 << (doubles.step + 1)) - (doubles.step % 2 === 0 ? 2 : 1);\r\n        I /= 3;\r\n\r\n        // Translate into more windowed form\r\n        var repr = [];\r\n        for (var j = 0; j < naf.length; j += doubles.step) {\r\n          var nafW = 0;\r\n          for (var k = j + doubles.step - 1; k >= j; k--)\r\n            nafW = (nafW << 1) + naf[k];\r\n          repr.push(nafW);\r\n        }\r\n\r\n        var a = this.jpoint(null, null, null);\r\n        var b = this.jpoint(null, null, null);\r\n        for (var i = I; i > 0; i--) {\r\n          for (var j = 0; j < repr.length; j++) {\r\n            var nafW = repr[j];\r\n            if (nafW === i)\r\n              b = b.mixedAdd(doubles.points[j]);\r\n            else if (nafW === -i)\r\n              b = b.mixedAdd(doubles.points[j].neg());\r\n          }\r\n          a = a.add(b);\r\n        }\r\n        return a.toP();\r\n      };\r\n\r\n      BaseCurve.prototype._wnafMul = function _wnafMul(p, k) {\r\n        var w = 4;\r\n\r\n        // Precompute window\r\n        var nafPoints = p._getNAFPoints(w);\r\n        w = nafPoints.wnd;\r\n        var wnd = nafPoints.points;\r\n\r\n        // Get NAF form\r\n        var naf = getNAF(k, w);\r\n\r\n        // Add `this`*(N+1) for every w-NAF index\r\n        var acc = this.jpoint(null, null, null);\r\n        for (var i = naf.length - 1; i >= 0; i--) {\r\n          // Count zeroes\r\n          for (var k = 0; i >= 0 && naf[i] === 0; i--)\r\n            k++;\r\n          if (i >= 0)\r\n            k++;\r\n          acc = acc.dblp(k);\r\n\r\n          if (i < 0)\r\n            break;\r\n          var z = naf[i];\r\n          assert(z !== 0);\r\n          if (p.type === 'affine') {\r\n            // J +- P\r\n            if (z > 0)\r\n              acc = acc.mixedAdd(wnd[(z - 1) >> 1]);\r\n            else\r\n              acc = acc.mixedAdd(wnd[(-z - 1) >> 1].neg());\r\n          } else {\r\n            // J +- J\r\n            if (z > 0)\r\n              acc = acc.add(wnd[(z - 1) >> 1]);\r\n            else\r\n              acc = acc.add(wnd[(-z - 1) >> 1].neg());\r\n          }\r\n        }\r\n        return p.type === 'affine' ? acc.toP() : acc;\r\n      };\r\n\r\n      BaseCurve.prototype._wnafMulAdd = function _wnafMulAdd(defW,\r\n        points,\r\n        coeffs,\r\n        len,\r\n        jacobianResult) {\r\n        var wndWidth = this._wnafT1;\r\n        var wnd = this._wnafT2;\r\n        var naf = this._wnafT3;\r\n\r\n        // Fill all arrays\r\n        var max = 0;\r\n        for (var i = 0; i < len; i++) {\r\n          var p = points[i];\r\n          var nafPoints = p._getNAFPoints(defW);\r\n          wndWidth[i] = nafPoints.wnd;\r\n          wnd[i] = nafPoints.points;\r\n        }\r\n\r\n        // Comb small window NAFs\r\n        for (var i = len - 1; i >= 1; i -= 2) {\r\n          var a = i - 1;\r\n          var b = i;\r\n          if (wndWidth[a] !== 1 || wndWidth[b] !== 1) {\r\n            naf[a] = getNAF(coeffs[a], wndWidth[a]);\r\n            naf[b] = getNAF(coeffs[b], wndWidth[b]);\r\n            max = Math.max(naf[a].length, max);\r\n            max = Math.max(naf[b].length, max);\r\n            continue;\r\n          }\r\n\r\n          var comb = [\r\n            points[a], /* 1 */\r\n            null, /* 3 */\r\n            null, /* 5 */\r\n            points[b] /* 7 */\r\n          ];\r\n\r\n          // Try to avoid Projective points, if possible\r\n          if (points[a].y.cmp(points[b].y) === 0) {\r\n            comb[1] = points[a].add(points[b]);\r\n            comb[2] = points[a].toJ().mixedAdd(points[b].neg());\r\n          } else if (points[a].y.cmp(points[b].y.redNeg()) === 0) {\r\n            comb[1] = points[a].toJ().mixedAdd(points[b]);\r\n            comb[2] = points[a].add(points[b].neg());\r\n          } else {\r\n            comb[1] = points[a].toJ().mixedAdd(points[b]);\r\n            comb[2] = points[a].toJ().mixedAdd(points[b].neg());\r\n          }\r\n\r\n          var index = [\r\n            -3, /* -1 -1 */\r\n            -1, /* -1 0 */\r\n            -5, /* -1 1 */\r\n            -7, /* 0 -1 */\r\n            0, /* 0 0 */\r\n            7, /* 0 1 */\r\n            5, /* 1 -1 */\r\n            1, /* 1 0 */\r\n            3 /* 1 1 */\r\n          ];\r\n\r\n          var jsf = getJSF(coeffs[a], coeffs[b]);\r\n          max = Math.max(jsf[0].length, max);\r\n          naf[a] = new Array(max);\r\n          naf[b] = new Array(max);\r\n          for (var j = 0; j < max; j++) {\r\n            var ja = jsf[0][j] | 0;\r\n            var jb = jsf[1][j] | 0;\r\n\r\n            naf[a][j] = index[(ja + 1) * 3 + (jb + 1)];\r\n            naf[b][j] = 0;\r\n            wnd[a] = comb;\r\n          }\r\n        }\r\n\r\n        var acc = this.jpoint(null, null, null);\r\n        var tmp = this._wnafT4;\r\n        for (var i = max; i >= 0; i--) {\r\n          var k = 0;\r\n\r\n          while (i >= 0) {\r\n            var zero = true;\r\n            for (var j = 0; j < len; j++) {\r\n              tmp[j] = naf[j][i] | 0;\r\n              if (tmp[j] !== 0)\r\n                zero = false;\r\n            }\r\n            if (!zero)\r\n              break;\r\n            k++;\r\n            i--;\r\n          }\r\n          if (i >= 0)\r\n            k++;\r\n          acc = acc.dblp(k);\r\n          if (i < 0)\r\n            break;\r\n\r\n          for (var j = 0; j < len; j++) {\r\n            var z = tmp[j];\r\n            var p;\r\n            if (z === 0)\r\n              continue;\r\n            else if (z > 0)\r\n              p = wnd[j][(z - 1) >> 1];\r\n            else if (z < 0)\r\n              p = wnd[j][(-z - 1) >> 1].neg();\r\n\r\n            if (p.type === 'affine')\r\n              acc = acc.mixedAdd(p);\r\n            else\r\n              acc = acc.add(p);\r\n          }\r\n        }\r\n        // Zeroify references\r\n        for (var i = 0; i < len; i++)\r\n          wnd[i] = null;\r\n\r\n        if (jacobianResult)\r\n          return acc;\r\n        else\r\n          return acc.toP();\r\n      };\r\n\r\n      function BasePoint(curve, type) {\r\n        this.curve = curve;\r\n        this.type = type;\r\n        this.precomputed = null;\r\n      }\r\n      BaseCurve.BasePoint = BasePoint;\r\n\r\n      BasePoint.prototype.eq = function eq( /*other*/ ) {\r\n        throw new Error('Not implemented');\r\n      };\r\n\r\n      BasePoint.prototype.validate = function validate() {\r\n        return this.curve.validate(this);\r\n      };\r\n\r\n      BaseCurve.prototype.decodePoint = function decodePoint(bytes, enc) {\r\n        bytes = utils.toArray(bytes, enc);\r\n\r\n        var len = this.p.byteLength();\r\n\r\n        // uncompressed, hybrid-odd, hybrid-even\r\n        if ((bytes[0] === 0x04 || bytes[0] === 0x06 || bytes[0] === 0x07) &&\r\n          bytes.length - 1 === 2 * len) {\r\n          if (bytes[0] === 0x06)\r\n            assert(bytes[bytes.length - 1] % 2 === 0);\r\n          else if (bytes[0] === 0x07)\r\n            assert(bytes[bytes.length - 1] % 2 === 1);\r\n\r\n          var res = this.point(bytes.slice(1, 1 + len),\r\n            bytes.slice(1 + len, 1 + 2 * len));\r\n\r\n          return res;\r\n        } else if ((bytes[0] === 0x02 || bytes[0] === 0x03) &&\r\n          bytes.length - 1 === len) {\r\n          return this.pointFromX(bytes.slice(1, 1 + len), bytes[0] === 0x03);\r\n        }\r\n        throw new Error('Unknown point format');\r\n      };\r\n\r\n      BasePoint.prototype.encodeCompressed = function encodeCompressed(enc) {\r\n        return this.encode(enc, true);\r\n      };\r\n\r\n      BasePoint.prototype._encode = function _encode(compact) {\r\n        var len = this.curve.p.byteLength();\r\n        var x = this.getX().toArray('be', len);\r\n\r\n        if (compact)\r\n          return [this.getY().isEven() ? 0x02 : 0x03].concat(x);\r\n\r\n        return [0x04].concat(x, this.getY().toArray('be', len));\r\n      };\r\n\r\n      BasePoint.prototype.encode = function encode(enc, compact) {\r\n        return utils.encode(this._encode(compact), enc);\r\n      };\r\n\r\n      BasePoint.prototype.precompute = function precompute(power) {\r\n        if (this.precomputed)\r\n          return this;\r\n\r\n        var precomputed = {\r\n          doubles: null,\r\n          naf: null,\r\n          beta: null\r\n        };\r\n        precomputed.naf = this._getNAFPoints(8);\r\n        precomputed.doubles = this._getDoubles(4, power);\r\n        precomputed.beta = this._getBeta();\r\n        this.precomputed = precomputed;\r\n\r\n        return this;\r\n      };\r\n\r\n      BasePoint.prototype._hasDoubles = function _hasDoubles(k) {\r\n        if (!this.precomputed)\r\n          return false;\r\n\r\n        var doubles = this.precomputed.doubles;\r\n        if (!doubles)\r\n          return false;\r\n\r\n        return doubles.points.length >= Math.ceil((k.bitLength() + 1) / doubles.step);\r\n      };\r\n\r\n      BasePoint.prototype._getDoubles = function _getDoubles(step, power) {\r\n        if (this.precomputed && this.precomputed.doubles)\r\n          return this.precomputed.doubles;\r\n\r\n        var doubles = [this];\r\n        var acc = this;\r\n        for (var i = 0; i < power; i += step) {\r\n          for (var j = 0; j < step; j++)\r\n            acc = acc.dbl();\r\n          doubles.push(acc);\r\n        }\r\n        return {\r\n          step: step,\r\n          points: doubles\r\n        };\r\n      };\r\n\r\n      BasePoint.prototype._getNAFPoints = function _getNAFPoints(wnd) {\r\n        if (this.precomputed && this.precomputed.naf)\r\n          return this.precomputed.naf;\r\n\r\n        var res = [this];\r\n        var max = (1 << wnd) - 1;\r\n        var dbl = max === 1 ? null : this.dbl();\r\n        for (var i = 1; i < max; i++)\r\n          res[i] = res[i - 1].add(dbl);\r\n        return {\r\n          wnd: wnd,\r\n          points: res\r\n        };\r\n      };\r\n\r\n      BasePoint.prototype._getBeta = function _getBeta() {\r\n        return null;\r\n      };\r\n\r\n      BasePoint.prototype.dblp = function dblp(k) {\r\n        var r = this;\r\n        for (var i = 0; i < k; i++)\r\n          r = r.dbl();\r\n        return r;\r\n      };\r\n\r\n    }, {\r\n      \"../../elliptic\": 73,\r\n      \"bn.js\": 23\r\n    }],\r\n    75: [function (require, module, exports) {\r\n      'use strict';\r\n\r\n      var curve = require('../curve');\r\n      var elliptic = require('../../elliptic');\r\n      var BN = require('bn.js');\r\n      var inherits = require('inherits');\r\n      var Base = curve.base;\r\n\r\n      var assert = elliptic.utils.assert;\r\n\r\n      function EdwardsCurve(conf) {\r\n        // NOTE: Important as we are creating point in Base.call()\r\n        this.twisted = (conf.a | 0) !== 1;\r\n        this.mOneA = this.twisted && (conf.a | 0) === -1;\r\n        this.extended = this.mOneA;\r\n\r\n        Base.call(this, 'edwards', conf);\r\n\r\n        this.a = new BN(conf.a, 16).umod(this.red.m);\r\n        this.a = this.a.toRed(this.red);\r\n        this.c = new BN(conf.c, 16).toRed(this.red);\r\n        this.c2 = this.c.redSqr();\r\n        this.d = new BN(conf.d, 16).toRed(this.red);\r\n        this.dd = this.d.redAdd(this.d);\r\n\r\n        assert(!this.twisted || this.c.fromRed().cmpn(1) === 0);\r\n        this.oneC = (conf.c | 0) === 1;\r\n      }\r\n      inherits(EdwardsCurve, Base);\r\n      module.exports = EdwardsCurve;\r\n\r\n      EdwardsCurve.prototype._mulA = function _mulA(num) {\r\n        if (this.mOneA)\r\n          return num.redNeg();\r\n        else\r\n          return this.a.redMul(num);\r\n      };\r\n\r\n      EdwardsCurve.prototype._mulC = function _mulC(num) {\r\n        if (this.oneC)\r\n          return num;\r\n        else\r\n          return this.c.redMul(num);\r\n      };\r\n\r\n      // Just for compatibility with Short curve\r\n      EdwardsCurve.prototype.jpoint = function jpoint(x, y, z, t) {\r\n        return this.point(x, y, z, t);\r\n      };\r\n\r\n      EdwardsCurve.prototype.pointFromX = function pointFromX(x, odd) {\r\n        x = new BN(x, 16);\r\n        if (!x.red)\r\n          x = x.toRed(this.red);\r\n\r\n        var x2 = x.redSqr();\r\n        var rhs = this.c2.redSub(this.a.redMul(x2));\r\n        var lhs = this.one.redSub(this.c2.redMul(this.d).redMul(x2));\r\n\r\n        var y2 = rhs.redMul(lhs.redInvm());\r\n        var y = y2.redSqrt();\r\n        if (y.redSqr().redSub(y2).cmp(this.zero) !== 0)\r\n          throw new Error('invalid point');\r\n\r\n        var isOdd = y.fromRed().isOdd();\r\n        if (odd && !isOdd || !odd && isOdd)\r\n          y = y.redNeg();\r\n\r\n        return this.point(x, y);\r\n      };\r\n\r\n      EdwardsCurve.prototype.pointFromY = function pointFromY(y, odd) {\r\n        y = new BN(y, 16);\r\n        if (!y.red)\r\n          y = y.toRed(this.red);\r\n\r\n        // x^2 = (y^2 - c^2) / (c^2 d y^2 - a)\r\n        var y2 = y.redSqr();\r\n        var lhs = y2.redSub(this.c2);\r\n        var rhs = y2.redMul(this.d).redMul(this.c2).redSub(this.a);\r\n        var x2 = lhs.redMul(rhs.redInvm());\r\n\r\n        if (x2.cmp(this.zero) === 0) {\r\n          if (odd)\r\n            throw new Error('invalid point');\r\n          else\r\n            return this.point(this.zero, y);\r\n        }\r\n\r\n        var x = x2.redSqrt();\r\n        if (x.redSqr().redSub(x2).cmp(this.zero) !== 0)\r\n          throw new Error('invalid point');\r\n\r\n        if (x.fromRed().isOdd() !== odd)\r\n          x = x.redNeg();\r\n\r\n        return this.point(x, y);\r\n      };\r\n\r\n      EdwardsCurve.prototype.validate = function validate(point) {\r\n        if (point.isInfinity())\r\n          return true;\r\n\r\n        // Curve: A * X^2 + Y^2 = C^2 * (1 + D * X^2 * Y^2)\r\n        point.normalize();\r\n\r\n        var x2 = point.x.redSqr();\r\n        var y2 = point.y.redSqr();\r\n        var lhs = x2.redMul(this.a).redAdd(y2);\r\n        var rhs = this.c2.redMul(this.one.redAdd(this.d.redMul(x2).redMul(y2)));\r\n\r\n        return lhs.cmp(rhs) === 0;\r\n      };\r\n\r\n      function Point(curve, x, y, z, t) {\r\n        Base.BasePoint.call(this, curve, 'projective');\r\n        if (x === null && y === null && z === null) {\r\n          this.x = this.curve.zero;\r\n          this.y = this.curve.one;\r\n          this.z = this.curve.one;\r\n          this.t = this.curve.zero;\r\n          this.zOne = true;\r\n        } else {\r\n          this.x = new BN(x, 16);\r\n          this.y = new BN(y, 16);\r\n          this.z = z ? new BN(z, 16) : this.curve.one;\r\n          this.t = t && new BN(t, 16);\r\n          if (!this.x.red)\r\n            this.x = this.x.toRed(this.curve.red);\r\n          if (!this.y.red)\r\n            this.y = this.y.toRed(this.curve.red);\r\n          if (!this.z.red)\r\n            this.z = this.z.toRed(this.curve.red);\r\n          if (this.t && !this.t.red)\r\n            this.t = this.t.toRed(this.curve.red);\r\n          this.zOne = this.z === this.curve.one;\r\n\r\n          // Use extended coordinates\r\n          if (this.curve.extended && !this.t) {\r\n            this.t = this.x.redMul(this.y);\r\n            if (!this.zOne)\r\n              this.t = this.t.redMul(this.z.redInvm());\r\n          }\r\n        }\r\n      }\r\n      inherits(Point, Base.BasePoint);\r\n\r\n      EdwardsCurve.prototype.pointFromJSON = function pointFromJSON(obj) {\r\n        return Point.fromJSON(this, obj);\r\n      };\r\n\r\n      EdwardsCurve.prototype.point = function point(x, y, z, t) {\r\n        return new Point(this, x, y, z, t);\r\n      };\r\n\r\n      Point.fromJSON = function fromJSON(curve, obj) {\r\n        return new Point(curve, obj[0], obj[1], obj[2]);\r\n      };\r\n\r\n      Point.prototype.inspect = function inspect() {\r\n        if (this.isInfinity())\r\n          return '<EC Point Infinity>';\r\n        return '<EC Point x: ' + this.x.fromRed().toString(16, 2) +\r\n          ' y: ' + this.y.fromRed().toString(16, 2) +\r\n          ' z: ' + this.z.fromRed().toString(16, 2) + '>';\r\n      };\r\n\r\n      Point.prototype.isInfinity = function isInfinity() {\r\n        // XXX This code assumes that zero is always zero in red\r\n        return this.x.cmpn(0) === 0 &&\r\n          (this.y.cmp(this.z) === 0 ||\r\n            (this.zOne && this.y.cmp(this.curve.c) === 0));\r\n      };\r\n\r\n      Point.prototype._extDbl = function _extDbl() {\r\n        // hyperelliptic.org/EFD/g1p/auto-twisted-extended-1.html\r\n        //     #doubling-dbl-2008-hwcd\r\n        // 4M + 4S\r\n\r\n        // A = X1^2\r\n        var a = this.x.redSqr();\r\n        // B = Y1^2\r\n        var b = this.y.redSqr();\r\n        // C = 2 * Z1^2\r\n        var c = this.z.redSqr();\r\n        c = c.redIAdd(c);\r\n        // D = a * A\r\n        var d = this.curve._mulA(a);\r\n        // E = (X1 + Y1)^2 - A - B\r\n        var e = this.x.redAdd(this.y).redSqr().redISub(a).redISub(b);\r\n        // G = D + B\r\n        var g = d.redAdd(b);\r\n        // F = G - C\r\n        var f = g.redSub(c);\r\n        // H = D - B\r\n        var h = d.redSub(b);\r\n        // X3 = E * F\r\n        var nx = e.redMul(f);\r\n        // Y3 = G * H\r\n        var ny = g.redMul(h);\r\n        // T3 = E * H\r\n        var nt = e.redMul(h);\r\n        // Z3 = F * G\r\n        var nz = f.redMul(g);\r\n        return this.curve.point(nx, ny, nz, nt);\r\n      };\r\n\r\n      Point.prototype._projDbl = function _projDbl() {\r\n        // hyperelliptic.org/EFD/g1p/auto-twisted-projective.html\r\n        //     #doubling-dbl-2008-bbjlp\r\n        //     #doubling-dbl-2007-bl\r\n        // and others\r\n        // Generally 3M + 4S or 2M + 4S\r\n\r\n        // B = (X1 + Y1)^2\r\n        var b = this.x.redAdd(this.y).redSqr();\r\n        // C = X1^2\r\n        var c = this.x.redSqr();\r\n        // D = Y1^2\r\n        var d = this.y.redSqr();\r\n\r\n        var nx;\r\n        var ny;\r\n        var nz;\r\n        if (this.curve.twisted) {\r\n          // E = a * C\r\n          var e = this.curve._mulA(c);\r\n          // F = E + D\r\n          var f = e.redAdd(d);\r\n          if (this.zOne) {\r\n            // X3 = (B - C - D) * (F - 2)\r\n            nx = b.redSub(c).redSub(d).redMul(f.redSub(this.curve.two));\r\n            // Y3 = F * (E - D)\r\n            ny = f.redMul(e.redSub(d));\r\n            // Z3 = F^2 - 2 * F\r\n            nz = f.redSqr().redSub(f).redSub(f);\r\n          } else {\r\n            // H = Z1^2\r\n            var h = this.z.redSqr();\r\n            // J = F - 2 * H\r\n            var j = f.redSub(h).redISub(h);\r\n            // X3 = (B-C-D)*J\r\n            nx = b.redSub(c).redISub(d).redMul(j);\r\n            // Y3 = F * (E - D)\r\n            ny = f.redMul(e.redSub(d));\r\n            // Z3 = F * J\r\n            nz = f.redMul(j);\r\n          }\r\n        } else {\r\n          // E = C + D\r\n          var e = c.redAdd(d);\r\n          // H = (c * Z1)^2\r\n          var h = this.curve._mulC(this.z).redSqr();\r\n          // J = E - 2 * H\r\n          var j = e.redSub(h).redSub(h);\r\n          // X3 = c * (B - E) * J\r\n          nx = this.curve._mulC(b.redISub(e)).redMul(j);\r\n          // Y3 = c * E * (C - D)\r\n          ny = this.curve._mulC(e).redMul(c.redISub(d));\r\n          // Z3 = E * J\r\n          nz = e.redMul(j);\r\n        }\r\n        return this.curve.point(nx, ny, nz);\r\n      };\r\n\r\n      Point.prototype.dbl = function dbl() {\r\n        if (this.isInfinity())\r\n          return this;\r\n\r\n        // Double in extended coordinates\r\n        if (this.curve.extended)\r\n          return this._extDbl();\r\n        else\r\n          return this._projDbl();\r\n      };\r\n\r\n      Point.prototype._extAdd = function _extAdd(p) {\r\n        // hyperelliptic.org/EFD/g1p/auto-twisted-extended-1.html\r\n        //     #addition-add-2008-hwcd-3\r\n        // 8M\r\n\r\n        // A = (Y1 - X1) * (Y2 - X2)\r\n        var a = this.y.redSub(this.x).redMul(p.y.redSub(p.x));\r\n        // B = (Y1 + X1) * (Y2 + X2)\r\n        var b = this.y.redAdd(this.x).redMul(p.y.redAdd(p.x));\r\n        // C = T1 * k * T2\r\n        var c = this.t.redMul(this.curve.dd).redMul(p.t);\r\n        // D = Z1 * 2 * Z2\r\n        var d = this.z.redMul(p.z.redAdd(p.z));\r\n        // E = B - A\r\n        var e = b.redSub(a);\r\n        // F = D - C\r\n        var f = d.redSub(c);\r\n        // G = D + C\r\n        var g = d.redAdd(c);\r\n        // H = B + A\r\n        var h = b.redAdd(a);\r\n        // X3 = E * F\r\n        var nx = e.redMul(f);\r\n        // Y3 = G * H\r\n        var ny = g.redMul(h);\r\n        // T3 = E * H\r\n        var nt = e.redMul(h);\r\n        // Z3 = F * G\r\n        var nz = f.redMul(g);\r\n        return this.curve.point(nx, ny, nz, nt);\r\n      };\r\n\r\n      Point.prototype._projAdd = function _projAdd(p) {\r\n        // hyperelliptic.org/EFD/g1p/auto-twisted-projective.html\r\n        //     #addition-add-2008-bbjlp\r\n        //     #addition-add-2007-bl\r\n        // 10M + 1S\r\n\r\n        // A = Z1 * Z2\r\n        var a = this.z.redMul(p.z);\r\n        // B = A^2\r\n        var b = a.redSqr();\r\n        // C = X1 * X2\r\n        var c = this.x.redMul(p.x);\r\n        // D = Y1 * Y2\r\n        var d = this.y.redMul(p.y);\r\n        // E = d * C * D\r\n        var e = this.curve.d.redMul(c).redMul(d);\r\n        // F = B - E\r\n        var f = b.redSub(e);\r\n        // G = B + E\r\n        var g = b.redAdd(e);\r\n        // X3 = A * F * ((X1 + Y1) * (X2 + Y2) - C - D)\r\n        var tmp = this.x.redAdd(this.y).redMul(p.x.redAdd(p.y)).redISub(c).redISub(d);\r\n        var nx = a.redMul(f).redMul(tmp);\r\n        var ny;\r\n        var nz;\r\n        if (this.curve.twisted) {\r\n          // Y3 = A * G * (D - a * C)\r\n          ny = a.redMul(g).redMul(d.redSub(this.curve._mulA(c)));\r\n          // Z3 = F * G\r\n          nz = f.redMul(g);\r\n        } else {\r\n          // Y3 = A * G * (D - C)\r\n          ny = a.redMul(g).redMul(d.redSub(c));\r\n          // Z3 = c * F * G\r\n          nz = this.curve._mulC(f).redMul(g);\r\n        }\r\n        return this.curve.point(nx, ny, nz);\r\n      };\r\n\r\n      Point.prototype.add = function add(p) {\r\n        if (this.isInfinity())\r\n          return p;\r\n        if (p.isInfinity())\r\n          return this;\r\n\r\n        if (this.curve.extended)\r\n          return this._extAdd(p);\r\n        else\r\n          return this._projAdd(p);\r\n      };\r\n\r\n      Point.prototype.mul = function mul(k) {\r\n        if (this._hasDoubles(k))\r\n          return this.curve._fixedNafMul(this, k);\r\n        else\r\n          return this.curve._wnafMul(this, k);\r\n      };\r\n\r\n      Point.prototype.mulAdd = function mulAdd(k1, p, k2) {\r\n        return this.curve._wnafMulAdd(1, [this, p], [k1, k2], 2, false);\r\n      };\r\n\r\n      Point.prototype.jmulAdd = function jmulAdd(k1, p, k2) {\r\n        return this.curve._wnafMulAdd(1, [this, p], [k1, k2], 2, true);\r\n      };\r\n\r\n      Point.prototype.normalize = function normalize() {\r\n        if (this.zOne)\r\n          return this;\r\n\r\n        // Normalize coordinates\r\n        var zi = this.z.redInvm();\r\n        this.x = this.x.redMul(zi);\r\n        this.y = this.y.redMul(zi);\r\n        if (this.t)\r\n          this.t = this.t.redMul(zi);\r\n        this.z = this.curve.one;\r\n        this.zOne = true;\r\n        return this;\r\n      };\r\n\r\n      Point.prototype.neg = function neg() {\r\n        return this.curve.point(this.x.redNeg(),\r\n          this.y,\r\n          this.z,\r\n          this.t && this.t.redNeg());\r\n      };\r\n\r\n      Point.prototype.getX = function getX() {\r\n        this.normalize();\r\n        return this.x.fromRed();\r\n      };\r\n\r\n      Point.prototype.getY = function getY() {\r\n        this.normalize();\r\n        return this.y.fromRed();\r\n      };\r\n\r\n      Point.prototype.eq = function eq(other) {\r\n        return this === other ||\r\n          this.getX().cmp(other.getX()) === 0 &&\r\n          this.getY().cmp(other.getY()) === 0;\r\n      };\r\n\r\n      Point.prototype.eqXToP = function eqXToP(x) {\r\n        var rx = x.toRed(this.curve.red).redMul(this.z);\r\n        if (this.x.cmp(rx) === 0)\r\n          return true;\r\n\r\n        var xc = x.clone();\r\n        var t = this.curve.redN.redMul(this.z);\r\n        for (;;) {\r\n          xc.iadd(this.curve.n);\r\n          if (xc.cmp(this.curve.p) >= 0)\r\n            return false;\r\n\r\n          rx.redIAdd(t);\r\n          if (this.x.cmp(rx) === 0)\r\n            return true;\r\n        }\r\n      };\r\n\r\n      // Compatibility with BaseCurve\r\n      Point.prototype.toP = Point.prototype.normalize;\r\n      Point.prototype.mixedAdd = Point.prototype.add;\r\n\r\n    }, {\r\n      \"../../elliptic\": 73,\r\n      \"../curve\": 76,\r\n      \"bn.js\": 23,\r\n      \"inherits\": 106\r\n    }],\r\n    76: [function (require, module, exports) {\r\n      'use strict';\r\n\r\n      var curve = exports;\r\n\r\n      curve.base = require('./base');\r\n      curve.short = require('./short');\r\n      curve.mont = require('./mont');\r\n      curve.edwards = require('./edwards');\r\n\r\n    }, {\r\n      \"./base\": 74,\r\n      \"./edwards\": 75,\r\n      \"./mont\": 77,\r\n      \"./short\": 78\r\n    }],\r\n    77: [function (require, module, exports) {\r\n      'use strict';\r\n\r\n      var curve = require('../curve');\r\n      var BN = require('bn.js');\r\n      var inherits = require('inherits');\r\n      var Base = curve.base;\r\n\r\n      var elliptic = require('../../elliptic');\r\n      var utils = elliptic.utils;\r\n\r\n      function MontCurve(conf) {\r\n        Base.call(this, 'mont', conf);\r\n\r\n        this.a = new BN(conf.a, 16).toRed(this.red);\r\n        this.b = new BN(conf.b, 16).toRed(this.red);\r\n        this.i4 = new BN(4).toRed(this.red).redInvm();\r\n        this.two = new BN(2).toRed(this.red);\r\n        this.a24 = this.i4.redMul(this.a.redAdd(this.two));\r\n      }\r\n      inherits(MontCurve, Base);\r\n      module.exports = MontCurve;\r\n\r\n      MontCurve.prototype.validate = function validate(point) {\r\n        var x = point.normalize().x;\r\n        var x2 = x.redSqr();\r\n        var rhs = x2.redMul(x).redAdd(x2.redMul(this.a)).redAdd(x);\r\n        var y = rhs.redSqrt();\r\n\r\n        return y.redSqr().cmp(rhs) === 0;\r\n      };\r\n\r\n      function Point(curve, x, z) {\r\n        Base.BasePoint.call(this, curve, 'projective');\r\n        if (x === null && z === null) {\r\n          this.x = this.curve.one;\r\n          this.z = this.curve.zero;\r\n        } else {\r\n          this.x = new BN(x, 16);\r\n          this.z = new BN(z, 16);\r\n          if (!this.x.red)\r\n            this.x = this.x.toRed(this.curve.red);\r\n          if (!this.z.red)\r\n            this.z = this.z.toRed(this.curve.red);\r\n        }\r\n      }\r\n      inherits(Point, Base.BasePoint);\r\n\r\n      MontCurve.prototype.decodePoint = function decodePoint(bytes, enc) {\r\n        return this.point(utils.toArray(bytes, enc), 1);\r\n      };\r\n\r\n      MontCurve.prototype.point = function point(x, z) {\r\n        return new Point(this, x, z);\r\n      };\r\n\r\n      MontCurve.prototype.pointFromJSON = function pointFromJSON(obj) {\r\n        return Point.fromJSON(this, obj);\r\n      };\r\n\r\n      Point.prototype.precompute = function precompute() {\r\n        // No-op\r\n      };\r\n\r\n      Point.prototype._encode = function _encode() {\r\n        return this.getX().toArray('be', this.curve.p.byteLength());\r\n      };\r\n\r\n      Point.fromJSON = function fromJSON(curve, obj) {\r\n        return new Point(curve, obj[0], obj[1] || curve.one);\r\n      };\r\n\r\n      Point.prototype.inspect = function inspect() {\r\n        if (this.isInfinity())\r\n          return '<EC Point Infinity>';\r\n        return '<EC Point x: ' + this.x.fromRed().toString(16, 2) +\r\n          ' z: ' + this.z.fromRed().toString(16, 2) + '>';\r\n      };\r\n\r\n      Point.prototype.isInfinity = function isInfinity() {\r\n        // XXX This code assumes that zero is always zero in red\r\n        return this.z.cmpn(0) === 0;\r\n      };\r\n\r\n      Point.prototype.dbl = function dbl() {\r\n        // http://hyperelliptic.org/EFD/g1p/auto-montgom-xz.html#doubling-dbl-1987-m-3\r\n        // 2M + 2S + 4A\r\n\r\n        // A = X1 + Z1\r\n        var a = this.x.redAdd(this.z);\r\n        // AA = A^2\r\n        var aa = a.redSqr();\r\n        // B = X1 - Z1\r\n        var b = this.x.redSub(this.z);\r\n        // BB = B^2\r\n        var bb = b.redSqr();\r\n        // C = AA - BB\r\n        var c = aa.redSub(bb);\r\n        // X3 = AA * BB\r\n        var nx = aa.redMul(bb);\r\n        // Z3 = C * (BB + A24 * C)\r\n        var nz = c.redMul(bb.redAdd(this.curve.a24.redMul(c)));\r\n        return this.curve.point(nx, nz);\r\n      };\r\n\r\n      Point.prototype.add = function add() {\r\n        throw new Error('Not supported on Montgomery curve');\r\n      };\r\n\r\n      Point.prototype.diffAdd = function diffAdd(p, diff) {\r\n        // http://hyperelliptic.org/EFD/g1p/auto-montgom-xz.html#diffadd-dadd-1987-m-3\r\n        // 4M + 2S + 6A\r\n\r\n        // A = X2 + Z2\r\n        var a = this.x.redAdd(this.z);\r\n        // B = X2 - Z2\r\n        var b = this.x.redSub(this.z);\r\n        // C = X3 + Z3\r\n        var c = p.x.redAdd(p.z);\r\n        // D = X3 - Z3\r\n        var d = p.x.redSub(p.z);\r\n        // DA = D * A\r\n        var da = d.redMul(a);\r\n        // CB = C * B\r\n        var cb = c.redMul(b);\r\n        // X5 = Z1 * (DA + CB)^2\r\n        var nx = diff.z.redMul(da.redAdd(cb).redSqr());\r\n        // Z5 = X1 * (DA - CB)^2\r\n        var nz = diff.x.redMul(da.redISub(cb).redSqr());\r\n        return this.curve.point(nx, nz);\r\n      };\r\n\r\n      Point.prototype.mul = function mul(k) {\r\n        var t = k.clone();\r\n        var a = this; // (N / 2) * Q + Q\r\n        var b = this.curve.point(null, null); // (N / 2) * Q\r\n        var c = this; // Q\r\n\r\n        for (var bits = []; t.cmpn(0) !== 0; t.iushrn(1))\r\n          bits.push(t.andln(1));\r\n\r\n        for (var i = bits.length - 1; i >= 0; i--) {\r\n          if (bits[i] === 0) {\r\n            // N * Q + Q = ((N / 2) * Q + Q)) + (N / 2) * Q\r\n            a = a.diffAdd(b, c);\r\n            // N * Q = 2 * ((N / 2) * Q + Q))\r\n            b = b.dbl();\r\n          } else {\r\n            // N * Q = ((N / 2) * Q + Q) + ((N / 2) * Q)\r\n            b = a.diffAdd(b, c);\r\n            // N * Q + Q = 2 * ((N / 2) * Q + Q)\r\n            a = a.dbl();\r\n          }\r\n        }\r\n        return b;\r\n      };\r\n\r\n      Point.prototype.mulAdd = function mulAdd() {\r\n        throw new Error('Not supported on Montgomery curve');\r\n      };\r\n\r\n      Point.prototype.jumlAdd = function jumlAdd() {\r\n        throw new Error('Not supported on Montgomery curve');\r\n      };\r\n\r\n      Point.prototype.eq = function eq(other) {\r\n        return this.getX().cmp(other.getX()) === 0;\r\n      };\r\n\r\n      Point.prototype.normalize = function normalize() {\r\n        this.x = this.x.redMul(this.z.redInvm());\r\n        this.z = this.curve.one;\r\n        return this;\r\n      };\r\n\r\n      Point.prototype.getX = function getX() {\r\n        // Normalize coordinates\r\n        this.normalize();\r\n\r\n        return this.x.fromRed();\r\n      };\r\n\r\n    }, {\r\n      \"../../elliptic\": 73,\r\n      \"../curve\": 76,\r\n      \"bn.js\": 23,\r\n      \"inherits\": 106\r\n    }],\r\n    78: [function (require, module, exports) {\r\n      'use strict';\r\n\r\n      var curve = require('../curve');\r\n      var elliptic = require('../../elliptic');\r\n      var BN = require('bn.js');\r\n      var inherits = require('inherits');\r\n      var Base = curve.base;\r\n\r\n      var assert = elliptic.utils.assert;\r\n\r\n      function ShortCurve(conf) {\r\n        Base.call(this, 'short', conf);\r\n\r\n        this.a = new BN(conf.a, 16).toRed(this.red);\r\n        this.b = new BN(conf.b, 16).toRed(this.red);\r\n        this.tinv = this.two.redInvm();\r\n\r\n        this.zeroA = this.a.fromRed().cmpn(0) === 0;\r\n        this.threeA = this.a.fromRed().sub(this.p).cmpn(-3) === 0;\r\n\r\n        // If the curve is endomorphic, precalculate beta and lambda\r\n        this.endo = this._getEndomorphism(conf);\r\n        this._endoWnafT1 = new Array(4);\r\n        this._endoWnafT2 = new Array(4);\r\n      }\r\n      inherits(ShortCurve, Base);\r\n      module.exports = ShortCurve;\r\n\r\n      ShortCurve.prototype._getEndomorphism = function _getEndomorphism(conf) {\r\n        // No efficient endomorphism\r\n        if (!this.zeroA || !this.g || !this.n || this.p.modn(3) !== 1)\r\n          return;\r\n\r\n        // Compute beta and lambda, that lambda * P = (beta * Px; Py)\r\n        var beta;\r\n        var lambda;\r\n        if (conf.beta) {\r\n          beta = new BN(conf.beta, 16).toRed(this.red);\r\n        } else {\r\n          var betas = this._getEndoRoots(this.p);\r\n          // Choose the smallest beta\r\n          beta = betas[0].cmp(betas[1]) < 0 ? betas[0] : betas[1];\r\n          beta = beta.toRed(this.red);\r\n        }\r\n        if (conf.lambda) {\r\n          lambda = new BN(conf.lambda, 16);\r\n        } else {\r\n          // Choose the lambda that is matching selected beta\r\n          var lambdas = this._getEndoRoots(this.n);\r\n          if (this.g.mul(lambdas[0]).x.cmp(this.g.x.redMul(beta)) === 0) {\r\n            lambda = lambdas[0];\r\n          } else {\r\n            lambda = lambdas[1];\r\n            assert(this.g.mul(lambda).x.cmp(this.g.x.redMul(beta)) === 0);\r\n          }\r\n        }\r\n\r\n        // Get basis vectors, used for balanced length-two representation\r\n        var basis;\r\n        if (conf.basis) {\r\n          basis = conf.basis.map(function (vec) {\r\n            return {\r\n              a: new BN(vec.a, 16),\r\n              b: new BN(vec.b, 16)\r\n            };\r\n          });\r\n        } else {\r\n          basis = this._getEndoBasis(lambda);\r\n        }\r\n\r\n        return {\r\n          beta: beta,\r\n          lambda: lambda,\r\n          basis: basis\r\n        };\r\n      };\r\n\r\n      ShortCurve.prototype._getEndoRoots = function _getEndoRoots(num) {\r\n        // Find roots of for x^2 + x + 1 in F\r\n        // Root = (-1 +- Sqrt(-3)) / 2\r\n        //\r\n        var red = num === this.p ? this.red : BN.mont(num);\r\n        var tinv = new BN(2).toRed(red).redInvm();\r\n        var ntinv = tinv.redNeg();\r\n\r\n        var s = new BN(3).toRed(red).redNeg().redSqrt().redMul(tinv);\r\n\r\n        var l1 = ntinv.redAdd(s).fromRed();\r\n        var l2 = ntinv.redSub(s).fromRed();\r\n        return [l1, l2];\r\n      };\r\n\r\n      ShortCurve.prototype._getEndoBasis = function _getEndoBasis(lambda) {\r\n        // aprxSqrt >= sqrt(this.n)\r\n        var aprxSqrt = this.n.ushrn(Math.floor(this.n.bitLength() / 2));\r\n\r\n        // 3.74\r\n        // Run EGCD, until r(L + 1) < aprxSqrt\r\n        var u = lambda;\r\n        var v = this.n.clone();\r\n        var x1 = new BN(1);\r\n        var y1 = new BN(0);\r\n        var x2 = new BN(0);\r\n        var y2 = new BN(1);\r\n\r\n        // NOTE: all vectors are roots of: a + b * lambda = 0 (mod n)\r\n        var a0;\r\n        var b0;\r\n        // First vector\r\n        var a1;\r\n        var b1;\r\n        // Second vector\r\n        var a2;\r\n        var b2;\r\n\r\n        var prevR;\r\n        var i = 0;\r\n        var r;\r\n        var x;\r\n        while (u.cmpn(0) !== 0) {\r\n          var q = v.div(u);\r\n          r = v.sub(q.mul(u));\r\n          x = x2.sub(q.mul(x1));\r\n          var y = y2.sub(q.mul(y1));\r\n\r\n          if (!a1 && r.cmp(aprxSqrt) < 0) {\r\n            a0 = prevR.neg();\r\n            b0 = x1;\r\n            a1 = r.neg();\r\n            b1 = x;\r\n          } else if (a1 && ++i === 2) {\r\n            break;\r\n          }\r\n          prevR = r;\r\n\r\n          v = u;\r\n          u = r;\r\n          x2 = x1;\r\n          x1 = x;\r\n          y2 = y1;\r\n          y1 = y;\r\n        }\r\n        a2 = r.neg();\r\n        b2 = x;\r\n\r\n        var len1 = a1.sqr().add(b1.sqr());\r\n        var len2 = a2.sqr().add(b2.sqr());\r\n        if (len2.cmp(len1) >= 0) {\r\n          a2 = a0;\r\n          b2 = b0;\r\n        }\r\n\r\n        // Normalize signs\r\n        if (a1.negative) {\r\n          a1 = a1.neg();\r\n          b1 = b1.neg();\r\n        }\r\n        if (a2.negative) {\r\n          a2 = a2.neg();\r\n          b2 = b2.neg();\r\n        }\r\n\r\n        return [{\r\n            a: a1,\r\n            b: b1\r\n          },\r\n          {\r\n            a: a2,\r\n            b: b2\r\n          }\r\n        ];\r\n      };\r\n\r\n      ShortCurve.prototype._endoSplit = function _endoSplit(k) {\r\n        var basis = this.endo.basis;\r\n        var v1 = basis[0];\r\n        var v2 = basis[1];\r\n\r\n        var c1 = v2.b.mul(k).divRound(this.n);\r\n        var c2 = v1.b.neg().mul(k).divRound(this.n);\r\n\r\n        var p1 = c1.mul(v1.a);\r\n        var p2 = c2.mul(v2.a);\r\n        var q1 = c1.mul(v1.b);\r\n        var q2 = c2.mul(v2.b);\r\n\r\n        // Calculate answer\r\n        var k1 = k.sub(p1).sub(p2);\r\n        var k2 = q1.add(q2).neg();\r\n        return {\r\n          k1: k1,\r\n          k2: k2\r\n        };\r\n      };\r\n\r\n      ShortCurve.prototype.pointFromX = function pointFromX(x, odd) {\r\n        x = new BN(x, 16);\r\n        if (!x.red)\r\n          x = x.toRed(this.red);\r\n\r\n        var y2 = x.redSqr().redMul(x).redIAdd(x.redMul(this.a)).redIAdd(this.b);\r\n        var y = y2.redSqrt();\r\n        if (y.redSqr().redSub(y2).cmp(this.zero) !== 0)\r\n          throw new Error('invalid point');\r\n\r\n        // XXX Is there any way to tell if the number is odd without converting it\r\n        // to non-red form?\r\n        var isOdd = y.fromRed().isOdd();\r\n        if (odd && !isOdd || !odd && isOdd)\r\n          y = y.redNeg();\r\n\r\n        return this.point(x, y);\r\n      };\r\n\r\n      ShortCurve.prototype.validate = function validate(point) {\r\n        if (point.inf)\r\n          return true;\r\n\r\n        var x = point.x;\r\n        var y = point.y;\r\n\r\n        var ax = this.a.redMul(x);\r\n        var rhs = x.redSqr().redMul(x).redIAdd(ax).redIAdd(this.b);\r\n        return y.redSqr().redISub(rhs).cmpn(0) === 0;\r\n      };\r\n\r\n      ShortCurve.prototype._endoWnafMulAdd =\r\n        function _endoWnafMulAdd(points, coeffs, jacobianResult) {\r\n          var npoints = this._endoWnafT1;\r\n          var ncoeffs = this._endoWnafT2;\r\n          for (var i = 0; i < points.length; i++) {\r\n            var split = this._endoSplit(coeffs[i]);\r\n            var p = points[i];\r\n            var beta = p._getBeta();\r\n\r\n            if (split.k1.negative) {\r\n              split.k1.ineg();\r\n              p = p.neg(true);\r\n            }\r\n            if (split.k2.negative) {\r\n              split.k2.ineg();\r\n              beta = beta.neg(true);\r\n            }\r\n\r\n            npoints[i * 2] = p;\r\n            npoints[i * 2 + 1] = beta;\r\n            ncoeffs[i * 2] = split.k1;\r\n            ncoeffs[i * 2 + 1] = split.k2;\r\n          }\r\n          var res = this._wnafMulAdd(1, npoints, ncoeffs, i * 2, jacobianResult);\r\n\r\n          // Clean-up references to points and coefficients\r\n          for (var j = 0; j < i * 2; j++) {\r\n            npoints[j] = null;\r\n            ncoeffs[j] = null;\r\n          }\r\n          return res;\r\n        };\r\n\r\n      function Point(curve, x, y, isRed) {\r\n        Base.BasePoint.call(this, curve, 'affine');\r\n        if (x === null && y === null) {\r\n          this.x = null;\r\n          this.y = null;\r\n          this.inf = true;\r\n        } else {\r\n          this.x = new BN(x, 16);\r\n          this.y = new BN(y, 16);\r\n          // Force redgomery representation when loading from JSON\r\n          if (isRed) {\r\n            this.x.forceRed(this.curve.red);\r\n            this.y.forceRed(this.curve.red);\r\n          }\r\n          if (!this.x.red)\r\n            this.x = this.x.toRed(this.curve.red);\r\n          if (!this.y.red)\r\n            this.y = this.y.toRed(this.curve.red);\r\n          this.inf = false;\r\n        }\r\n      }\r\n      inherits(Point, Base.BasePoint);\r\n\r\n      ShortCurve.prototype.point = function point(x, y, isRed) {\r\n        return new Point(this, x, y, isRed);\r\n      };\r\n\r\n      ShortCurve.prototype.pointFromJSON = function pointFromJSON(obj, red) {\r\n        return Point.fromJSON(this, obj, red);\r\n      };\r\n\r\n      Point.prototype._getBeta = function _getBeta() {\r\n        if (!this.curve.endo)\r\n          return;\r\n\r\n        var pre = this.precomputed;\r\n        if (pre && pre.beta)\r\n          return pre.beta;\r\n\r\n        var beta = this.curve.point(this.x.redMul(this.curve.endo.beta), this.y);\r\n        if (pre) {\r\n          var curve = this.curve;\r\n          var endoMul = function (p) {\r\n            return curve.point(p.x.redMul(curve.endo.beta), p.y);\r\n          };\r\n          pre.beta = beta;\r\n          beta.precomputed = {\r\n            beta: null,\r\n            naf: pre.naf && {\r\n              wnd: pre.naf.wnd,\r\n              points: pre.naf.points.map(endoMul)\r\n            },\r\n            doubles: pre.doubles && {\r\n              step: pre.doubles.step,\r\n              points: pre.doubles.points.map(endoMul)\r\n            }\r\n          };\r\n        }\r\n        return beta;\r\n      };\r\n\r\n      Point.prototype.toJSON = function toJSON() {\r\n        if (!this.precomputed)\r\n          return [this.x, this.y];\r\n\r\n        return [this.x, this.y, this.precomputed && {\r\n          doubles: this.precomputed.doubles && {\r\n            step: this.precomputed.doubles.step,\r\n            points: this.precomputed.doubles.points.slice(1)\r\n          },\r\n          naf: this.precomputed.naf && {\r\n            wnd: this.precomputed.naf.wnd,\r\n            points: this.precomputed.naf.points.slice(1)\r\n          }\r\n        }];\r\n      };\r\n\r\n      Point.fromJSON = function fromJSON(curve, obj, red) {\r\n        if (typeof obj === 'string')\r\n          obj = JSON.parse(obj);\r\n        var res = curve.point(obj[0], obj[1], red);\r\n        if (!obj[2])\r\n          return res;\r\n\r\n        function obj2point(obj) {\r\n          return curve.point(obj[0], obj[1], red);\r\n        }\r\n\r\n        var pre = obj[2];\r\n        res.precomputed = {\r\n          beta: null,\r\n          doubles: pre.doubles && {\r\n            step: pre.doubles.step,\r\n            points: [res].concat(pre.doubles.points.map(obj2point))\r\n          },\r\n          naf: pre.naf && {\r\n            wnd: pre.naf.wnd,\r\n            points: [res].concat(pre.naf.points.map(obj2point))\r\n          }\r\n        };\r\n        return res;\r\n      };\r\n\r\n      Point.prototype.inspect = function inspect() {\r\n        if (this.isInfinity())\r\n          return '<EC Point Infinity>';\r\n        return '<EC Point x: ' + this.x.fromRed().toString(16, 2) +\r\n          ' y: ' + this.y.fromRed().toString(16, 2) + '>';\r\n      };\r\n\r\n      Point.prototype.isInfinity = function isInfinity() {\r\n        return this.inf;\r\n      };\r\n\r\n      Point.prototype.add = function add(p) {\r\n        // O + P = P\r\n        if (this.inf)\r\n          return p;\r\n\r\n        // P + O = P\r\n        if (p.inf)\r\n          return this;\r\n\r\n        // P + P = 2P\r\n        if (this.eq(p))\r\n          return this.dbl();\r\n\r\n        // P + (-P) = O\r\n        if (this.neg().eq(p))\r\n          return this.curve.point(null, null);\r\n\r\n        // P + Q = O\r\n        if (this.x.cmp(p.x) === 0)\r\n          return this.curve.point(null, null);\r\n\r\n        var c = this.y.redSub(p.y);\r\n        if (c.cmpn(0) !== 0)\r\n          c = c.redMul(this.x.redSub(p.x).redInvm());\r\n        var nx = c.redSqr().redISub(this.x).redISub(p.x);\r\n        var ny = c.redMul(this.x.redSub(nx)).redISub(this.y);\r\n        return this.curve.point(nx, ny);\r\n      };\r\n\r\n      Point.prototype.dbl = function dbl() {\r\n        if (this.inf)\r\n          return this;\r\n\r\n        // 2P = O\r\n        var ys1 = this.y.redAdd(this.y);\r\n        if (ys1.cmpn(0) === 0)\r\n          return this.curve.point(null, null);\r\n\r\n        var a = this.curve.a;\r\n\r\n        var x2 = this.x.redSqr();\r\n        var dyinv = ys1.redInvm();\r\n        var c = x2.redAdd(x2).redIAdd(x2).redIAdd(a).redMul(dyinv);\r\n\r\n        var nx = c.redSqr().redISub(this.x.redAdd(this.x));\r\n        var ny = c.redMul(this.x.redSub(nx)).redISub(this.y);\r\n        return this.curve.point(nx, ny);\r\n      };\r\n\r\n      Point.prototype.getX = function getX() {\r\n        return this.x.fromRed();\r\n      };\r\n\r\n      Point.prototype.getY = function getY() {\r\n        return this.y.fromRed();\r\n      };\r\n\r\n      Point.prototype.mul = function mul(k) {\r\n        k = new BN(k, 16);\r\n\r\n        if (this._hasDoubles(k))\r\n          return this.curve._fixedNafMul(this, k);\r\n        else if (this.curve.endo)\r\n          return this.curve._endoWnafMulAdd([this], [k]);\r\n        else\r\n          return this.curve._wnafMul(this, k);\r\n      };\r\n\r\n      Point.prototype.mulAdd = function mulAdd(k1, p2, k2) {\r\n        var points = [this, p2];\r\n        var coeffs = [k1, k2];\r\n        if (this.curve.endo)\r\n          return this.curve._endoWnafMulAdd(points, coeffs);\r\n        else\r\n          return this.curve._wnafMulAdd(1, points, coeffs, 2);\r\n      };\r\n\r\n      Point.prototype.jmulAdd = function jmulAdd(k1, p2, k2) {\r\n        var points = [this, p2];\r\n        var coeffs = [k1, k2];\r\n        if (this.curve.endo)\r\n          return this.curve._endoWnafMulAdd(points, coeffs, true);\r\n        else\r\n          return this.curve._wnafMulAdd(1, points, coeffs, 2, true);\r\n      };\r\n\r\n      Point.prototype.eq = function eq(p) {\r\n        return this === p ||\r\n          this.inf === p.inf &&\r\n          (this.inf || this.x.cmp(p.x) === 0 && this.y.cmp(p.y) === 0);\r\n      };\r\n\r\n      Point.prototype.neg = function neg(_precompute) {\r\n        if (this.inf)\r\n          return this;\r\n\r\n        var res = this.curve.point(this.x, this.y.redNeg());\r\n        if (_precompute && this.precomputed) {\r\n          var pre = this.precomputed;\r\n          var negate = function (p) {\r\n            return p.neg();\r\n          };\r\n          res.precomputed = {\r\n            naf: pre.naf && {\r\n              wnd: pre.naf.wnd,\r\n              points: pre.naf.points.map(negate)\r\n            },\r\n            doubles: pre.doubles && {\r\n              step: pre.doubles.step,\r\n              points: pre.doubles.points.map(negate)\r\n            }\r\n          };\r\n        }\r\n        return res;\r\n      };\r\n\r\n      Point.prototype.toJ = function toJ() {\r\n        if (this.inf)\r\n          return this.curve.jpoint(null, null, null);\r\n\r\n        var res = this.curve.jpoint(this.x, this.y, this.curve.one);\r\n        return res;\r\n      };\r\n\r\n      function JPoint(curve, x, y, z) {\r\n        Base.BasePoint.call(this, curve, 'jacobian');\r\n        if (x === null && y === null && z === null) {\r\n          this.x = this.curve.one;\r\n          this.y = this.curve.one;\r\n          this.z = new BN(0);\r\n        } else {\r\n          this.x = new BN(x, 16);\r\n          this.y = new BN(y, 16);\r\n          this.z = new BN(z, 16);\r\n        }\r\n        if (!this.x.red)\r\n          this.x = this.x.toRed(this.curve.red);\r\n        if (!this.y.red)\r\n          this.y = this.y.toRed(this.curve.red);\r\n        if (!this.z.red)\r\n          this.z = this.z.toRed(this.curve.red);\r\n\r\n        this.zOne = this.z === this.curve.one;\r\n      }\r\n      inherits(JPoint, Base.BasePoint);\r\n\r\n      ShortCurve.prototype.jpoint = function jpoint(x, y, z) {\r\n        return new JPoint(this, x, y, z);\r\n      };\r\n\r\n      JPoint.prototype.toP = function toP() {\r\n        if (this.isInfinity())\r\n          return this.curve.point(null, null);\r\n\r\n        var zinv = this.z.redInvm();\r\n        var zinv2 = zinv.redSqr();\r\n        var ax = this.x.redMul(zinv2);\r\n        var ay = this.y.redMul(zinv2).redMul(zinv);\r\n\r\n        return this.curve.point(ax, ay);\r\n      };\r\n\r\n      JPoint.prototype.neg = function neg() {\r\n        return this.curve.jpoint(this.x, this.y.redNeg(), this.z);\r\n      };\r\n\r\n      JPoint.prototype.add = function add(p) {\r\n        // O + P = P\r\n        if (this.isInfinity())\r\n          return p;\r\n\r\n        // P + O = P\r\n        if (p.isInfinity())\r\n          return this;\r\n\r\n        // 12M + 4S + 7A\r\n        var pz2 = p.z.redSqr();\r\n        var z2 = this.z.redSqr();\r\n        var u1 = this.x.redMul(pz2);\r\n        var u2 = p.x.redMul(z2);\r\n        var s1 = this.y.redMul(pz2.redMul(p.z));\r\n        var s2 = p.y.redMul(z2.redMul(this.z));\r\n\r\n        var h = u1.redSub(u2);\r\n        var r = s1.redSub(s2);\r\n        if (h.cmpn(0) === 0) {\r\n          if (r.cmpn(0) !== 0)\r\n            return this.curve.jpoint(null, null, null);\r\n          else\r\n            return this.dbl();\r\n        }\r\n\r\n        var h2 = h.redSqr();\r\n        var h3 = h2.redMul(h);\r\n        var v = u1.redMul(h2);\r\n\r\n        var nx = r.redSqr().redIAdd(h3).redISub(v).redISub(v);\r\n        var ny = r.redMul(v.redISub(nx)).redISub(s1.redMul(h3));\r\n        var nz = this.z.redMul(p.z).redMul(h);\r\n\r\n        return this.curve.jpoint(nx, ny, nz);\r\n      };\r\n\r\n      JPoint.prototype.mixedAdd = function mixedAdd(p) {\r\n        // O + P = P\r\n        if (this.isInfinity())\r\n          return p.toJ();\r\n\r\n        // P + O = P\r\n        if (p.isInfinity())\r\n          return this;\r\n\r\n        // 8M + 3S + 7A\r\n        var z2 = this.z.redSqr();\r\n        var u1 = this.x;\r\n        var u2 = p.x.redMul(z2);\r\n        var s1 = this.y;\r\n        var s2 = p.y.redMul(z2).redMul(this.z);\r\n\r\n        var h = u1.redSub(u2);\r\n        var r = s1.redSub(s2);\r\n        if (h.cmpn(0) === 0) {\r\n          if (r.cmpn(0) !== 0)\r\n            return this.curve.jpoint(null, null, null);\r\n          else\r\n            return this.dbl();\r\n        }\r\n\r\n        var h2 = h.redSqr();\r\n        var h3 = h2.redMul(h);\r\n        var v = u1.redMul(h2);\r\n\r\n        var nx = r.redSqr().redIAdd(h3).redISub(v).redISub(v);\r\n        var ny = r.redMul(v.redISub(nx)).redISub(s1.redMul(h3));\r\n        var nz = this.z.redMul(h);\r\n\r\n        return this.curve.jpoint(nx, ny, nz);\r\n      };\r\n\r\n      JPoint.prototype.dblp = function dblp(pow) {\r\n        if (pow === 0)\r\n          return this;\r\n        if (this.isInfinity())\r\n          return this;\r\n        if (!pow)\r\n          return this.dbl();\r\n\r\n        if (this.curve.zeroA || this.curve.threeA) {\r\n          var r = this;\r\n          for (var i = 0; i < pow; i++)\r\n            r = r.dbl();\r\n          return r;\r\n        }\r\n\r\n        // 1M + 2S + 1A + N * (4S + 5M + 8A)\r\n        // N = 1 => 6M + 6S + 9A\r\n        var a = this.curve.a;\r\n        var tinv = this.curve.tinv;\r\n\r\n        var jx = this.x;\r\n        var jy = this.y;\r\n        var jz = this.z;\r\n        var jz4 = jz.redSqr().redSqr();\r\n\r\n        // Reuse results\r\n        var jyd = jy.redAdd(jy);\r\n        for (var i = 0; i < pow; i++) {\r\n          var jx2 = jx.redSqr();\r\n          var jyd2 = jyd.redSqr();\r\n          var jyd4 = jyd2.redSqr();\r\n          var c = jx2.redAdd(jx2).redIAdd(jx2).redIAdd(a.redMul(jz4));\r\n\r\n          var t1 = jx.redMul(jyd2);\r\n          var nx = c.redSqr().redISub(t1.redAdd(t1));\r\n          var t2 = t1.redISub(nx);\r\n          var dny = c.redMul(t2);\r\n          dny = dny.redIAdd(dny).redISub(jyd4);\r\n          var nz = jyd.redMul(jz);\r\n          if (i + 1 < pow)\r\n            jz4 = jz4.redMul(jyd4);\r\n\r\n          jx = nx;\r\n          jz = nz;\r\n          jyd = dny;\r\n        }\r\n\r\n        return this.curve.jpoint(jx, jyd.redMul(tinv), jz);\r\n      };\r\n\r\n      JPoint.prototype.dbl = function dbl() {\r\n        if (this.isInfinity())\r\n          return this;\r\n\r\n        if (this.curve.zeroA)\r\n          return this._zeroDbl();\r\n        else if (this.curve.threeA)\r\n          return this._threeDbl();\r\n        else\r\n          return this._dbl();\r\n      };\r\n\r\n      JPoint.prototype._zeroDbl = function _zeroDbl() {\r\n        var nx;\r\n        var ny;\r\n        var nz;\r\n        // Z = 1\r\n        if (this.zOne) {\r\n          // hyperelliptic.org/EFD/g1p/auto-shortw-jacobian-0.html\r\n          //     #doubling-mdbl-2007-bl\r\n          // 1M + 5S + 14A\r\n\r\n          // XX = X1^2\r\n          var xx = this.x.redSqr();\r\n          // YY = Y1^2\r\n          var yy = this.y.redSqr();\r\n          // YYYY = YY^2\r\n          var yyyy = yy.redSqr();\r\n          // S = 2 * ((X1 + YY)^2 - XX - YYYY)\r\n          var s = this.x.redAdd(yy).redSqr().redISub(xx).redISub(yyyy);\r\n          s = s.redIAdd(s);\r\n          // M = 3 * XX + a; a = 0\r\n          var m = xx.redAdd(xx).redIAdd(xx);\r\n          // T = M ^ 2 - 2*S\r\n          var t = m.redSqr().redISub(s).redISub(s);\r\n\r\n          // 8 * YYYY\r\n          var yyyy8 = yyyy.redIAdd(yyyy);\r\n          yyyy8 = yyyy8.redIAdd(yyyy8);\r\n          yyyy8 = yyyy8.redIAdd(yyyy8);\r\n\r\n          // X3 = T\r\n          nx = t;\r\n          // Y3 = M * (S - T) - 8 * YYYY\r\n          ny = m.redMul(s.redISub(t)).redISub(yyyy8);\r\n          // Z3 = 2*Y1\r\n          nz = this.y.redAdd(this.y);\r\n        } else {\r\n          // hyperelliptic.org/EFD/g1p/auto-shortw-jacobian-0.html\r\n          //     #doubling-dbl-2009-l\r\n          // 2M + 5S + 13A\r\n\r\n          // A = X1^2\r\n          var a = this.x.redSqr();\r\n          // B = Y1^2\r\n          var b = this.y.redSqr();\r\n          // C = B^2\r\n          var c = b.redSqr();\r\n          // D = 2 * ((X1 + B)^2 - A - C)\r\n          var d = this.x.redAdd(b).redSqr().redISub(a).redISub(c);\r\n          d = d.redIAdd(d);\r\n          // E = 3 * A\r\n          var e = a.redAdd(a).redIAdd(a);\r\n          // F = E^2\r\n          var f = e.redSqr();\r\n\r\n          // 8 * C\r\n          var c8 = c.redIAdd(c);\r\n          c8 = c8.redIAdd(c8);\r\n          c8 = c8.redIAdd(c8);\r\n\r\n          // X3 = F - 2 * D\r\n          nx = f.redISub(d).redISub(d);\r\n          // Y3 = E * (D - X3) - 8 * C\r\n          ny = e.redMul(d.redISub(nx)).redISub(c8);\r\n          // Z3 = 2 * Y1 * Z1\r\n          nz = this.y.redMul(this.z);\r\n          nz = nz.redIAdd(nz);\r\n        }\r\n\r\n        return this.curve.jpoint(nx, ny, nz);\r\n      };\r\n\r\n      JPoint.prototype._threeDbl = function _threeDbl() {\r\n        var nx;\r\n        var ny;\r\n        var nz;\r\n        // Z = 1\r\n        if (this.zOne) {\r\n          // hyperelliptic.org/EFD/g1p/auto-shortw-jacobian-3.html\r\n          //     #doubling-mdbl-2007-bl\r\n          // 1M + 5S + 15A\r\n\r\n          // XX = X1^2\r\n          var xx = this.x.redSqr();\r\n          // YY = Y1^2\r\n          var yy = this.y.redSqr();\r\n          // YYYY = YY^2\r\n          var yyyy = yy.redSqr();\r\n          // S = 2 * ((X1 + YY)^2 - XX - YYYY)\r\n          var s = this.x.redAdd(yy).redSqr().redISub(xx).redISub(yyyy);\r\n          s = s.redIAdd(s);\r\n          // M = 3 * XX + a\r\n          var m = xx.redAdd(xx).redIAdd(xx).redIAdd(this.curve.a);\r\n          // T = M^2 - 2 * S\r\n          var t = m.redSqr().redISub(s).redISub(s);\r\n          // X3 = T\r\n          nx = t;\r\n          // Y3 = M * (S - T) - 8 * YYYY\r\n          var yyyy8 = yyyy.redIAdd(yyyy);\r\n          yyyy8 = yyyy8.redIAdd(yyyy8);\r\n          yyyy8 = yyyy8.redIAdd(yyyy8);\r\n          ny = m.redMul(s.redISub(t)).redISub(yyyy8);\r\n          // Z3 = 2 * Y1\r\n          nz = this.y.redAdd(this.y);\r\n        } else {\r\n          // hyperelliptic.org/EFD/g1p/auto-shortw-jacobian-3.html#doubling-dbl-2001-b\r\n          // 3M + 5S\r\n\r\n          // delta = Z1^2\r\n          var delta = this.z.redSqr();\r\n          // gamma = Y1^2\r\n          var gamma = this.y.redSqr();\r\n          // beta = X1 * gamma\r\n          var beta = this.x.redMul(gamma);\r\n          // alpha = 3 * (X1 - delta) * (X1 + delta)\r\n          var alpha = this.x.redSub(delta).redMul(this.x.redAdd(delta));\r\n          alpha = alpha.redAdd(alpha).redIAdd(alpha);\r\n          // X3 = alpha^2 - 8 * beta\r\n          var beta4 = beta.redIAdd(beta);\r\n          beta4 = beta4.redIAdd(beta4);\r\n          var beta8 = beta4.redAdd(beta4);\r\n          nx = alpha.redSqr().redISub(beta8);\r\n          // Z3 = (Y1 + Z1)^2 - gamma - delta\r\n          nz = this.y.redAdd(this.z).redSqr().redISub(gamma).redISub(delta);\r\n          // Y3 = alpha * (4 * beta - X3) - 8 * gamma^2\r\n          var ggamma8 = gamma.redSqr();\r\n          ggamma8 = ggamma8.redIAdd(ggamma8);\r\n          ggamma8 = ggamma8.redIAdd(ggamma8);\r\n          ggamma8 = ggamma8.redIAdd(ggamma8);\r\n          ny = alpha.redMul(beta4.redISub(nx)).redISub(ggamma8);\r\n        }\r\n\r\n        return this.curve.jpoint(nx, ny, nz);\r\n      };\r\n\r\n      JPoint.prototype._dbl = function _dbl() {\r\n        var a = this.curve.a;\r\n\r\n        // 4M + 6S + 10A\r\n        var jx = this.x;\r\n        var jy = this.y;\r\n        var jz = this.z;\r\n        var jz4 = jz.redSqr().redSqr();\r\n\r\n        var jx2 = jx.redSqr();\r\n        var jy2 = jy.redSqr();\r\n\r\n        var c = jx2.redAdd(jx2).redIAdd(jx2).redIAdd(a.redMul(jz4));\r\n\r\n        var jxd4 = jx.redAdd(jx);\r\n        jxd4 = jxd4.redIAdd(jxd4);\r\n        var t1 = jxd4.redMul(jy2);\r\n        var nx = c.redSqr().redISub(t1.redAdd(t1));\r\n        var t2 = t1.redISub(nx);\r\n\r\n        var jyd8 = jy2.redSqr();\r\n        jyd8 = jyd8.redIAdd(jyd8);\r\n        jyd8 = jyd8.redIAdd(jyd8);\r\n        jyd8 = jyd8.redIAdd(jyd8);\r\n        var ny = c.redMul(t2).redISub(jyd8);\r\n        var nz = jy.redAdd(jy).redMul(jz);\r\n\r\n        return this.curve.jpoint(nx, ny, nz);\r\n      };\r\n\r\n      JPoint.prototype.trpl = function trpl() {\r\n        if (!this.curve.zeroA)\r\n          return this.dbl().add(this);\r\n\r\n        // hyperelliptic.org/EFD/g1p/auto-shortw-jacobian-0.html#tripling-tpl-2007-bl\r\n        // 5M + 10S + ...\r\n\r\n        // XX = X1^2\r\n        var xx = this.x.redSqr();\r\n        // YY = Y1^2\r\n        var yy = this.y.redSqr();\r\n        // ZZ = Z1^2\r\n        var zz = this.z.redSqr();\r\n        // YYYY = YY^2\r\n        var yyyy = yy.redSqr();\r\n        // M = 3 * XX + a * ZZ2; a = 0\r\n        var m = xx.redAdd(xx).redIAdd(xx);\r\n        // MM = M^2\r\n        var mm = m.redSqr();\r\n        // E = 6 * ((X1 + YY)^2 - XX - YYYY) - MM\r\n        var e = this.x.redAdd(yy).redSqr().redISub(xx).redISub(yyyy);\r\n        e = e.redIAdd(e);\r\n        e = e.redAdd(e).redIAdd(e);\r\n        e = e.redISub(mm);\r\n        // EE = E^2\r\n        var ee = e.redSqr();\r\n        // T = 16*YYYY\r\n        var t = yyyy.redIAdd(yyyy);\r\n        t = t.redIAdd(t);\r\n        t = t.redIAdd(t);\r\n        t = t.redIAdd(t);\r\n        // U = (M + E)^2 - MM - EE - T\r\n        var u = m.redIAdd(e).redSqr().redISub(mm).redISub(ee).redISub(t);\r\n        // X3 = 4 * (X1 * EE - 4 * YY * U)\r\n        var yyu4 = yy.redMul(u);\r\n        yyu4 = yyu4.redIAdd(yyu4);\r\n        yyu4 = yyu4.redIAdd(yyu4);\r\n        var nx = this.x.redMul(ee).redISub(yyu4);\r\n        nx = nx.redIAdd(nx);\r\n        nx = nx.redIAdd(nx);\r\n        // Y3 = 8 * Y1 * (U * (T - U) - E * EE)\r\n        var ny = this.y.redMul(u.redMul(t.redISub(u)).redISub(e.redMul(ee)));\r\n        ny = ny.redIAdd(ny);\r\n        ny = ny.redIAdd(ny);\r\n        ny = ny.redIAdd(ny);\r\n        // Z3 = (Z1 + E)^2 - ZZ - EE\r\n        var nz = this.z.redAdd(e).redSqr().redISub(zz).redISub(ee);\r\n\r\n        return this.curve.jpoint(nx, ny, nz);\r\n      };\r\n\r\n      JPoint.prototype.mul = function mul(k, kbase) {\r\n        k = new BN(k, kbase);\r\n\r\n        return this.curve._wnafMul(this, k);\r\n      };\r\n\r\n      JPoint.prototype.eq = function eq(p) {\r\n        if (p.type === 'affine')\r\n          return this.eq(p.toJ());\r\n\r\n        if (this === p)\r\n          return true;\r\n\r\n        // x1 * z2^2 == x2 * z1^2\r\n        var z2 = this.z.redSqr();\r\n        var pz2 = p.z.redSqr();\r\n        if (this.x.redMul(pz2).redISub(p.x.redMul(z2)).cmpn(0) !== 0)\r\n          return false;\r\n\r\n        // y1 * z2^3 == y2 * z1^3\r\n        var z3 = z2.redMul(this.z);\r\n        var pz3 = pz2.redMul(p.z);\r\n        return this.y.redMul(pz3).redISub(p.y.redMul(z3)).cmpn(0) === 0;\r\n      };\r\n\r\n      JPoint.prototype.eqXToP = function eqXToP(x) {\r\n        var zs = this.z.redSqr();\r\n        var rx = x.toRed(this.curve.red).redMul(zs);\r\n        if (this.x.cmp(rx) === 0)\r\n          return true;\r\n\r\n        var xc = x.clone();\r\n        var t = this.curve.redN.redMul(zs);\r\n        for (;;) {\r\n          xc.iadd(this.curve.n);\r\n          if (xc.cmp(this.curve.p) >= 0)\r\n            return false;\r\n\r\n          rx.redIAdd(t);\r\n          if (this.x.cmp(rx) === 0)\r\n            return true;\r\n        }\r\n      };\r\n\r\n      JPoint.prototype.inspect = function inspect() {\r\n        if (this.isInfinity())\r\n          return '<EC JPoint Infinity>';\r\n        return '<EC JPoint x: ' + this.x.toString(16, 2) +\r\n          ' y: ' + this.y.toString(16, 2) +\r\n          ' z: ' + this.z.toString(16, 2) + '>';\r\n      };\r\n\r\n      JPoint.prototype.isInfinity = function isInfinity() {\r\n        // XXX This code assumes that zero is always zero in red\r\n        return this.z.cmpn(0) === 0;\r\n      };\r\n\r\n    }, {\r\n      \"../../elliptic\": 73,\r\n      \"../curve\": 76,\r\n      \"bn.js\": 23,\r\n      \"inherits\": 106\r\n    }],\r\n    79: [function (require, module, exports) {\r\n      'use strict';\r\n\r\n      var curves = exports;\r\n\r\n      var hash = require('hash.js');\r\n      var elliptic = require('../elliptic');\r\n\r\n      var assert = elliptic.utils.assert;\r\n\r\n      function PresetCurve(options) {\r\n        if (options.type === 'short')\r\n          this.curve = new elliptic.curve.short(options);\r\n        else if (options.type === 'edwards')\r\n          this.curve = new elliptic.curve.edwards(options);\r\n        else\r\n          this.curve = new elliptic.curve.mont(options);\r\n        this.g = this.curve.g;\r\n        this.n = this.curve.n;\r\n        this.hash = options.hash;\r\n\r\n        assert(this.g.validate(), 'Invalid curve');\r\n        assert(this.g.mul(this.n).isInfinity(), 'Invalid curve, G*N != O');\r\n      }\r\n      curves.PresetCurve = PresetCurve;\r\n\r\n      function defineCurve(name, options) {\r\n        Object.defineProperty(curves, name, {\r\n          configurable: true,\r\n          enumerable: true,\r\n          get: function () {\r\n            var curve = new PresetCurve(options);\r\n            Object.defineProperty(curves, name, {\r\n              configurable: true,\r\n              enumerable: true,\r\n              value: curve\r\n            });\r\n            return curve;\r\n          }\r\n        });\r\n      }\r\n\r\n      defineCurve('p192', {\r\n        type: 'short',\r\n        prime: 'p192',\r\n        p: 'ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff',\r\n        a: 'ffffffff ffffffff ffffffff fffffffe ffffffff fffffffc',\r\n        b: '64210519 e59c80e7 0fa7e9ab 72243049 feb8deec c146b9b1',\r\n        n: 'ffffffff ffffffff ffffffff 99def836 146bc9b1 b4d22831',\r\n        hash: hash.sha256,\r\n        gRed: false,\r\n        g: [\r\n          '188da80e b03090f6 7cbf20eb 43a18800 f4ff0afd 82ff1012',\r\n          '07192b95 ffc8da78 631011ed 6b24cdd5 73f977a1 1e794811'\r\n        ]\r\n      });\r\n\r\n      defineCurve('p224', {\r\n        type: 'short',\r\n        prime: 'p224',\r\n        p: 'ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001',\r\n        a: 'ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff fffffffe',\r\n        b: 'b4050a85 0c04b3ab f5413256 5044b0b7 d7bfd8ba 270b3943 2355ffb4',\r\n        n: 'ffffffff ffffffff ffffffff ffff16a2 e0b8f03e 13dd2945 5c5c2a3d',\r\n        hash: hash.sha256,\r\n        gRed: false,\r\n        g: [\r\n          'b70e0cbd 6bb4bf7f 321390b9 4a03c1d3 56c21122 343280d6 115c1d21',\r\n          'bd376388 b5f723fb 4c22dfe6 cd4375a0 5a074764 44d58199 85007e34'\r\n        ]\r\n      });\r\n\r\n      defineCurve('p256', {\r\n        type: 'short',\r\n        prime: null,\r\n        p: 'ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff ffffffff',\r\n        a: 'ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff fffffffc',\r\n        b: '5ac635d8 aa3a93e7 b3ebbd55 769886bc 651d06b0 cc53b0f6 3bce3c3e 27d2604b',\r\n        n: 'ffffffff 00000000 ffffffff ffffffff bce6faad a7179e84 f3b9cac2 fc632551',\r\n        hash: hash.sha256,\r\n        gRed: false,\r\n        g: [\r\n          '6b17d1f2 e12c4247 f8bce6e5 63a440f2 77037d81 2deb33a0 f4a13945 d898c296',\r\n          '4fe342e2 fe1a7f9b 8ee7eb4a 7c0f9e16 2bce3357 6b315ece cbb64068 37bf51f5'\r\n        ]\r\n      });\r\n\r\n      defineCurve('p384', {\r\n        type: 'short',\r\n        prime: null,\r\n        p: 'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ' +\r\n          'fffffffe ffffffff 00000000 00000000 ffffffff',\r\n        a: 'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ' +\r\n          'fffffffe ffffffff 00000000 00000000 fffffffc',\r\n        b: 'b3312fa7 e23ee7e4 988e056b e3f82d19 181d9c6e fe814112 0314088f ' +\r\n          '5013875a c656398d 8a2ed19d 2a85c8ed d3ec2aef',\r\n        n: 'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff c7634d81 ' +\r\n          'f4372ddf 581a0db2 48b0a77a ecec196a ccc52973',\r\n        hash: hash.sha384,\r\n        gRed: false,\r\n        g: [\r\n          'aa87ca22 be8b0537 8eb1c71e f320ad74 6e1d3b62 8ba79b98 59f741e0 82542a38 ' +\r\n          '5502f25d bf55296c 3a545e38 72760ab7',\r\n          '3617de4a 96262c6f 5d9e98bf 9292dc29 f8f41dbd 289a147c e9da3113 b5f0b8c0 ' +\r\n          '0a60b1ce 1d7e819d 7a431d7c 90ea0e5f'\r\n        ]\r\n      });\r\n\r\n      defineCurve('p521', {\r\n        type: 'short',\r\n        prime: null,\r\n        p: '000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ' +\r\n          'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ' +\r\n          'ffffffff ffffffff ffffffff ffffffff ffffffff',\r\n        a: '000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ' +\r\n          'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ' +\r\n          'ffffffff ffffffff ffffffff ffffffff fffffffc',\r\n        b: '00000051 953eb961 8e1c9a1f 929a21a0 b68540ee a2da725b ' +\r\n          '99b315f3 b8b48991 8ef109e1 56193951 ec7e937b 1652c0bd ' +\r\n          '3bb1bf07 3573df88 3d2c34f1 ef451fd4 6b503f00',\r\n        n: '000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ' +\r\n          'ffffffff ffffffff fffffffa 51868783 bf2f966b 7fcc0148 ' +\r\n          'f709a5d0 3bb5c9b8 899c47ae bb6fb71e 91386409',\r\n        hash: hash.sha512,\r\n        gRed: false,\r\n        g: [\r\n          '000000c6 858e06b7 0404e9cd 9e3ecb66 2395b442 9c648139 ' +\r\n          '053fb521 f828af60 6b4d3dba a14b5e77 efe75928 fe1dc127 ' +\r\n          'a2ffa8de 3348b3c1 856a429b f97e7e31 c2e5bd66',\r\n          '00000118 39296a78 9a3bc004 5c8a5fb4 2c7d1bd9 98f54449 ' +\r\n          '579b4468 17afbd17 273e662c 97ee7299 5ef42640 c550b901 ' +\r\n          '3fad0761 353c7086 a272c240 88be9476 9fd16650'\r\n        ]\r\n      });\r\n\r\n      defineCurve('curve25519', {\r\n        type: 'mont',\r\n        prime: 'p25519',\r\n        p: '7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed',\r\n        a: '76d06',\r\n        b: '1',\r\n        n: '1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed',\r\n        hash: hash.sha256,\r\n        gRed: false,\r\n        g: [\r\n          '9'\r\n        ]\r\n      });\r\n\r\n      defineCurve('ed25519', {\r\n        type: 'edwards',\r\n        prime: 'p25519',\r\n        p: '7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed',\r\n        a: '-1',\r\n        c: '1',\r\n        // -121665 * (121666^(-1)) (mod P)\r\n        d: '52036cee2b6ffe73 8cc740797779e898 00700a4d4141d8ab 75eb4dca135978a3',\r\n        n: '1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed',\r\n        hash: hash.sha256,\r\n        gRed: false,\r\n        g: [\r\n          '216936d3cd6e53fec0a4e231fdd6dc5c692cc7609525a7b2c9562d608f25d51a',\r\n\r\n          // 4/5\r\n          '6666666666666666666666666666666666666666666666666666666666666658'\r\n        ]\r\n      });\r\n\r\n      var pre;\r\n      try {\r\n        pre = require('./precomputed/secp256k1');\r\n      } catch (e) {\r\n        pre = undefined;\r\n      }\r\n\r\n      defineCurve('secp256k1', {\r\n        type: 'short',\r\n        prime: 'k256',\r\n        p: 'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f',\r\n        a: '0',\r\n        b: '7',\r\n        n: 'ffffffff ffffffff ffffffff fffffffe baaedce6 af48a03b bfd25e8c d0364141',\r\n        h: '1',\r\n        hash: hash.sha256,\r\n\r\n        // Precomputed endomorphism\r\n        beta: '7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee',\r\n        lambda: '5363ad4cc05c30e0a5261c028812645a122e22ea20816678df02967c1b23bd72',\r\n        basis: [{\r\n            a: '3086d221a7d46bcde86c90e49284eb15',\r\n            b: '-e4437ed6010e88286f547fa90abfe4c3'\r\n          },\r\n          {\r\n            a: '114ca50f7a8e2f3f657c1108d9d44cfd8',\r\n            b: '3086d221a7d46bcde86c90e49284eb15'\r\n          }\r\n        ],\r\n\r\n        gRed: false,\r\n        g: [\r\n          '79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798',\r\n          '483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8',\r\n          pre\r\n        ]\r\n      });\r\n\r\n    }, {\r\n      \"../elliptic\": 73,\r\n      \"./precomputed/secp256k1\": 86,\r\n      \"hash.js\": 92\r\n    }],\r\n    80: [function (require, module, exports) {\r\n      'use strict';\r\n\r\n      var BN = require('bn.js');\r\n      var HmacDRBG = require('hmac-drbg');\r\n      var elliptic = require('../../elliptic');\r\n      var utils = elliptic.utils;\r\n      var assert = utils.assert;\r\n\r\n      var KeyPair = require('./key');\r\n      var Signature = require('./signature');\r\n\r\n      function EC(options) {\r\n        if (!(this instanceof EC))\r\n          return new EC(options);\r\n\r\n        // Shortcut `elliptic.ec(curve-name)`\r\n        if (typeof options === 'string') {\r\n          assert(elliptic.curves.hasOwnProperty(options), 'Unknown curve ' + options);\r\n\r\n          options = elliptic.curves[options];\r\n        }\r\n\r\n        // Shortcut for `elliptic.ec(elliptic.curves.curveName)`\r\n        if (options instanceof elliptic.curves.PresetCurve)\r\n          options = {\r\n            curve: options\r\n          };\r\n\r\n        this.curve = options.curve.curve;\r\n        this.n = this.curve.n;\r\n        this.nh = this.n.ushrn(1);\r\n        this.g = this.curve.g;\r\n\r\n        // Point on curve\r\n        this.g = options.curve.g;\r\n        this.g.precompute(options.curve.n.bitLength() + 1);\r\n\r\n        // Hash for function for DRBG\r\n        this.hash = options.hash || options.curve.hash;\r\n      }\r\n      module.exports = EC;\r\n\r\n      EC.prototype.keyPair = function keyPair(options) {\r\n        return new KeyPair(this, options);\r\n      };\r\n\r\n      EC.prototype.keyFromPrivate = function keyFromPrivate(priv, enc) {\r\n        return KeyPair.fromPrivate(this, priv, enc);\r\n      };\r\n\r\n      EC.prototype.keyFromPublic = function keyFromPublic(pub, enc) {\r\n        return KeyPair.fromPublic(this, pub, enc);\r\n      };\r\n\r\n      EC.prototype.genKeyPair = function genKeyPair(options) {\r\n        if (!options)\r\n          options = {};\r\n\r\n        // Instantiate Hmac_DRBG\r\n        var drbg = new HmacDRBG({\r\n          hash: this.hash,\r\n          pers: options.pers,\r\n          persEnc: options.persEnc || 'utf8',\r\n          entropy: options.entropy || elliptic.rand(this.hash.hmacStrength),\r\n          entropyEnc: options.entropy && options.entropyEnc || 'utf8',\r\n          nonce: this.n.toArray()\r\n        });\r\n\r\n        var bytes = this.n.byteLength();\r\n        var ns2 = this.n.sub(new BN(2));\r\n        do {\r\n          var priv = new BN(drbg.generate(bytes));\r\n          if (priv.cmp(ns2) > 0)\r\n            continue;\r\n\r\n          priv.iaddn(1);\r\n          return this.keyFromPrivate(priv);\r\n        } while (true);\r\n      };\r\n\r\n      EC.prototype._truncateToN = function truncateToN(msg, truncOnly) {\r\n        var delta = msg.byteLength() * 8 - this.n.bitLength();\r\n        if (delta > 0)\r\n          msg = msg.ushrn(delta);\r\n        if (!truncOnly && msg.cmp(this.n) >= 0)\r\n          return msg.sub(this.n);\r\n        else\r\n          return msg;\r\n      };\r\n\r\n      EC.prototype.sign = function sign(msg, key, enc, options) {\r\n        if (typeof enc === 'object') {\r\n          options = enc;\r\n          enc = null;\r\n        }\r\n        if (!options)\r\n          options = {};\r\n\r\n        key = this.keyFromPrivate(key, enc);\r\n        msg = this._truncateToN(new BN(msg, 16));\r\n\r\n        // Zero-extend key to provide enough entropy\r\n        var bytes = this.n.byteLength();\r\n        var bkey = key.getPrivate().toArray('be', bytes);\r\n\r\n        // Zero-extend nonce to have the same byte size as N\r\n        var nonce = msg.toArray('be', bytes);\r\n\r\n        // Instantiate Hmac_DRBG\r\n        var drbg = new HmacDRBG({\r\n          hash: this.hash,\r\n          entropy: bkey,\r\n          nonce: nonce,\r\n          pers: options.pers,\r\n          persEnc: options.persEnc || 'utf8'\r\n        });\r\n\r\n        // Number of bytes to generate\r\n        var ns1 = this.n.sub(new BN(1));\r\n\r\n        for (var iter = 0; true; iter++) {\r\n          var k = options.k ?\r\n            options.k(iter) :\r\n            new BN(drbg.generate(this.n.byteLength()));\r\n          k = this._truncateToN(k, true);\r\n          if (k.cmpn(1) <= 0 || k.cmp(ns1) >= 0)\r\n            continue;\r\n\r\n          var kp = this.g.mul(k);\r\n          if (kp.isInfinity())\r\n            continue;\r\n\r\n          var kpX = kp.getX();\r\n          var r = kpX.umod(this.n);\r\n          if (r.cmpn(0) === 0)\r\n            continue;\r\n\r\n          var s = k.invm(this.n).mul(r.mul(key.getPrivate()).iadd(msg));\r\n          s = s.umod(this.n);\r\n          if (s.cmpn(0) === 0)\r\n            continue;\r\n\r\n          var recoveryParam = (kp.getY().isOdd() ? 1 : 0) |\r\n            (kpX.cmp(r) !== 0 ? 2 : 0);\r\n\r\n          // Use complement of `s`, if it is > `n / 2`\r\n          if (options.canonical && s.cmp(this.nh) > 0) {\r\n            s = this.n.sub(s);\r\n            recoveryParam ^= 1;\r\n          }\r\n\r\n          return new Signature({\r\n            r: r,\r\n            s: s,\r\n            recoveryParam: recoveryParam\r\n          });\r\n        }\r\n      };\r\n\r\n      EC.prototype.verify = function verify(msg, signature, key, enc) {\r\n        msg = this._truncateToN(new BN(msg, 16));\r\n        key = this.keyFromPublic(key, enc);\r\n        signature = new Signature(signature, 'hex');\r\n\r\n        // Perform primitive values validation\r\n        var r = signature.r;\r\n        var s = signature.s;\r\n        if (r.cmpn(1) < 0 || r.cmp(this.n) >= 0)\r\n          return false;\r\n        if (s.cmpn(1) < 0 || s.cmp(this.n) >= 0)\r\n          return false;\r\n\r\n        // Validate signature\r\n        var sinv = s.invm(this.n);\r\n        var u1 = sinv.mul(msg).umod(this.n);\r\n        var u2 = sinv.mul(r).umod(this.n);\r\n\r\n        if (!this.curve._maxwellTrick) {\r\n          var p = this.g.mulAdd(u1, key.getPublic(), u2);\r\n          if (p.isInfinity())\r\n            return false;\r\n\r\n          return p.getX().umod(this.n).cmp(r) === 0;\r\n        }\r\n\r\n        // NOTE: Greg Maxwell's trick, inspired by:\r\n        // https://git.io/vad3K\r\n\r\n        var p = this.g.jmulAdd(u1, key.getPublic(), u2);\r\n        if (p.isInfinity())\r\n          return false;\r\n\r\n        // Compare `p.x` of Jacobian point with `r`,\r\n        // this will do `p.x == r * p.z^2` instead of multiplying `p.x` by the\r\n        // inverse of `p.z^2`\r\n        return p.eqXToP(r);\r\n      };\r\n\r\n      EC.prototype.recoverPubKey = function (msg, signature, j, enc) {\r\n        assert((3 & j) === j, 'The recovery param is more than two bits');\r\n        signature = new Signature(signature, enc);\r\n\r\n        var n = this.n;\r\n        var e = new BN(msg);\r\n        var r = signature.r;\r\n        var s = signature.s;\r\n\r\n        // A set LSB signifies that the y-coordinate is odd\r\n        var isYOdd = j & 1;\r\n        var isSecondKey = j >> 1;\r\n        if (r.cmp(this.curve.p.umod(this.curve.n)) >= 0 && isSecondKey)\r\n          throw new Error('Unable to find sencond key candinate');\r\n\r\n        // 1.1. Let x = r + jn.\r\n        if (isSecondKey)\r\n          r = this.curve.pointFromX(r.add(this.curve.n), isYOdd);\r\n        else\r\n          r = this.curve.pointFromX(r, isYOdd);\r\n\r\n        var rInv = signature.r.invm(n);\r\n        var s1 = n.sub(e).mul(rInv).umod(n);\r\n        var s2 = s.mul(rInv).umod(n);\r\n\r\n        // 1.6.1 Compute Q = r^-1 (sR -  eG)\r\n        //               Q = r^-1 (sR + -eG)\r\n        return this.g.mulAdd(s1, r, s2);\r\n      };\r\n\r\n      EC.prototype.getKeyRecoveryParam = function (e, signature, Q, enc) {\r\n        signature = new Signature(signature, enc);\r\n        if (signature.recoveryParam !== null)\r\n          return signature.recoveryParam;\r\n\r\n        for (var i = 0; i < 4; i++) {\r\n          var Qprime;\r\n          try {\r\n            Qprime = this.recoverPubKey(e, signature, i);\r\n          } catch (e) {\r\n            continue;\r\n          }\r\n\r\n          if (Qprime.eq(Q))\r\n            return i;\r\n        }\r\n        throw new Error('Unable to find valid recovery factor');\r\n      };\r\n\r\n    }, {\r\n      \"../../elliptic\": 73,\r\n      \"./key\": 81,\r\n      \"./signature\": 82,\r\n      \"bn.js\": 23,\r\n      \"hmac-drbg\": 104\r\n    }],\r\n    81: [function (require, module, exports) {\r\n      'use strict';\r\n\r\n      var BN = require('bn.js');\r\n      var elliptic = require('../../elliptic');\r\n      var utils = elliptic.utils;\r\n      var assert = utils.assert;\r\n\r\n      function KeyPair(ec, options) {\r\n        this.ec = ec;\r\n        this.priv = null;\r\n        this.pub = null;\r\n\r\n        // KeyPair(ec, { priv: ..., pub: ... })\r\n        if (options.priv)\r\n          this._importPrivate(options.priv, options.privEnc);\r\n        if (options.pub)\r\n          this._importPublic(options.pub, options.pubEnc);\r\n      }\r\n      module.exports = KeyPair;\r\n\r\n      KeyPair.fromPublic = function fromPublic(ec, pub, enc) {\r\n        if (pub instanceof KeyPair)\r\n          return pub;\r\n\r\n        return new KeyPair(ec, {\r\n          pub: pub,\r\n          pubEnc: enc\r\n        });\r\n      };\r\n\r\n      KeyPair.fromPrivate = function fromPrivate(ec, priv, enc) {\r\n        if (priv instanceof KeyPair)\r\n          return priv;\r\n\r\n        return new KeyPair(ec, {\r\n          priv: priv,\r\n          privEnc: enc\r\n        });\r\n      };\r\n\r\n      KeyPair.prototype.validate = function validate() {\r\n        var pub = this.getPublic();\r\n\r\n        if (pub.isInfinity())\r\n          return {\r\n            result: false,\r\n            reason: 'Invalid public key'\r\n          };\r\n        if (!pub.validate())\r\n          return {\r\n            result: false,\r\n            reason: 'Public key is not a point'\r\n          };\r\n        if (!pub.mul(this.ec.curve.n).isInfinity())\r\n          return {\r\n            result: false,\r\n            reason: 'Public key * N != O'\r\n          };\r\n\r\n        return {\r\n          result: true,\r\n          reason: null\r\n        };\r\n      };\r\n\r\n      KeyPair.prototype.getPublic = function getPublic(compact, enc) {\r\n        // compact is optional argument\r\n        if (typeof compact === 'string') {\r\n          enc = compact;\r\n          compact = null;\r\n        }\r\n\r\n        if (!this.pub)\r\n          this.pub = this.ec.g.mul(this.priv);\r\n\r\n        if (!enc)\r\n          return this.pub;\r\n\r\n        return this.pub.encode(enc, compact);\r\n      };\r\n\r\n      KeyPair.prototype.getPrivate = function getPrivate(enc) {\r\n        if (enc === 'hex')\r\n          return this.priv.toString(16, 2);\r\n        else\r\n          return this.priv;\r\n      };\r\n\r\n      KeyPair.prototype._importPrivate = function _importPrivate(key, enc) {\r\n        this.priv = new BN(key, enc || 16);\r\n\r\n        // Ensure that the priv won't be bigger than n, otherwise we may fail\r\n        // in fixed multiplication method\r\n        this.priv = this.priv.umod(this.ec.curve.n);\r\n      };\r\n\r\n      KeyPair.prototype._importPublic = function _importPublic(key, enc) {\r\n        if (key.x || key.y) {\r\n          // Montgomery points only have an `x` coordinate.\r\n          // Weierstrass/Edwards points on the other hand have both `x` and\r\n          // `y` coordinates.\r\n          if (this.ec.curve.type === 'mont') {\r\n            assert(key.x, 'Need x coordinate');\r\n          } else if (this.ec.curve.type === 'short' ||\r\n            this.ec.curve.type === 'edwards') {\r\n            assert(key.x && key.y, 'Need both x and y coordinate');\r\n          }\r\n          this.pub = this.ec.curve.point(key.x, key.y);\r\n          return;\r\n        }\r\n        this.pub = this.ec.curve.decodePoint(key, enc);\r\n      };\r\n\r\n      // ECDH\r\n      KeyPair.prototype.derive = function derive(pub) {\r\n        return pub.mul(this.priv).getX();\r\n      };\r\n\r\n      // ECDSA\r\n      KeyPair.prototype.sign = function sign(msg, enc, options) {\r\n        return this.ec.sign(msg, this, enc, options);\r\n      };\r\n\r\n      KeyPair.prototype.verify = function verify(msg, signature) {\r\n        return this.ec.verify(msg, signature, this);\r\n      };\r\n\r\n      KeyPair.prototype.inspect = function inspect() {\r\n        return '<Key priv: ' + (this.priv && this.priv.toString(16, 2)) +\r\n          ' pub: ' + (this.pub && this.pub.inspect()) + ' >';\r\n      };\r\n\r\n    }, {\r\n      \"../../elliptic\": 73,\r\n      \"bn.js\": 23\r\n    }],\r\n    82: [function (require, module, exports) {\r\n      'use strict';\r\n\r\n      var BN = require('bn.js');\r\n\r\n      var elliptic = require('../../elliptic');\r\n      var utils = elliptic.utils;\r\n      var assert = utils.assert;\r\n\r\n      function Signature(options, enc) {\r\n        if (options instanceof Signature)\r\n          return options;\r\n\r\n        if (this._importDER(options, enc))\r\n          return;\r\n\r\n        assert(options.r && options.s, 'Signature without r or s');\r\n        this.r = new BN(options.r, 16);\r\n        this.s = new BN(options.s, 16);\r\n        if (options.recoveryParam === undefined)\r\n          this.recoveryParam = null;\r\n        else\r\n          this.recoveryParam = options.recoveryParam;\r\n      }\r\n      module.exports = Signature;\r\n\r\n      function Position() {\r\n        this.place = 0;\r\n      }\r\n\r\n      function getLength(buf, p) {\r\n        var initial = buf[p.place++];\r\n        if (!(initial & 0x80)) {\r\n          return initial;\r\n        }\r\n        var octetLen = initial & 0xf;\r\n        var val = 0;\r\n        for (var i = 0, off = p.place; i < octetLen; i++, off++) {\r\n          val <<= 8;\r\n          val |= buf[off];\r\n        }\r\n        p.place = off;\r\n        return val;\r\n      }\r\n\r\n      function rmPadding(buf) {\r\n        var i = 0;\r\n        var len = buf.length - 1;\r\n        while (!buf[i] && !(buf[i + 1] & 0x80) && i < len) {\r\n          i++;\r\n        }\r\n        if (i === 0) {\r\n          return buf;\r\n        }\r\n        return buf.slice(i);\r\n      }\r\n\r\n      Signature.prototype._importDER = function _importDER(data, enc) {\r\n        data = utils.toArray(data, enc);\r\n        var p = new Position();\r\n        if (data[p.place++] !== 0x30) {\r\n          return false;\r\n        }\r\n        var len = getLength(data, p);\r\n        if ((len + p.place) !== data.length) {\r\n          return false;\r\n        }\r\n        if (data[p.place++] !== 0x02) {\r\n          return false;\r\n        }\r\n        var rlen = getLength(data, p);\r\n        var r = data.slice(p.place, rlen + p.place);\r\n        p.place += rlen;\r\n        if (data[p.place++] !== 0x02) {\r\n          return false;\r\n        }\r\n        var slen = getLength(data, p);\r\n        if (data.length !== slen + p.place) {\r\n          return false;\r\n        }\r\n        var s = data.slice(p.place, slen + p.place);\r\n        if (r[0] === 0 && (r[1] & 0x80)) {\r\n          r = r.slice(1);\r\n        }\r\n        if (s[0] === 0 && (s[1] & 0x80)) {\r\n          s = s.slice(1);\r\n        }\r\n\r\n        this.r = new BN(r);\r\n        this.s = new BN(s);\r\n        this.recoveryParam = null;\r\n\r\n        return true;\r\n      };\r\n\r\n      function constructLength(arr, len) {\r\n        if (len < 0x80) {\r\n          arr.push(len);\r\n          return;\r\n        }\r\n        var octets = 1 + (Math.log(len) / Math.LN2 >>> 3);\r\n        arr.push(octets | 0x80);\r\n        while (--octets) {\r\n          arr.push((len >>> (octets << 3)) & 0xff);\r\n        }\r\n        arr.push(len);\r\n      }\r\n\r\n      Signature.prototype.toDER = function toDER(enc) {\r\n        var r = this.r.toArray();\r\n        var s = this.s.toArray();\r\n\r\n        // Pad values\r\n        if (r[0] & 0x80)\r\n          r = [0].concat(r);\r\n        // Pad values\r\n        if (s[0] & 0x80)\r\n          s = [0].concat(s);\r\n\r\n        r = rmPadding(r);\r\n        s = rmPadding(s);\r\n\r\n        while (!s[0] && !(s[1] & 0x80)) {\r\n          s = s.slice(1);\r\n        }\r\n        var arr = [0x02];\r\n        constructLength(arr, r.length);\r\n        arr = arr.concat(r);\r\n        arr.push(0x02);\r\n        constructLength(arr, s.length);\r\n        var backHalf = arr.concat(s);\r\n        var res = [0x30];\r\n        constructLength(res, backHalf.length);\r\n        res = res.concat(backHalf);\r\n        return utils.encode(res, enc);\r\n      };\r\n\r\n    }, {\r\n      \"../../elliptic\": 73,\r\n      \"bn.js\": 23\r\n    }],\r\n    83: [function (require, module, exports) {\r\n      'use strict';\r\n\r\n      var hash = require('hash.js');\r\n      var elliptic = require('../../elliptic');\r\n      var utils = elliptic.utils;\r\n      var assert = utils.assert;\r\n      var parseBytes = utils.parseBytes;\r\n      var KeyPair = require('./key');\r\n      var Signature = require('./signature');\r\n\r\n      function EDDSA(curve) {\r\n        assert(curve === 'ed25519', 'only tested with ed25519 so far');\r\n\r\n        if (!(this instanceof EDDSA))\r\n          return new EDDSA(curve);\r\n\r\n        var curve = elliptic.curves[curve].curve;\r\n        this.curve = curve;\r\n        this.g = curve.g;\r\n        this.g.precompute(curve.n.bitLength() + 1);\r\n\r\n        this.pointClass = curve.point().constructor;\r\n        this.encodingLength = Math.ceil(curve.n.bitLength() / 8);\r\n        this.hash = hash.sha512;\r\n      }\r\n\r\n      module.exports = EDDSA;\r\n\r\n      /**\r\n       * @param {Array|String} message - message bytes\r\n       * @param {Array|String|KeyPair} secret - secret bytes or a keypair\r\n       * @returns {Signature} - signature\r\n       */\r\n      EDDSA.prototype.sign = function sign(message, secret) {\r\n        message = parseBytes(message);\r\n        var key = this.keyFromSecret(secret);\r\n        var r = this.hashInt(key.messagePrefix(), message);\r\n        var R = this.g.mul(r);\r\n        var Rencoded = this.encodePoint(R);\r\n        var s_ = this.hashInt(Rencoded, key.pubBytes(), message)\r\n          .mul(key.priv());\r\n        var S = r.add(s_).umod(this.curve.n);\r\n        return this.makeSignature({\r\n          R: R,\r\n          S: S,\r\n          Rencoded: Rencoded\r\n        });\r\n      };\r\n\r\n      /**\r\n       * @param {Array} message - message bytes\r\n       * @param {Array|String|Signature} sig - sig bytes\r\n       * @param {Array|String|Point|KeyPair} pub - public key\r\n       * @returns {Boolean} - true if public key matches sig of message\r\n       */\r\n      EDDSA.prototype.verify = function verify(message, sig, pub) {\r\n        message = parseBytes(message);\r\n        sig = this.makeSignature(sig);\r\n        var key = this.keyFromPublic(pub);\r\n        var h = this.hashInt(sig.Rencoded(), key.pubBytes(), message);\r\n        var SG = this.g.mul(sig.S());\r\n        var RplusAh = sig.R().add(key.pub().mul(h));\r\n        return RplusAh.eq(SG);\r\n      };\r\n\r\n      EDDSA.prototype.hashInt = function hashInt() {\r\n        var hash = this.hash();\r\n        for (var i = 0; i < arguments.length; i++)\r\n          hash.update(arguments[i]);\r\n        return utils.intFromLE(hash.digest()).umod(this.curve.n);\r\n      };\r\n\r\n      EDDSA.prototype.keyFromPublic = function keyFromPublic(pub) {\r\n        return KeyPair.fromPublic(this, pub);\r\n      };\r\n\r\n      EDDSA.prototype.keyFromSecret = function keyFromSecret(secret) {\r\n        return KeyPair.fromSecret(this, secret);\r\n      };\r\n\r\n      EDDSA.prototype.makeSignature = function makeSignature(sig) {\r\n        if (sig instanceof Signature)\r\n          return sig;\r\n        return new Signature(this, sig);\r\n      };\r\n\r\n      /**\r\n       * * https://tools.ietf.org/html/draft-josefsson-eddsa-ed25519-03#section-5.2\r\n       *\r\n       * EDDSA defines methods for encoding and decoding points and integers. These are\r\n       * helper convenience methods, that pass along to utility functions implied\r\n       * parameters.\r\n       *\r\n       */\r\n      EDDSA.prototype.encodePoint = function encodePoint(point) {\r\n        var enc = point.getY().toArray('le', this.encodingLength);\r\n        enc[this.encodingLength - 1] |= point.getX().isOdd() ? 0x80 : 0;\r\n        return enc;\r\n      };\r\n\r\n      EDDSA.prototype.decodePoint = function decodePoint(bytes) {\r\n        bytes = utils.parseBytes(bytes);\r\n\r\n        var lastIx = bytes.length - 1;\r\n        var normed = bytes.slice(0, lastIx).concat(bytes[lastIx] & ~0x80);\r\n        var xIsOdd = (bytes[lastIx] & 0x80) !== 0;\r\n\r\n        var y = utils.intFromLE(normed);\r\n        return this.curve.pointFromY(y, xIsOdd);\r\n      };\r\n\r\n      EDDSA.prototype.encodeInt = function encodeInt(num) {\r\n        return num.toArray('le', this.encodingLength);\r\n      };\r\n\r\n      EDDSA.prototype.decodeInt = function decodeInt(bytes) {\r\n        return utils.intFromLE(bytes);\r\n      };\r\n\r\n      EDDSA.prototype.isPoint = function isPoint(val) {\r\n        return val instanceof this.pointClass;\r\n      };\r\n\r\n    }, {\r\n      \"../../elliptic\": 73,\r\n      \"./key\": 84,\r\n      \"./signature\": 85,\r\n      \"hash.js\": 92\r\n    }],\r\n    84: [function (require, module, exports) {\r\n      'use strict';\r\n\r\n      var elliptic = require('../../elliptic');\r\n      var utils = elliptic.utils;\r\n      var assert = utils.assert;\r\n      var parseBytes = utils.parseBytes;\r\n      var cachedProperty = utils.cachedProperty;\r\n\r\n      /**\r\n       * @param {EDDSA} eddsa - instance\r\n       * @param {Object} params - public/private key parameters\r\n       *\r\n       * @param {Array<Byte>} [params.secret] - secret seed bytes\r\n       * @param {Point} [params.pub] - public key point (aka `A` in eddsa terms)\r\n       * @param {Array<Byte>} [params.pub] - public key point encoded as bytes\r\n       *\r\n       */\r\n      function KeyPair(eddsa, params) {\r\n        this.eddsa = eddsa;\r\n        this._secret = parseBytes(params.secret);\r\n        if (eddsa.isPoint(params.pub))\r\n          this._pub = params.pub;\r\n        else\r\n          this._pubBytes = parseBytes(params.pub);\r\n      }\r\n\r\n      KeyPair.fromPublic = function fromPublic(eddsa, pub) {\r\n        if (pub instanceof KeyPair)\r\n          return pub;\r\n        return new KeyPair(eddsa, {\r\n          pub: pub\r\n        });\r\n      };\r\n\r\n      KeyPair.fromSecret = function fromSecret(eddsa, secret) {\r\n        if (secret instanceof KeyPair)\r\n          return secret;\r\n        return new KeyPair(eddsa, {\r\n          secret: secret\r\n        });\r\n      };\r\n\r\n      KeyPair.prototype.secret = function secret() {\r\n        return this._secret;\r\n      };\r\n\r\n      cachedProperty(KeyPair, 'pubBytes', function pubBytes() {\r\n        return this.eddsa.encodePoint(this.pub());\r\n      });\r\n\r\n      cachedProperty(KeyPair, 'pub', function pub() {\r\n        if (this._pubBytes)\r\n          return this.eddsa.decodePoint(this._pubBytes);\r\n        return this.eddsa.g.mul(this.priv());\r\n      });\r\n\r\n      cachedProperty(KeyPair, 'privBytes', function privBytes() {\r\n        var eddsa = this.eddsa;\r\n        var hash = this.hash();\r\n        var lastIx = eddsa.encodingLength - 1;\r\n\r\n        var a = hash.slice(0, eddsa.encodingLength);\r\n        a[0] &= 248;\r\n        a[lastIx] &= 127;\r\n        a[lastIx] |= 64;\r\n\r\n        return a;\r\n      });\r\n\r\n      cachedProperty(KeyPair, 'priv', function priv() {\r\n        return this.eddsa.decodeInt(this.privBytes());\r\n      });\r\n\r\n      cachedProperty(KeyPair, 'hash', function hash() {\r\n        return this.eddsa.hash().update(this.secret()).digest();\r\n      });\r\n\r\n      cachedProperty(KeyPair, 'messagePrefix', function messagePrefix() {\r\n        return this.hash().slice(this.eddsa.encodingLength);\r\n      });\r\n\r\n      KeyPair.prototype.sign = function sign(message) {\r\n        assert(this._secret, 'KeyPair can only verify');\r\n        return this.eddsa.sign(message, this);\r\n      };\r\n\r\n      KeyPair.prototype.verify = function verify(message, sig) {\r\n        return this.eddsa.verify(message, sig, this);\r\n      };\r\n\r\n      KeyPair.prototype.getSecret = function getSecret(enc) {\r\n        assert(this._secret, 'KeyPair is public only');\r\n        return utils.encode(this.secret(), enc);\r\n      };\r\n\r\n      KeyPair.prototype.getPublic = function getPublic(enc) {\r\n        return utils.encode(this.pubBytes(), enc);\r\n      };\r\n\r\n      module.exports = KeyPair;\r\n\r\n    }, {\r\n      \"../../elliptic\": 73\r\n    }],\r\n    85: [function (require, module, exports) {\r\n      'use strict';\r\n\r\n      var BN = require('bn.js');\r\n      var elliptic = require('../../elliptic');\r\n      var utils = elliptic.utils;\r\n      var assert = utils.assert;\r\n      var cachedProperty = utils.cachedProperty;\r\n      var parseBytes = utils.parseBytes;\r\n\r\n      /**\r\n       * @param {EDDSA} eddsa - eddsa instance\r\n       * @param {Array<Bytes>|Object} sig -\r\n       * @param {Array<Bytes>|Point} [sig.R] - R point as Point or bytes\r\n       * @param {Array<Bytes>|bn} [sig.S] - S scalar as bn or bytes\r\n       * @param {Array<Bytes>} [sig.Rencoded] - R point encoded\r\n       * @param {Array<Bytes>} [sig.Sencoded] - S scalar encoded\r\n       */\r\n      function Signature(eddsa, sig) {\r\n        this.eddsa = eddsa;\r\n\r\n        if (typeof sig !== 'object')\r\n          sig = parseBytes(sig);\r\n\r\n        if (Array.isArray(sig)) {\r\n          sig = {\r\n            R: sig.slice(0, eddsa.encodingLength),\r\n            S: sig.slice(eddsa.encodingLength)\r\n          };\r\n        }\r\n\r\n        assert(sig.R && sig.S, 'Signature without R or S');\r\n\r\n        if (eddsa.isPoint(sig.R))\r\n          this._R = sig.R;\r\n        if (sig.S instanceof BN)\r\n          this._S = sig.S;\r\n\r\n        this._Rencoded = Array.isArray(sig.R) ? sig.R : sig.Rencoded;\r\n        this._Sencoded = Array.isArray(sig.S) ? sig.S : sig.Sencoded;\r\n      }\r\n\r\n      cachedProperty(Signature, 'S', function S() {\r\n        return this.eddsa.decodeInt(this.Sencoded());\r\n      });\r\n\r\n      cachedProperty(Signature, 'R', function R() {\r\n        return this.eddsa.decodePoint(this.Rencoded());\r\n      });\r\n\r\n      cachedProperty(Signature, 'Rencoded', function Rencoded() {\r\n        return this.eddsa.encodePoint(this.R());\r\n      });\r\n\r\n      cachedProperty(Signature, 'Sencoded', function Sencoded() {\r\n        return this.eddsa.encodeInt(this.S());\r\n      });\r\n\r\n      Signature.prototype.toBytes = function toBytes() {\r\n        return this.Rencoded().concat(this.Sencoded());\r\n      };\r\n\r\n      Signature.prototype.toHex = function toHex() {\r\n        return utils.encode(this.toBytes(), 'hex').toUpperCase();\r\n      };\r\n\r\n      module.exports = Signature;\r\n\r\n    }, {\r\n      \"../../elliptic\": 73,\r\n      \"bn.js\": 23\r\n    }],\r\n    86: [function (require, module, exports) {\r\n      module.exports = {\r\n        doubles: {\r\n          step: 4,\r\n          points: [\r\n            [\r\n              'e60fce93b59e9ec53011aabc21c23e97b2a31369b87a5ae9c44ee89e2a6dec0a',\r\n              'f7e3507399e595929db99f34f57937101296891e44d23f0be1f32cce69616821'\r\n            ],\r\n            [\r\n              '8282263212c609d9ea2a6e3e172de238d8c39cabd5ac1ca10646e23fd5f51508',\r\n              '11f8a8098557dfe45e8256e830b60ace62d613ac2f7b17bed31b6eaff6e26caf'\r\n            ],\r\n            [\r\n              '175e159f728b865a72f99cc6c6fc846de0b93833fd2222ed73fce5b551e5b739',\r\n              'd3506e0d9e3c79eba4ef97a51ff71f5eacb5955add24345c6efa6ffee9fed695'\r\n            ],\r\n            [\r\n              '363d90d447b00c9c99ceac05b6262ee053441c7e55552ffe526bad8f83ff4640',\r\n              '4e273adfc732221953b445397f3363145b9a89008199ecb62003c7f3bee9de9'\r\n            ],\r\n            [\r\n              '8b4b5f165df3c2be8c6244b5b745638843e4a781a15bcd1b69f79a55dffdf80c',\r\n              '4aad0a6f68d308b4b3fbd7813ab0da04f9e336546162ee56b3eff0c65fd4fd36'\r\n            ],\r\n            [\r\n              '723cbaa6e5db996d6bf771c00bd548c7b700dbffa6c0e77bcb6115925232fcda',\r\n              '96e867b5595cc498a921137488824d6e2660a0653779494801dc069d9eb39f5f'\r\n            ],\r\n            [\r\n              'eebfa4d493bebf98ba5feec812c2d3b50947961237a919839a533eca0e7dd7fa',\r\n              '5d9a8ca3970ef0f269ee7edaf178089d9ae4cdc3a711f712ddfd4fdae1de8999'\r\n            ],\r\n            [\r\n              '100f44da696e71672791d0a09b7bde459f1215a29b3c03bfefd7835b39a48db0',\r\n              'cdd9e13192a00b772ec8f3300c090666b7ff4a18ff5195ac0fbd5cd62bc65a09'\r\n            ],\r\n            [\r\n              'e1031be262c7ed1b1dc9227a4a04c017a77f8d4464f3b3852c8acde6e534fd2d',\r\n              '9d7061928940405e6bb6a4176597535af292dd419e1ced79a44f18f29456a00d'\r\n            ],\r\n            [\r\n              'feea6cae46d55b530ac2839f143bd7ec5cf8b266a41d6af52d5e688d9094696d',\r\n              'e57c6b6c97dce1bab06e4e12bf3ecd5c981c8957cc41442d3155debf18090088'\r\n            ],\r\n            [\r\n              'da67a91d91049cdcb367be4be6ffca3cfeed657d808583de33fa978bc1ec6cb1',\r\n              '9bacaa35481642bc41f463f7ec9780e5dec7adc508f740a17e9ea8e27a68be1d'\r\n            ],\r\n            [\r\n              '53904faa0b334cdda6e000935ef22151ec08d0f7bb11069f57545ccc1a37b7c0',\r\n              '5bc087d0bc80106d88c9eccac20d3c1c13999981e14434699dcb096b022771c8'\r\n            ],\r\n            [\r\n              '8e7bcd0bd35983a7719cca7764ca906779b53a043a9b8bcaeff959f43ad86047',\r\n              '10b7770b2a3da4b3940310420ca9514579e88e2e47fd68b3ea10047e8460372a'\r\n            ],\r\n            [\r\n              '385eed34c1cdff21e6d0818689b81bde71a7f4f18397e6690a841e1599c43862',\r\n              '283bebc3e8ea23f56701de19e9ebf4576b304eec2086dc8cc0458fe5542e5453'\r\n            ],\r\n            [\r\n              '6f9d9b803ecf191637c73a4413dfa180fddf84a5947fbc9c606ed86c3fac3a7',\r\n              '7c80c68e603059ba69b8e2a30e45c4d47ea4dd2f5c281002d86890603a842160'\r\n            ],\r\n            [\r\n              '3322d401243c4e2582a2147c104d6ecbf774d163db0f5e5313b7e0e742d0e6bd',\r\n              '56e70797e9664ef5bfb019bc4ddaf9b72805f63ea2873af624f3a2e96c28b2a0'\r\n            ],\r\n            [\r\n              '85672c7d2de0b7da2bd1770d89665868741b3f9af7643397721d74d28134ab83',\r\n              '7c481b9b5b43b2eb6374049bfa62c2e5e77f17fcc5298f44c8e3094f790313a6'\r\n            ],\r\n            [\r\n              '948bf809b1988a46b06c9f1919413b10f9226c60f668832ffd959af60c82a0a',\r\n              '53a562856dcb6646dc6b74c5d1c3418c6d4dff08c97cd2bed4cb7f88d8c8e589'\r\n            ],\r\n            [\r\n              '6260ce7f461801c34f067ce0f02873a8f1b0e44dfc69752accecd819f38fd8e8',\r\n              'bc2da82b6fa5b571a7f09049776a1ef7ecd292238051c198c1a84e95b2b4ae17'\r\n            ],\r\n            [\r\n              'e5037de0afc1d8d43d8348414bbf4103043ec8f575bfdc432953cc8d2037fa2d',\r\n              '4571534baa94d3b5f9f98d09fb990bddbd5f5b03ec481f10e0e5dc841d755bda'\r\n            ],\r\n            [\r\n              'e06372b0f4a207adf5ea905e8f1771b4e7e8dbd1c6a6c5b725866a0ae4fce725',\r\n              '7a908974bce18cfe12a27bb2ad5a488cd7484a7787104870b27034f94eee31dd'\r\n            ],\r\n            [\r\n              '213c7a715cd5d45358d0bbf9dc0ce02204b10bdde2a3f58540ad6908d0559754',\r\n              '4b6dad0b5ae462507013ad06245ba190bb4850f5f36a7eeddff2c27534b458f2'\r\n            ],\r\n            [\r\n              '4e7c272a7af4b34e8dbb9352a5419a87e2838c70adc62cddf0cc3a3b08fbd53c',\r\n              '17749c766c9d0b18e16fd09f6def681b530b9614bff7dd33e0b3941817dcaae6'\r\n            ],\r\n            [\r\n              'fea74e3dbe778b1b10f238ad61686aa5c76e3db2be43057632427e2840fb27b6',\r\n              '6e0568db9b0b13297cf674deccb6af93126b596b973f7b77701d3db7f23cb96f'\r\n            ],\r\n            [\r\n              '76e64113f677cf0e10a2570d599968d31544e179b760432952c02a4417bdde39',\r\n              'c90ddf8dee4e95cf577066d70681f0d35e2a33d2b56d2032b4b1752d1901ac01'\r\n            ],\r\n            [\r\n              'c738c56b03b2abe1e8281baa743f8f9a8f7cc643df26cbee3ab150242bcbb891',\r\n              '893fb578951ad2537f718f2eacbfbbbb82314eef7880cfe917e735d9699a84c3'\r\n            ],\r\n            [\r\n              'd895626548b65b81e264c7637c972877d1d72e5f3a925014372e9f6588f6c14b',\r\n              'febfaa38f2bc7eae728ec60818c340eb03428d632bb067e179363ed75d7d991f'\r\n            ],\r\n            [\r\n              'b8da94032a957518eb0f6433571e8761ceffc73693e84edd49150a564f676e03',\r\n              '2804dfa44805a1e4d7c99cc9762808b092cc584d95ff3b511488e4e74efdf6e7'\r\n            ],\r\n            [\r\n              'e80fea14441fb33a7d8adab9475d7fab2019effb5156a792f1a11778e3c0df5d',\r\n              'eed1de7f638e00771e89768ca3ca94472d155e80af322ea9fcb4291b6ac9ec78'\r\n            ],\r\n            [\r\n              'a301697bdfcd704313ba48e51d567543f2a182031efd6915ddc07bbcc4e16070',\r\n              '7370f91cfb67e4f5081809fa25d40f9b1735dbf7c0a11a130c0d1a041e177ea1'\r\n            ],\r\n            [\r\n              '90ad85b389d6b936463f9d0512678de208cc330b11307fffab7ac63e3fb04ed4',\r\n              'e507a3620a38261affdcbd9427222b839aefabe1582894d991d4d48cb6ef150'\r\n            ],\r\n            [\r\n              '8f68b9d2f63b5f339239c1ad981f162ee88c5678723ea3351b7b444c9ec4c0da',\r\n              '662a9f2dba063986de1d90c2b6be215dbbea2cfe95510bfdf23cbf79501fff82'\r\n            ],\r\n            [\r\n              'e4f3fb0176af85d65ff99ff9198c36091f48e86503681e3e6686fd5053231e11',\r\n              '1e63633ad0ef4f1c1661a6d0ea02b7286cc7e74ec951d1c9822c38576feb73bc'\r\n            ],\r\n            [\r\n              '8c00fa9b18ebf331eb961537a45a4266c7034f2f0d4e1d0716fb6eae20eae29e',\r\n              'efa47267fea521a1a9dc343a3736c974c2fadafa81e36c54e7d2a4c66702414b'\r\n            ],\r\n            [\r\n              'e7a26ce69dd4829f3e10cec0a9e98ed3143d084f308b92c0997fddfc60cb3e41',\r\n              '2a758e300fa7984b471b006a1aafbb18d0a6b2c0420e83e20e8a9421cf2cfd51'\r\n            ],\r\n            [\r\n              'b6459e0ee3662ec8d23540c223bcbdc571cbcb967d79424f3cf29eb3de6b80ef',\r\n              '67c876d06f3e06de1dadf16e5661db3c4b3ae6d48e35b2ff30bf0b61a71ba45'\r\n            ],\r\n            [\r\n              'd68a80c8280bb840793234aa118f06231d6f1fc67e73c5a5deda0f5b496943e8',\r\n              'db8ba9fff4b586d00c4b1f9177b0e28b5b0e7b8f7845295a294c84266b133120'\r\n            ],\r\n            [\r\n              '324aed7df65c804252dc0270907a30b09612aeb973449cea4095980fc28d3d5d',\r\n              '648a365774b61f2ff130c0c35aec1f4f19213b0c7e332843967224af96ab7c84'\r\n            ],\r\n            [\r\n              '4df9c14919cde61f6d51dfdbe5fee5dceec4143ba8d1ca888e8bd373fd054c96',\r\n              '35ec51092d8728050974c23a1d85d4b5d506cdc288490192ebac06cad10d5d'\r\n            ],\r\n            [\r\n              '9c3919a84a474870faed8a9c1cc66021523489054d7f0308cbfc99c8ac1f98cd',\r\n              'ddb84f0f4a4ddd57584f044bf260e641905326f76c64c8e6be7e5e03d4fc599d'\r\n            ],\r\n            [\r\n              '6057170b1dd12fdf8de05f281d8e06bb91e1493a8b91d4cc5a21382120a959e5',\r\n              '9a1af0b26a6a4807add9a2daf71df262465152bc3ee24c65e899be932385a2a8'\r\n            ],\r\n            [\r\n              'a576df8e23a08411421439a4518da31880cef0fba7d4df12b1a6973eecb94266',\r\n              '40a6bf20e76640b2c92b97afe58cd82c432e10a7f514d9f3ee8be11ae1b28ec8'\r\n            ],\r\n            [\r\n              '7778a78c28dec3e30a05fe9629de8c38bb30d1f5cf9a3a208f763889be58ad71',\r\n              '34626d9ab5a5b22ff7098e12f2ff580087b38411ff24ac563b513fc1fd9f43ac'\r\n            ],\r\n            [\r\n              '928955ee637a84463729fd30e7afd2ed5f96274e5ad7e5cb09eda9c06d903ac',\r\n              'c25621003d3f42a827b78a13093a95eeac3d26efa8a8d83fc5180e935bcd091f'\r\n            ],\r\n            [\r\n              '85d0fef3ec6db109399064f3a0e3b2855645b4a907ad354527aae75163d82751',\r\n              '1f03648413a38c0be29d496e582cf5663e8751e96877331582c237a24eb1f962'\r\n            ],\r\n            [\r\n              'ff2b0dce97eece97c1c9b6041798b85dfdfb6d8882da20308f5404824526087e',\r\n              '493d13fef524ba188af4c4dc54d07936c7b7ed6fb90e2ceb2c951e01f0c29907'\r\n            ],\r\n            [\r\n              '827fbbe4b1e880ea9ed2b2e6301b212b57f1ee148cd6dd28780e5e2cf856e241',\r\n              'c60f9c923c727b0b71bef2c67d1d12687ff7a63186903166d605b68baec293ec'\r\n            ],\r\n            [\r\n              'eaa649f21f51bdbae7be4ae34ce6e5217a58fdce7f47f9aa7f3b58fa2120e2b3',\r\n              'be3279ed5bbbb03ac69a80f89879aa5a01a6b965f13f7e59d47a5305ba5ad93d'\r\n            ],\r\n            [\r\n              'e4a42d43c5cf169d9391df6decf42ee541b6d8f0c9a137401e23632dda34d24f',\r\n              '4d9f92e716d1c73526fc99ccfb8ad34ce886eedfa8d8e4f13a7f7131deba9414'\r\n            ],\r\n            [\r\n              '1ec80fef360cbdd954160fadab352b6b92b53576a88fea4947173b9d4300bf19',\r\n              'aeefe93756b5340d2f3a4958a7abbf5e0146e77f6295a07b671cdc1cc107cefd'\r\n            ],\r\n            [\r\n              '146a778c04670c2f91b00af4680dfa8bce3490717d58ba889ddb5928366642be',\r\n              'b318e0ec3354028add669827f9d4b2870aaa971d2f7e5ed1d0b297483d83efd0'\r\n            ],\r\n            [\r\n              'fa50c0f61d22e5f07e3acebb1aa07b128d0012209a28b9776d76a8793180eef9',\r\n              '6b84c6922397eba9b72cd2872281a68a5e683293a57a213b38cd8d7d3f4f2811'\r\n            ],\r\n            [\r\n              'da1d61d0ca721a11b1a5bf6b7d88e8421a288ab5d5bba5220e53d32b5f067ec2',\r\n              '8157f55a7c99306c79c0766161c91e2966a73899d279b48a655fba0f1ad836f1'\r\n            ],\r\n            [\r\n              'a8e282ff0c9706907215ff98e8fd416615311de0446f1e062a73b0610d064e13',\r\n              '7f97355b8db81c09abfb7f3c5b2515888b679a3e50dd6bd6cef7c73111f4cc0c'\r\n            ],\r\n            [\r\n              '174a53b9c9a285872d39e56e6913cab15d59b1fa512508c022f382de8319497c',\r\n              'ccc9dc37abfc9c1657b4155f2c47f9e6646b3a1d8cb9854383da13ac079afa73'\r\n            ],\r\n            [\r\n              '959396981943785c3d3e57edf5018cdbe039e730e4918b3d884fdff09475b7ba',\r\n              '2e7e552888c331dd8ba0386a4b9cd6849c653f64c8709385e9b8abf87524f2fd'\r\n            ],\r\n            [\r\n              'd2a63a50ae401e56d645a1153b109a8fcca0a43d561fba2dbb51340c9d82b151',\r\n              'e82d86fb6443fcb7565aee58b2948220a70f750af484ca52d4142174dcf89405'\r\n            ],\r\n            [\r\n              '64587e2335471eb890ee7896d7cfdc866bacbdbd3839317b3436f9b45617e073',\r\n              'd99fcdd5bf6902e2ae96dd6447c299a185b90a39133aeab358299e5e9faf6589'\r\n            ],\r\n            [\r\n              '8481bde0e4e4d885b3a546d3e549de042f0aa6cea250e7fd358d6c86dd45e458',\r\n              '38ee7b8cba5404dd84a25bf39cecb2ca900a79c42b262e556d64b1b59779057e'\r\n            ],\r\n            [\r\n              '13464a57a78102aa62b6979ae817f4637ffcfed3c4b1ce30bcd6303f6caf666b',\r\n              '69be159004614580ef7e433453ccb0ca48f300a81d0942e13f495a907f6ecc27'\r\n            ],\r\n            [\r\n              'bc4a9df5b713fe2e9aef430bcc1dc97a0cd9ccede2f28588cada3a0d2d83f366',\r\n              'd3a81ca6e785c06383937adf4b798caa6e8a9fbfa547b16d758d666581f33c1'\r\n            ],\r\n            [\r\n              '8c28a97bf8298bc0d23d8c749452a32e694b65e30a9472a3954ab30fe5324caa',\r\n              '40a30463a3305193378fedf31f7cc0eb7ae784f0451cb9459e71dc73cbef9482'\r\n            ],\r\n            [\r\n              '8ea9666139527a8c1dd94ce4f071fd23c8b350c5a4bb33748c4ba111faccae0',\r\n              '620efabbc8ee2782e24e7c0cfb95c5d735b783be9cf0f8e955af34a30e62b945'\r\n            ],\r\n            [\r\n              'dd3625faef5ba06074669716bbd3788d89bdde815959968092f76cc4eb9a9787',\r\n              '7a188fa3520e30d461da2501045731ca941461982883395937f68d00c644a573'\r\n            ],\r\n            [\r\n              'f710d79d9eb962297e4f6232b40e8f7feb2bc63814614d692c12de752408221e',\r\n              'ea98e67232d3b3295d3b535532115ccac8612c721851617526ae47a9c77bfc82'\r\n            ]\r\n          ]\r\n        },\r\n        naf: {\r\n          wnd: 7,\r\n          points: [\r\n            [\r\n              'f9308a019258c31049344f85f89d5229b531c845836f99b08601f113bce036f9',\r\n              '388f7b0f632de8140fe337e62a37f3566500a99934c2231b6cb9fd7584b8e672'\r\n            ],\r\n            [\r\n              '2f8bde4d1a07209355b4a7250a5c5128e88b84bddc619ab7cba8d569b240efe4',\r\n              'd8ac222636e5e3d6d4dba9dda6c9c426f788271bab0d6840dca87d3aa6ac62d6'\r\n            ],\r\n            [\r\n              '5cbdf0646e5db4eaa398f365f2ea7a0e3d419b7e0330e39ce92bddedcac4f9bc',\r\n              '6aebca40ba255960a3178d6d861a54dba813d0b813fde7b5a5082628087264da'\r\n            ],\r\n            [\r\n              'acd484e2f0c7f65309ad178a9f559abde09796974c57e714c35f110dfc27ccbe',\r\n              'cc338921b0a7d9fd64380971763b61e9add888a4375f8e0f05cc262ac64f9c37'\r\n            ],\r\n            [\r\n              '774ae7f858a9411e5ef4246b70c65aac5649980be5c17891bbec17895da008cb',\r\n              'd984a032eb6b5e190243dd56d7b7b365372db1e2dff9d6a8301d74c9c953c61b'\r\n            ],\r\n            [\r\n              'f28773c2d975288bc7d1d205c3748651b075fbc6610e58cddeeddf8f19405aa8',\r\n              'ab0902e8d880a89758212eb65cdaf473a1a06da521fa91f29b5cb52db03ed81'\r\n            ],\r\n            [\r\n              'd7924d4f7d43ea965a465ae3095ff41131e5946f3c85f79e44adbcf8e27e080e',\r\n              '581e2872a86c72a683842ec228cc6defea40af2bd896d3a5c504dc9ff6a26b58'\r\n            ],\r\n            [\r\n              'defdea4cdb677750a420fee807eacf21eb9898ae79b9768766e4faa04a2d4a34',\r\n              '4211ab0694635168e997b0ead2a93daeced1f4a04a95c0f6cfb199f69e56eb77'\r\n            ],\r\n            [\r\n              '2b4ea0a797a443d293ef5cff444f4979f06acfebd7e86d277475656138385b6c',\r\n              '85e89bc037945d93b343083b5a1c86131a01f60c50269763b570c854e5c09b7a'\r\n            ],\r\n            [\r\n              '352bbf4a4cdd12564f93fa332ce333301d9ad40271f8107181340aef25be59d5',\r\n              '321eb4075348f534d59c18259dda3e1f4a1b3b2e71b1039c67bd3d8bcf81998c'\r\n            ],\r\n            [\r\n              '2fa2104d6b38d11b0230010559879124e42ab8dfeff5ff29dc9cdadd4ecacc3f',\r\n              '2de1068295dd865b64569335bd5dd80181d70ecfc882648423ba76b532b7d67'\r\n            ],\r\n            [\r\n              '9248279b09b4d68dab21a9b066edda83263c3d84e09572e269ca0cd7f5453714',\r\n              '73016f7bf234aade5d1aa71bdea2b1ff3fc0de2a887912ffe54a32ce97cb3402'\r\n            ],\r\n            [\r\n              'daed4f2be3a8bf278e70132fb0beb7522f570e144bf615c07e996d443dee8729',\r\n              'a69dce4a7d6c98e8d4a1aca87ef8d7003f83c230f3afa726ab40e52290be1c55'\r\n            ],\r\n            [\r\n              'c44d12c7065d812e8acf28d7cbb19f9011ecd9e9fdf281b0e6a3b5e87d22e7db',\r\n              '2119a460ce326cdc76c45926c982fdac0e106e861edf61c5a039063f0e0e6482'\r\n            ],\r\n            [\r\n              '6a245bf6dc698504c89a20cfded60853152b695336c28063b61c65cbd269e6b4',\r\n              'e022cf42c2bd4a708b3f5126f16a24ad8b33ba48d0423b6efd5e6348100d8a82'\r\n            ],\r\n            [\r\n              '1697ffa6fd9de627c077e3d2fe541084ce13300b0bec1146f95ae57f0d0bd6a5',\r\n              'b9c398f186806f5d27561506e4557433a2cf15009e498ae7adee9d63d01b2396'\r\n            ],\r\n            [\r\n              '605bdb019981718b986d0f07e834cb0d9deb8360ffb7f61df982345ef27a7479',\r\n              '2972d2de4f8d20681a78d93ec96fe23c26bfae84fb14db43b01e1e9056b8c49'\r\n            ],\r\n            [\r\n              '62d14dab4150bf497402fdc45a215e10dcb01c354959b10cfe31c7e9d87ff33d',\r\n              '80fc06bd8cc5b01098088a1950eed0db01aa132967ab472235f5642483b25eaf'\r\n            ],\r\n            [\r\n              '80c60ad0040f27dade5b4b06c408e56b2c50e9f56b9b8b425e555c2f86308b6f',\r\n              '1c38303f1cc5c30f26e66bad7fe72f70a65eed4cbe7024eb1aa01f56430bd57a'\r\n            ],\r\n            [\r\n              '7a9375ad6167ad54aa74c6348cc54d344cc5dc9487d847049d5eabb0fa03c8fb',\r\n              'd0e3fa9eca8726909559e0d79269046bdc59ea10c70ce2b02d499ec224dc7f7'\r\n            ],\r\n            [\r\n              'd528ecd9b696b54c907a9ed045447a79bb408ec39b68df504bb51f459bc3ffc9',\r\n              'eecf41253136e5f99966f21881fd656ebc4345405c520dbc063465b521409933'\r\n            ],\r\n            [\r\n              '49370a4b5f43412ea25f514e8ecdad05266115e4a7ecb1387231808f8b45963',\r\n              '758f3f41afd6ed428b3081b0512fd62a54c3f3afbb5b6764b653052a12949c9a'\r\n            ],\r\n            [\r\n              '77f230936ee88cbbd73df930d64702ef881d811e0e1498e2f1c13eb1fc345d74',\r\n              '958ef42a7886b6400a08266e9ba1b37896c95330d97077cbbe8eb3c7671c60d6'\r\n            ],\r\n            [\r\n              'f2dac991cc4ce4b9ea44887e5c7c0bce58c80074ab9d4dbaeb28531b7739f530',\r\n              'e0dedc9b3b2f8dad4da1f32dec2531df9eb5fbeb0598e4fd1a117dba703a3c37'\r\n            ],\r\n            [\r\n              '463b3d9f662621fb1b4be8fbbe2520125a216cdfc9dae3debcba4850c690d45b',\r\n              '5ed430d78c296c3543114306dd8622d7c622e27c970a1de31cb377b01af7307e'\r\n            ],\r\n            [\r\n              'f16f804244e46e2a09232d4aff3b59976b98fac14328a2d1a32496b49998f247',\r\n              'cedabd9b82203f7e13d206fcdf4e33d92a6c53c26e5cce26d6579962c4e31df6'\r\n            ],\r\n            [\r\n              'caf754272dc84563b0352b7a14311af55d245315ace27c65369e15f7151d41d1',\r\n              'cb474660ef35f5f2a41b643fa5e460575f4fa9b7962232a5c32f908318a04476'\r\n            ],\r\n            [\r\n              '2600ca4b282cb986f85d0f1709979d8b44a09c07cb86d7c124497bc86f082120',\r\n              '4119b88753c15bd6a693b03fcddbb45d5ac6be74ab5f0ef44b0be9475a7e4b40'\r\n            ],\r\n            [\r\n              '7635ca72d7e8432c338ec53cd12220bc01c48685e24f7dc8c602a7746998e435',\r\n              '91b649609489d613d1d5e590f78e6d74ecfc061d57048bad9e76f302c5b9c61'\r\n            ],\r\n            [\r\n              '754e3239f325570cdbbf4a87deee8a66b7f2b33479d468fbc1a50743bf56cc18',\r\n              '673fb86e5bda30fb3cd0ed304ea49a023ee33d0197a695d0c5d98093c536683'\r\n            ],\r\n            [\r\n              'e3e6bd1071a1e96aff57859c82d570f0330800661d1c952f9fe2694691d9b9e8',\r\n              '59c9e0bba394e76f40c0aa58379a3cb6a5a2283993e90c4167002af4920e37f5'\r\n            ],\r\n            [\r\n              '186b483d056a033826ae73d88f732985c4ccb1f32ba35f4b4cc47fdcf04aa6eb',\r\n              '3b952d32c67cf77e2e17446e204180ab21fb8090895138b4a4a797f86e80888b'\r\n            ],\r\n            [\r\n              'df9d70a6b9876ce544c98561f4be4f725442e6d2b737d9c91a8321724ce0963f',\r\n              '55eb2dafd84d6ccd5f862b785dc39d4ab157222720ef9da217b8c45cf2ba2417'\r\n            ],\r\n            [\r\n              '5edd5cc23c51e87a497ca815d5dce0f8ab52554f849ed8995de64c5f34ce7143',\r\n              'efae9c8dbc14130661e8cec030c89ad0c13c66c0d17a2905cdc706ab7399a868'\r\n            ],\r\n            [\r\n              '290798c2b6476830da12fe02287e9e777aa3fba1c355b17a722d362f84614fba',\r\n              'e38da76dcd440621988d00bcf79af25d5b29c094db2a23146d003afd41943e7a'\r\n            ],\r\n            [\r\n              'af3c423a95d9f5b3054754efa150ac39cd29552fe360257362dfdecef4053b45',\r\n              'f98a3fd831eb2b749a93b0e6f35cfb40c8cd5aa667a15581bc2feded498fd9c6'\r\n            ],\r\n            [\r\n              '766dbb24d134e745cccaa28c99bf274906bb66b26dcf98df8d2fed50d884249a',\r\n              '744b1152eacbe5e38dcc887980da38b897584a65fa06cedd2c924f97cbac5996'\r\n            ],\r\n            [\r\n              '59dbf46f8c94759ba21277c33784f41645f7b44f6c596a58ce92e666191abe3e',\r\n              'c534ad44175fbc300f4ea6ce648309a042ce739a7919798cd85e216c4a307f6e'\r\n            ],\r\n            [\r\n              'f13ada95103c4537305e691e74e9a4a8dd647e711a95e73cb62dc6018cfd87b8',\r\n              'e13817b44ee14de663bf4bc808341f326949e21a6a75c2570778419bdaf5733d'\r\n            ],\r\n            [\r\n              '7754b4fa0e8aced06d4167a2c59cca4cda1869c06ebadfb6488550015a88522c',\r\n              '30e93e864e669d82224b967c3020b8fa8d1e4e350b6cbcc537a48b57841163a2'\r\n            ],\r\n            [\r\n              '948dcadf5990e048aa3874d46abef9d701858f95de8041d2a6828c99e2262519',\r\n              'e491a42537f6e597d5d28a3224b1bc25df9154efbd2ef1d2cbba2cae5347d57e'\r\n            ],\r\n            [\r\n              '7962414450c76c1689c7b48f8202ec37fb224cf5ac0bfa1570328a8a3d7c77ab',\r\n              '100b610ec4ffb4760d5c1fc133ef6f6b12507a051f04ac5760afa5b29db83437'\r\n            ],\r\n            [\r\n              '3514087834964b54b15b160644d915485a16977225b8847bb0dd085137ec47ca',\r\n              'ef0afbb2056205448e1652c48e8127fc6039e77c15c2378b7e7d15a0de293311'\r\n            ],\r\n            [\r\n              'd3cc30ad6b483e4bc79ce2c9dd8bc54993e947eb8df787b442943d3f7b527eaf',\r\n              '8b378a22d827278d89c5e9be8f9508ae3c2ad46290358630afb34db04eede0a4'\r\n            ],\r\n            [\r\n              '1624d84780732860ce1c78fcbfefe08b2b29823db913f6493975ba0ff4847610',\r\n              '68651cf9b6da903e0914448c6cd9d4ca896878f5282be4c8cc06e2a404078575'\r\n            ],\r\n            [\r\n              '733ce80da955a8a26902c95633e62a985192474b5af207da6df7b4fd5fc61cd4',\r\n              'f5435a2bd2badf7d485a4d8b8db9fcce3e1ef8e0201e4578c54673bc1dc5ea1d'\r\n            ],\r\n            [\r\n              '15d9441254945064cf1a1c33bbd3b49f8966c5092171e699ef258dfab81c045c',\r\n              'd56eb30b69463e7234f5137b73b84177434800bacebfc685fc37bbe9efe4070d'\r\n            ],\r\n            [\r\n              'a1d0fcf2ec9de675b612136e5ce70d271c21417c9d2b8aaaac138599d0717940',\r\n              'edd77f50bcb5a3cab2e90737309667f2641462a54070f3d519212d39c197a629'\r\n            ],\r\n            [\r\n              'e22fbe15c0af8ccc5780c0735f84dbe9a790badee8245c06c7ca37331cb36980',\r\n              'a855babad5cd60c88b430a69f53a1a7a38289154964799be43d06d77d31da06'\r\n            ],\r\n            [\r\n              '311091dd9860e8e20ee13473c1155f5f69635e394704eaa74009452246cfa9b3',\r\n              '66db656f87d1f04fffd1f04788c06830871ec5a64feee685bd80f0b1286d8374'\r\n            ],\r\n            [\r\n              '34c1fd04d301be89b31c0442d3e6ac24883928b45a9340781867d4232ec2dbdf',\r\n              '9414685e97b1b5954bd46f730174136d57f1ceeb487443dc5321857ba73abee'\r\n            ],\r\n            [\r\n              'f219ea5d6b54701c1c14de5b557eb42a8d13f3abbcd08affcc2a5e6b049b8d63',\r\n              '4cb95957e83d40b0f73af4544cccf6b1f4b08d3c07b27fb8d8c2962a400766d1'\r\n            ],\r\n            [\r\n              'd7b8740f74a8fbaab1f683db8f45de26543a5490bca627087236912469a0b448',\r\n              'fa77968128d9c92ee1010f337ad4717eff15db5ed3c049b3411e0315eaa4593b'\r\n            ],\r\n            [\r\n              '32d31c222f8f6f0ef86f7c98d3a3335ead5bcd32abdd94289fe4d3091aa824bf',\r\n              '5f3032f5892156e39ccd3d7915b9e1da2e6dac9e6f26e961118d14b8462e1661'\r\n            ],\r\n            [\r\n              '7461f371914ab32671045a155d9831ea8793d77cd59592c4340f86cbc18347b5',\r\n              '8ec0ba238b96bec0cbdddcae0aa442542eee1ff50c986ea6b39847b3cc092ff6'\r\n            ],\r\n            [\r\n              'ee079adb1df1860074356a25aa38206a6d716b2c3e67453d287698bad7b2b2d6',\r\n              '8dc2412aafe3be5c4c5f37e0ecc5f9f6a446989af04c4e25ebaac479ec1c8c1e'\r\n            ],\r\n            [\r\n              '16ec93e447ec83f0467b18302ee620f7e65de331874c9dc72bfd8616ba9da6b5',\r\n              '5e4631150e62fb40d0e8c2a7ca5804a39d58186a50e497139626778e25b0674d'\r\n            ],\r\n            [\r\n              'eaa5f980c245f6f038978290afa70b6bd8855897f98b6aa485b96065d537bd99',\r\n              'f65f5d3e292c2e0819a528391c994624d784869d7e6ea67fb18041024edc07dc'\r\n            ],\r\n            [\r\n              '78c9407544ac132692ee1910a02439958ae04877151342ea96c4b6b35a49f51',\r\n              'f3e0319169eb9b85d5404795539a5e68fa1fbd583c064d2462b675f194a3ddb4'\r\n            ],\r\n            [\r\n              '494f4be219a1a77016dcd838431aea0001cdc8ae7a6fc688726578d9702857a5',\r\n              '42242a969283a5f339ba7f075e36ba2af925ce30d767ed6e55f4b031880d562c'\r\n            ],\r\n            [\r\n              'a598a8030da6d86c6bc7f2f5144ea549d28211ea58faa70ebf4c1e665c1fe9b5',\r\n              '204b5d6f84822c307e4b4a7140737aec23fc63b65b35f86a10026dbd2d864e6b'\r\n            ],\r\n            [\r\n              'c41916365abb2b5d09192f5f2dbeafec208f020f12570a184dbadc3e58595997',\r\n              '4f14351d0087efa49d245b328984989d5caf9450f34bfc0ed16e96b58fa9913'\r\n            ],\r\n            [\r\n              '841d6063a586fa475a724604da03bc5b92a2e0d2e0a36acfe4c73a5514742881',\r\n              '73867f59c0659e81904f9a1c7543698e62562d6744c169ce7a36de01a8d6154'\r\n            ],\r\n            [\r\n              '5e95bb399a6971d376026947f89bde2f282b33810928be4ded112ac4d70e20d5',\r\n              '39f23f366809085beebfc71181313775a99c9aed7d8ba38b161384c746012865'\r\n            ],\r\n            [\r\n              '36e4641a53948fd476c39f8a99fd974e5ec07564b5315d8bf99471bca0ef2f66',\r\n              'd2424b1b1abe4eb8164227b085c9aa9456ea13493fd563e06fd51cf5694c78fc'\r\n            ],\r\n            [\r\n              '336581ea7bfbbb290c191a2f507a41cf5643842170e914faeab27c2c579f726',\r\n              'ead12168595fe1be99252129b6e56b3391f7ab1410cd1e0ef3dcdcabd2fda224'\r\n            ],\r\n            [\r\n              '8ab89816dadfd6b6a1f2634fcf00ec8403781025ed6890c4849742706bd43ede',\r\n              '6fdcef09f2f6d0a044e654aef624136f503d459c3e89845858a47a9129cdd24e'\r\n            ],\r\n            [\r\n              '1e33f1a746c9c5778133344d9299fcaa20b0938e8acff2544bb40284b8c5fb94',\r\n              '60660257dd11b3aa9c8ed618d24edff2306d320f1d03010e33a7d2057f3b3b6'\r\n            ],\r\n            [\r\n              '85b7c1dcb3cec1b7ee7f30ded79dd20a0ed1f4cc18cbcfcfa410361fd8f08f31',\r\n              '3d98a9cdd026dd43f39048f25a8847f4fcafad1895d7a633c6fed3c35e999511'\r\n            ],\r\n            [\r\n              '29df9fbd8d9e46509275f4b125d6d45d7fbe9a3b878a7af872a2800661ac5f51',\r\n              'b4c4fe99c775a606e2d8862179139ffda61dc861c019e55cd2876eb2a27d84b'\r\n            ],\r\n            [\r\n              'a0b1cae06b0a847a3fea6e671aaf8adfdfe58ca2f768105c8082b2e449fce252',\r\n              'ae434102edde0958ec4b19d917a6a28e6b72da1834aff0e650f049503a296cf2'\r\n            ],\r\n            [\r\n              '4e8ceafb9b3e9a136dc7ff67e840295b499dfb3b2133e4ba113f2e4c0e121e5',\r\n              'cf2174118c8b6d7a4b48f6d534ce5c79422c086a63460502b827ce62a326683c'\r\n            ],\r\n            [\r\n              'd24a44e047e19b6f5afb81c7ca2f69080a5076689a010919f42725c2b789a33b',\r\n              '6fb8d5591b466f8fc63db50f1c0f1c69013f996887b8244d2cdec417afea8fa3'\r\n            ],\r\n            [\r\n              'ea01606a7a6c9cdd249fdfcfacb99584001edd28abbab77b5104e98e8e3b35d4',\r\n              '322af4908c7312b0cfbfe369f7a7b3cdb7d4494bc2823700cfd652188a3ea98d'\r\n            ],\r\n            [\r\n              'af8addbf2b661c8a6c6328655eb96651252007d8c5ea31be4ad196de8ce2131f',\r\n              '6749e67c029b85f52a034eafd096836b2520818680e26ac8f3dfbcdb71749700'\r\n            ],\r\n            [\r\n              'e3ae1974566ca06cc516d47e0fb165a674a3dabcfca15e722f0e3450f45889',\r\n              '2aeabe7e4531510116217f07bf4d07300de97e4874f81f533420a72eeb0bd6a4'\r\n            ],\r\n            [\r\n              '591ee355313d99721cf6993ffed1e3e301993ff3ed258802075ea8ced397e246',\r\n              'b0ea558a113c30bea60fc4775460c7901ff0b053d25ca2bdeee98f1a4be5d196'\r\n            ],\r\n            [\r\n              '11396d55fda54c49f19aa97318d8da61fa8584e47b084945077cf03255b52984',\r\n              '998c74a8cd45ac01289d5833a7beb4744ff536b01b257be4c5767bea93ea57a4'\r\n            ],\r\n            [\r\n              '3c5d2a1ba39c5a1790000738c9e0c40b8dcdfd5468754b6405540157e017aa7a',\r\n              'b2284279995a34e2f9d4de7396fc18b80f9b8b9fdd270f6661f79ca4c81bd257'\r\n            ],\r\n            [\r\n              'cc8704b8a60a0defa3a99a7299f2e9c3fbc395afb04ac078425ef8a1793cc030',\r\n              'bdd46039feed17881d1e0862db347f8cf395b74fc4bcdc4e940b74e3ac1f1b13'\r\n            ],\r\n            [\r\n              'c533e4f7ea8555aacd9777ac5cad29b97dd4defccc53ee7ea204119b2889b197',\r\n              '6f0a256bc5efdf429a2fb6242f1a43a2d9b925bb4a4b3a26bb8e0f45eb596096'\r\n            ],\r\n            [\r\n              'c14f8f2ccb27d6f109f6d08d03cc96a69ba8c34eec07bbcf566d48e33da6593',\r\n              'c359d6923bb398f7fd4473e16fe1c28475b740dd098075e6c0e8649113dc3a38'\r\n            ],\r\n            [\r\n              'a6cbc3046bc6a450bac24789fa17115a4c9739ed75f8f21ce441f72e0b90e6ef',\r\n              '21ae7f4680e889bb130619e2c0f95a360ceb573c70603139862afd617fa9b9f'\r\n            ],\r\n            [\r\n              '347d6d9a02c48927ebfb86c1359b1caf130a3c0267d11ce6344b39f99d43cc38',\r\n              '60ea7f61a353524d1c987f6ecec92f086d565ab687870cb12689ff1e31c74448'\r\n            ],\r\n            [\r\n              'da6545d2181db8d983f7dcb375ef5866d47c67b1bf31c8cf855ef7437b72656a',\r\n              '49b96715ab6878a79e78f07ce5680c5d6673051b4935bd897fea824b77dc208a'\r\n            ],\r\n            [\r\n              'c40747cc9d012cb1a13b8148309c6de7ec25d6945d657146b9d5994b8feb1111',\r\n              '5ca560753be2a12fc6de6caf2cb489565db936156b9514e1bb5e83037e0fa2d4'\r\n            ],\r\n            [\r\n              '4e42c8ec82c99798ccf3a610be870e78338c7f713348bd34c8203ef4037f3502',\r\n              '7571d74ee5e0fb92a7a8b33a07783341a5492144cc54bcc40a94473693606437'\r\n            ],\r\n            [\r\n              '3775ab7089bc6af823aba2e1af70b236d251cadb0c86743287522a1b3b0dedea',\r\n              'be52d107bcfa09d8bcb9736a828cfa7fac8db17bf7a76a2c42ad961409018cf7'\r\n            ],\r\n            [\r\n              'cee31cbf7e34ec379d94fb814d3d775ad954595d1314ba8846959e3e82f74e26',\r\n              '8fd64a14c06b589c26b947ae2bcf6bfa0149ef0be14ed4d80f448a01c43b1c6d'\r\n            ],\r\n            [\r\n              'b4f9eaea09b6917619f6ea6a4eb5464efddb58fd45b1ebefcdc1a01d08b47986',\r\n              '39e5c9925b5a54b07433a4f18c61726f8bb131c012ca542eb24a8ac07200682a'\r\n            ],\r\n            [\r\n              'd4263dfc3d2df923a0179a48966d30ce84e2515afc3dccc1b77907792ebcc60e',\r\n              '62dfaf07a0f78feb30e30d6295853ce189e127760ad6cf7fae164e122a208d54'\r\n            ],\r\n            [\r\n              '48457524820fa65a4f8d35eb6930857c0032acc0a4a2de422233eeda897612c4',\r\n              '25a748ab367979d98733c38a1fa1c2e7dc6cc07db2d60a9ae7a76aaa49bd0f77'\r\n            ],\r\n            [\r\n              'dfeeef1881101f2cb11644f3a2afdfc2045e19919152923f367a1767c11cceda',\r\n              'ecfb7056cf1de042f9420bab396793c0c390bde74b4bbdff16a83ae09a9a7517'\r\n            ],\r\n            [\r\n              '6d7ef6b17543f8373c573f44e1f389835d89bcbc6062ced36c82df83b8fae859',\r\n              'cd450ec335438986dfefa10c57fea9bcc521a0959b2d80bbf74b190dca712d10'\r\n            ],\r\n            [\r\n              'e75605d59102a5a2684500d3b991f2e3f3c88b93225547035af25af66e04541f',\r\n              'f5c54754a8f71ee540b9b48728473e314f729ac5308b06938360990e2bfad125'\r\n            ],\r\n            [\r\n              'eb98660f4c4dfaa06a2be453d5020bc99a0c2e60abe388457dd43fefb1ed620c',\r\n              '6cb9a8876d9cb8520609af3add26cd20a0a7cd8a9411131ce85f44100099223e'\r\n            ],\r\n            [\r\n              '13e87b027d8514d35939f2e6892b19922154596941888336dc3563e3b8dba942',\r\n              'fef5a3c68059a6dec5d624114bf1e91aac2b9da568d6abeb2570d55646b8adf1'\r\n            ],\r\n            [\r\n              'ee163026e9fd6fe017c38f06a5be6fc125424b371ce2708e7bf4491691e5764a',\r\n              '1acb250f255dd61c43d94ccc670d0f58f49ae3fa15b96623e5430da0ad6c62b2'\r\n            ],\r\n            [\r\n              'b268f5ef9ad51e4d78de3a750c2dc89b1e626d43505867999932e5db33af3d80',\r\n              '5f310d4b3c99b9ebb19f77d41c1dee018cf0d34fd4191614003e945a1216e423'\r\n            ],\r\n            [\r\n              'ff07f3118a9df035e9fad85eb6c7bfe42b02f01ca99ceea3bf7ffdba93c4750d',\r\n              '438136d603e858a3a5c440c38eccbaddc1d2942114e2eddd4740d098ced1f0d8'\r\n            ],\r\n            [\r\n              '8d8b9855c7c052a34146fd20ffb658bea4b9f69e0d825ebec16e8c3ce2b526a1',\r\n              'cdb559eedc2d79f926baf44fb84ea4d44bcf50fee51d7ceb30e2e7f463036758'\r\n            ],\r\n            [\r\n              '52db0b5384dfbf05bfa9d472d7ae26dfe4b851ceca91b1eba54263180da32b63',\r\n              'c3b997d050ee5d423ebaf66a6db9f57b3180c902875679de924b69d84a7b375'\r\n            ],\r\n            [\r\n              'e62f9490d3d51da6395efd24e80919cc7d0f29c3f3fa48c6fff543becbd43352',\r\n              '6d89ad7ba4876b0b22c2ca280c682862f342c8591f1daf5170e07bfd9ccafa7d'\r\n            ],\r\n            [\r\n              '7f30ea2476b399b4957509c88f77d0191afa2ff5cb7b14fd6d8e7d65aaab1193',\r\n              'ca5ef7d4b231c94c3b15389a5f6311e9daff7bb67b103e9880ef4bff637acaec'\r\n            ],\r\n            [\r\n              '5098ff1e1d9f14fb46a210fada6c903fef0fb7b4a1dd1d9ac60a0361800b7a00',\r\n              '9731141d81fc8f8084d37c6e7542006b3ee1b40d60dfe5362a5b132fd17ddc0'\r\n            ],\r\n            [\r\n              '32b78c7de9ee512a72895be6b9cbefa6e2f3c4ccce445c96b9f2c81e2778ad58',\r\n              'ee1849f513df71e32efc3896ee28260c73bb80547ae2275ba497237794c8753c'\r\n            ],\r\n            [\r\n              'e2cb74fddc8e9fbcd076eef2a7c72b0ce37d50f08269dfc074b581550547a4f7',\r\n              'd3aa2ed71c9dd2247a62df062736eb0baddea9e36122d2be8641abcb005cc4a4'\r\n            ],\r\n            [\r\n              '8438447566d4d7bedadc299496ab357426009a35f235cb141be0d99cd10ae3a8',\r\n              'c4e1020916980a4da5d01ac5e6ad330734ef0d7906631c4f2390426b2edd791f'\r\n            ],\r\n            [\r\n              '4162d488b89402039b584c6fc6c308870587d9c46f660b878ab65c82c711d67e',\r\n              '67163e903236289f776f22c25fb8a3afc1732f2b84b4e95dbda47ae5a0852649'\r\n            ],\r\n            [\r\n              '3fad3fa84caf0f34f0f89bfd2dcf54fc175d767aec3e50684f3ba4a4bf5f683d',\r\n              'cd1bc7cb6cc407bb2f0ca647c718a730cf71872e7d0d2a53fa20efcdfe61826'\r\n            ],\r\n            [\r\n              '674f2600a3007a00568c1a7ce05d0816c1fb84bf1370798f1c69532faeb1a86b',\r\n              '299d21f9413f33b3edf43b257004580b70db57da0b182259e09eecc69e0d38a5'\r\n            ],\r\n            [\r\n              'd32f4da54ade74abb81b815ad1fb3b263d82d6c692714bcff87d29bd5ee9f08f',\r\n              'f9429e738b8e53b968e99016c059707782e14f4535359d582fc416910b3eea87'\r\n            ],\r\n            [\r\n              '30e4e670435385556e593657135845d36fbb6931f72b08cb1ed954f1e3ce3ff6',\r\n              '462f9bce619898638499350113bbc9b10a878d35da70740dc695a559eb88db7b'\r\n            ],\r\n            [\r\n              'be2062003c51cc3004682904330e4dee7f3dcd10b01e580bf1971b04d4cad297',\r\n              '62188bc49d61e5428573d48a74e1c655b1c61090905682a0d5558ed72dccb9bc'\r\n            ],\r\n            [\r\n              '93144423ace3451ed29e0fb9ac2af211cb6e84a601df5993c419859fff5df04a',\r\n              '7c10dfb164c3425f5c71a3f9d7992038f1065224f72bb9d1d902a6d13037b47c'\r\n            ],\r\n            [\r\n              'b015f8044f5fcbdcf21ca26d6c34fb8197829205c7b7d2a7cb66418c157b112c',\r\n              'ab8c1e086d04e813744a655b2df8d5f83b3cdc6faa3088c1d3aea1454e3a1d5f'\r\n            ],\r\n            [\r\n              'd5e9e1da649d97d89e4868117a465a3a4f8a18de57a140d36b3f2af341a21b52',\r\n              '4cb04437f391ed73111a13cc1d4dd0db1693465c2240480d8955e8592f27447a'\r\n            ],\r\n            [\r\n              'd3ae41047dd7ca065dbf8ed77b992439983005cd72e16d6f996a5316d36966bb',\r\n              'bd1aeb21ad22ebb22a10f0303417c6d964f8cdd7df0aca614b10dc14d125ac46'\r\n            ],\r\n            [\r\n              '463e2763d885f958fc66cdd22800f0a487197d0a82e377b49f80af87c897b065',\r\n              'bfefacdb0e5d0fd7df3a311a94de062b26b80c61fbc97508b79992671ef7ca7f'\r\n            ],\r\n            [\r\n              '7985fdfd127c0567c6f53ec1bb63ec3158e597c40bfe747c83cddfc910641917',\r\n              '603c12daf3d9862ef2b25fe1de289aed24ed291e0ec6708703a5bd567f32ed03'\r\n            ],\r\n            [\r\n              '74a1ad6b5f76e39db2dd249410eac7f99e74c59cb83d2d0ed5ff1543da7703e9',\r\n              'cc6157ef18c9c63cd6193d83631bbea0093e0968942e8c33d5737fd790e0db08'\r\n            ],\r\n            [\r\n              '30682a50703375f602d416664ba19b7fc9bab42c72747463a71d0896b22f6da3',\r\n              '553e04f6b018b4fa6c8f39e7f311d3176290d0e0f19ca73f17714d9977a22ff8'\r\n            ],\r\n            [\r\n              '9e2158f0d7c0d5f26c3791efefa79597654e7a2b2464f52b1ee6c1347769ef57',\r\n              '712fcdd1b9053f09003a3481fa7762e9ffd7c8ef35a38509e2fbf2629008373'\r\n            ],\r\n            [\r\n              '176e26989a43c9cfeba4029c202538c28172e566e3c4fce7322857f3be327d66',\r\n              'ed8cc9d04b29eb877d270b4878dc43c19aefd31f4eee09ee7b47834c1fa4b1c3'\r\n            ],\r\n            [\r\n              '75d46efea3771e6e68abb89a13ad747ecf1892393dfc4f1b7004788c50374da8',\r\n              '9852390a99507679fd0b86fd2b39a868d7efc22151346e1a3ca4726586a6bed8'\r\n            ],\r\n            [\r\n              '809a20c67d64900ffb698c4c825f6d5f2310fb0451c869345b7319f645605721',\r\n              '9e994980d9917e22b76b061927fa04143d096ccc54963e6a5ebfa5f3f8e286c1'\r\n            ],\r\n            [\r\n              '1b38903a43f7f114ed4500b4eac7083fdefece1cf29c63528d563446f972c180',\r\n              '4036edc931a60ae889353f77fd53de4a2708b26b6f5da72ad3394119daf408f9'\r\n            ]\r\n          ]\r\n        }\r\n      };\r\n\r\n    }, {}],\r\n    87: [function (require, module, exports) {\r\n      'use strict';\r\n\r\n      var utils = exports;\r\n      var BN = require('bn.js');\r\n      var minAssert = require('minimalistic-assert');\r\n      var minUtils = require('minimalistic-crypto-utils');\r\n\r\n      utils.assert = minAssert;\r\n      utils.toArray = minUtils.toArray;\r\n      utils.zero2 = minUtils.zero2;\r\n      utils.toHex = minUtils.toHex;\r\n      utils.encode = minUtils.encode;\r\n\r\n      // Represent num in a w-NAF form\r\n      function getNAF(num, w) {\r\n        var naf = [];\r\n        var ws = 1 << (w + 1);\r\n        var k = num.clone();\r\n        while (k.cmpn(1) >= 0) {\r\n          var z;\r\n          if (k.isOdd()) {\r\n            var mod = k.andln(ws - 1);\r\n            if (mod > (ws >> 1) - 1)\r\n              z = (ws >> 1) - mod;\r\n            else\r\n              z = mod;\r\n            k.isubn(z);\r\n          } else {\r\n            z = 0;\r\n          }\r\n          naf.push(z);\r\n\r\n          // Optimization, shift by word if possible\r\n          var shift = (k.cmpn(0) !== 0 && k.andln(ws - 1) === 0) ? (w + 1) : 1;\r\n          for (var i = 1; i < shift; i++)\r\n            naf.push(0);\r\n          k.iushrn(shift);\r\n        }\r\n\r\n        return naf;\r\n      }\r\n      utils.getNAF = getNAF;\r\n\r\n      // Represent k1, k2 in a Joint Sparse Form\r\n      function getJSF(k1, k2) {\r\n        var jsf = [\r\n          [],\r\n          []\r\n        ];\r\n\r\n        k1 = k1.clone();\r\n        k2 = k2.clone();\r\n        var d1 = 0;\r\n        var d2 = 0;\r\n        while (k1.cmpn(-d1) > 0 || k2.cmpn(-d2) > 0) {\r\n\r\n          // First phase\r\n          var m14 = (k1.andln(3) + d1) & 3;\r\n          var m24 = (k2.andln(3) + d2) & 3;\r\n          if (m14 === 3)\r\n            m14 = -1;\r\n          if (m24 === 3)\r\n            m24 = -1;\r\n          var u1;\r\n          if ((m14 & 1) === 0) {\r\n            u1 = 0;\r\n          } else {\r\n            var m8 = (k1.andln(7) + d1) & 7;\r\n            if ((m8 === 3 || m8 === 5) && m24 === 2)\r\n              u1 = -m14;\r\n            else\r\n              u1 = m14;\r\n          }\r\n          jsf[0].push(u1);\r\n\r\n          var u2;\r\n          if ((m24 & 1) === 0) {\r\n            u2 = 0;\r\n          } else {\r\n            var m8 = (k2.andln(7) + d2) & 7;\r\n            if ((m8 === 3 || m8 === 5) && m14 === 2)\r\n              u2 = -m24;\r\n            else\r\n              u2 = m24;\r\n          }\r\n          jsf[1].push(u2);\r\n\r\n          // Second phase\r\n          if (2 * d1 === u1 + 1)\r\n            d1 = 1 - d1;\r\n          if (2 * d2 === u2 + 1)\r\n            d2 = 1 - d2;\r\n          k1.iushrn(1);\r\n          k2.iushrn(1);\r\n        }\r\n\r\n        return jsf;\r\n      }\r\n      utils.getJSF = getJSF;\r\n\r\n      function cachedProperty(obj, name, computer) {\r\n        var key = '_' + name;\r\n        obj.prototype[name] = function cachedProperty() {\r\n          return this[key] !== undefined ? this[key] :\r\n            this[key] = computer.call(this);\r\n        };\r\n      }\r\n      utils.cachedProperty = cachedProperty;\r\n\r\n      function parseBytes(bytes) {\r\n        return typeof bytes === 'string' ? utils.toArray(bytes, 'hex') :\r\n          bytes;\r\n      }\r\n      utils.parseBytes = parseBytes;\r\n\r\n      function intFromLE(bytes) {\r\n        return new BN(bytes, 'hex', 'le');\r\n      }\r\n      utils.intFromLE = intFromLE;\r\n\r\n\r\n    }, {\r\n      \"bn.js\": 23,\r\n      \"minimalistic-assert\": 111,\r\n      \"minimalistic-crypto-utils\": 112\r\n    }],\r\n    88: [function (require, module, exports) {\r\n      module.exports = {\r\n        \"_args\": [\r\n          [\r\n            \"elliptic@6.4.1\",\r\n            \"C:\\\\Users\\\\Jose\\\\Source\\\\Tide\\\\Tide.Wallet\\\\Tide.EncryptionJs\"\r\n          ]\r\n        ],\r\n        \"_development\": true,\r\n        \"_from\": \"elliptic@6.4.1\",\r\n        \"_id\": \"elliptic@6.4.1\",\r\n        \"_inBundle\": false,\r\n        \"_integrity\": \"sha512-BsXLz5sqX8OHcsh7CqBMztyXARmGQ3LWPtGjJi6DiJHq5C/qvi9P3OqgswKSDftbu8+IoI/QDTAm2fFnQ9SZSQ==\",\r\n        \"_location\": \"/elliptic\",\r\n        \"_phantomChildren\": {},\r\n        \"_requested\": {\r\n          \"type\": \"version\",\r\n          \"registry\": true,\r\n          \"raw\": \"elliptic@6.4.1\",\r\n          \"name\": \"elliptic\",\r\n          \"escapedName\": \"elliptic\",\r\n          \"rawSpec\": \"6.4.1\",\r\n          \"saveSpec\": null,\r\n          \"fetchSpec\": \"6.4.1\"\r\n        },\r\n        \"_requiredBy\": [\r\n          \"/browserify-sign\",\r\n          \"/create-ecdh\"\r\n        ],\r\n        \"_resolved\": \"https://registry.npmjs.org/elliptic/-/elliptic-6.4.1.tgz\",\r\n        \"_spec\": \"6.4.1\",\r\n        \"_where\": \"C:\\\\Users\\\\Jose\\\\Source\\\\Tide\\\\Tide.Wallet\\\\Tide.EncryptionJs\",\r\n        \"author\": {\r\n          \"name\": \"Fedor Indutny\",\r\n          \"email\": \"fedor@indutny.com\"\r\n        },\r\n        \"bugs\": {\r\n          \"url\": \"https://github.com/indutny/elliptic/issues\"\r\n        },\r\n        \"dependencies\": {\r\n          \"bn.js\": \"^4.4.0\",\r\n          \"brorand\": \"^1.0.1\",\r\n          \"hash.js\": \"^1.0.0\",\r\n          \"hmac-drbg\": \"^1.0.0\",\r\n          \"inherits\": \"^2.0.1\",\r\n          \"minimalistic-assert\": \"^1.0.0\",\r\n          \"minimalistic-crypto-utils\": \"^1.0.0\"\r\n        },\r\n        \"description\": \"EC cryptography\",\r\n        \"devDependencies\": {\r\n          \"brfs\": \"^1.4.3\",\r\n          \"coveralls\": \"^2.11.3\",\r\n          \"grunt\": \"^0.4.5\",\r\n          \"grunt-browserify\": \"^5.0.0\",\r\n          \"grunt-cli\": \"^1.2.0\",\r\n          \"grunt-contrib-connect\": \"^1.0.0\",\r\n          \"grunt-contrib-copy\": \"^1.0.0\",\r\n          \"grunt-contrib-uglify\": \"^1.0.1\",\r\n          \"grunt-mocha-istanbul\": \"^3.0.1\",\r\n          \"grunt-saucelabs\": \"^8.6.2\",\r\n          \"istanbul\": \"^0.4.2\",\r\n          \"jscs\": \"^2.9.0\",\r\n          \"jshint\": \"^2.6.0\",\r\n          \"mocha\": \"^2.1.0\"\r\n        },\r\n        \"files\": [\r\n          \"lib\"\r\n        ],\r\n        \"homepage\": \"https://github.com/indutny/elliptic\",\r\n        \"keywords\": [\r\n          \"EC\",\r\n          \"Elliptic\",\r\n          \"curve\",\r\n          \"Cryptography\"\r\n        ],\r\n        \"license\": \"MIT\",\r\n        \"main\": \"lib/elliptic.js\",\r\n        \"name\": \"elliptic\",\r\n        \"repository\": {\r\n          \"type\": \"git\",\r\n          \"url\": \"git+ssh://git@github.com/indutny/elliptic.git\"\r\n        },\r\n        \"scripts\": {\r\n          \"jscs\": \"jscs benchmarks/*.js lib/*.js lib/**/*.js lib/**/**/*.js test/index.js\",\r\n          \"jshint\": \"jscs benchmarks/*.js lib/*.js lib/**/*.js lib/**/**/*.js test/index.js\",\r\n          \"lint\": \"npm run jscs && npm run jshint\",\r\n          \"test\": \"npm run lint && npm run unit\",\r\n          \"unit\": \"istanbul test _mocha --reporter=spec test/index.js\",\r\n          \"version\": \"grunt dist && git add dist/\"\r\n        },\r\n        \"version\": \"6.4.1\"\r\n      }\r\n\r\n    }, {}],\r\n    89: [function (require, module, exports) {\r\n      // Copyright Joyent, Inc. and other Node contributors.\r\n      //\r\n      // Permission is hereby granted, free of charge, to any person obtaining a\r\n      // copy of this software and associated documentation files (the\r\n      // \"Software\"), to deal in the Software without restriction, including\r\n      // without limitation the rights to use, copy, modify, merge, publish,\r\n      // distribute, sublicense, and/or sell copies of the Software, and to permit\r\n      // persons to whom the Software is furnished to do so, subject to the\r\n      // following conditions:\r\n      //\r\n      // The above copyright notice and this permission notice shall be included\r\n      // in all copies or substantial portions of the Software.\r\n      //\r\n      // THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\r\n      // OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\r\n      // MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\r\n      // NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\r\n      // DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\r\n      // OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\r\n      // USE OR OTHER DEALINGS IN THE SOFTWARE.\r\n\r\n      var objectCreate = Object.create || objectCreatePolyfill\r\n      var objectKeys = Object.keys || objectKeysPolyfill\r\n      var bind = Function.prototype.bind || functionBindPolyfill\r\n\r\n      function EventEmitter() {\r\n        if (!this._events || !Object.prototype.hasOwnProperty.call(this, '_events')) {\r\n          this._events = objectCreate(null);\r\n          this._eventsCount = 0;\r\n        }\r\n\r\n        this._maxListeners = this._maxListeners || undefined;\r\n      }\r\n      module.exports = EventEmitter;\r\n\r\n      // Backwards-compat with node 0.10.x\r\n      EventEmitter.EventEmitter = EventEmitter;\r\n\r\n      EventEmitter.prototype._events = undefined;\r\n      EventEmitter.prototype._maxListeners = undefined;\r\n\r\n      // By default EventEmitters will print a warning if more than 10 listeners are\r\n      // added to it. This is a useful default which helps finding memory leaks.\r\n      var defaultMaxListeners = 10;\r\n\r\n      var hasDefineProperty;\r\n      try {\r\n        var o = {};\r\n        if (Object.defineProperty) Object.defineProperty(o, 'x', {\r\n          value: 0\r\n        });\r\n        hasDefineProperty = o.x === 0;\r\n      } catch (err) {\r\n        hasDefineProperty = false\r\n      }\r\n      if (hasDefineProperty) {\r\n        Object.defineProperty(EventEmitter, 'defaultMaxListeners', {\r\n          enumerable: true,\r\n          get: function () {\r\n            return defaultMaxListeners;\r\n          },\r\n          set: function (arg) {\r\n            // check whether the input is a positive number (whose value is zero or\r\n            // greater and not a NaN).\r\n            if (typeof arg !== 'number' || arg < 0 || arg !== arg)\r\n              throw new TypeError('\"defaultMaxListeners\" must be a positive number');\r\n            defaultMaxListeners = arg;\r\n          }\r\n        });\r\n      } else {\r\n        EventEmitter.defaultMaxListeners = defaultMaxListeners;\r\n      }\r\n\r\n      // Obviously not all Emitters should be limited to 10. This function allows\r\n      // that to be increased. Set to zero for unlimited.\r\n      EventEmitter.prototype.setMaxListeners = function setMaxListeners(n) {\r\n        if (typeof n !== 'number' || n < 0 || isNaN(n))\r\n          throw new TypeError('\"n\" argument must be a positive number');\r\n        this._maxListeners = n;\r\n        return this;\r\n      };\r\n\r\n      function $getMaxListeners(that) {\r\n        if (that._maxListeners === undefined)\r\n          return EventEmitter.defaultMaxListeners;\r\n        return that._maxListeners;\r\n      }\r\n\r\n      EventEmitter.prototype.getMaxListeners = function getMaxListeners() {\r\n        return $getMaxListeners(this);\r\n      };\r\n\r\n      // These standalone emit* functions are used to optimize calling of event\r\n      // handlers for fast cases because emit() itself often has a variable number of\r\n      // arguments and can be deoptimized because of that. These functions always have\r\n      // the same number of arguments and thus do not get deoptimized, so the code\r\n      // inside them can execute faster.\r\n      function emitNone(handler, isFn, self) {\r\n        if (isFn)\r\n          handler.call(self);\r\n        else {\r\n          var len = handler.length;\r\n          var listeners = arrayClone(handler, len);\r\n          for (var i = 0; i < len; ++i)\r\n            listeners[i].call(self);\r\n        }\r\n      }\r\n\r\n      function emitOne(handler, isFn, self, arg1) {\r\n        if (isFn)\r\n          handler.call(self, arg1);\r\n        else {\r\n          var len = handler.length;\r\n          var listeners = arrayClone(handler, len);\r\n          for (var i = 0; i < len; ++i)\r\n            listeners[i].call(self, arg1);\r\n        }\r\n      }\r\n\r\n      function emitTwo(handler, isFn, self, arg1, arg2) {\r\n        if (isFn)\r\n          handler.call(self, arg1, arg2);\r\n        else {\r\n          var len = handler.length;\r\n          var listeners = arrayClone(handler, len);\r\n          for (var i = 0; i < len; ++i)\r\n            listeners[i].call(self, arg1, arg2);\r\n        }\r\n      }\r\n\r\n      function emitThree(handler, isFn, self, arg1, arg2, arg3) {\r\n        if (isFn)\r\n          handler.call(self, arg1, arg2, arg3);\r\n        else {\r\n          var len = handler.length;\r\n          var listeners = arrayClone(handler, len);\r\n          for (var i = 0; i < len; ++i)\r\n            listeners[i].call(self, arg1, arg2, arg3);\r\n        }\r\n      }\r\n\r\n      function emitMany(handler, isFn, self, args) {\r\n        if (isFn)\r\n          handler.apply(self, args);\r\n        else {\r\n          var len = handler.length;\r\n          var listeners = arrayClone(handler, len);\r\n          for (var i = 0; i < len; ++i)\r\n            listeners[i].apply(self, args);\r\n        }\r\n      }\r\n\r\n      EventEmitter.prototype.emit = function emit(type) {\r\n        var er, handler, len, args, i, events;\r\n        var doError = (type === 'error');\r\n\r\n        events = this._events;\r\n        if (events)\r\n          doError = (doError && events.error == null);\r\n        else if (!doError)\r\n          return false;\r\n\r\n        // If there is no 'error' event listener then throw.\r\n        if (doError) {\r\n          if (arguments.length > 1)\r\n            er = arguments[1];\r\n          if (er instanceof Error) {\r\n            throw er; // Unhandled 'error' event\r\n          } else {\r\n            // At least give some kind of context to the user\r\n            var err = new Error('Unhandled \"error\" event. (' + er + ')');\r\n            err.context = er;\r\n            throw err;\r\n          }\r\n          return false;\r\n        }\r\n\r\n        handler = events[type];\r\n\r\n        if (!handler)\r\n          return false;\r\n\r\n        var isFn = typeof handler === 'function';\r\n        len = arguments.length;\r\n        switch (len) {\r\n          // fast cases\r\n          case 1:\r\n            emitNone(handler, isFn, this);\r\n            break;\r\n          case 2:\r\n            emitOne(handler, isFn, this, arguments[1]);\r\n            break;\r\n          case 3:\r\n            emitTwo(handler, isFn, this, arguments[1], arguments[2]);\r\n            break;\r\n          case 4:\r\n            emitThree(handler, isFn, this, arguments[1], arguments[2], arguments[3]);\r\n            break;\r\n            // slower\r\n          default:\r\n            args = new Array(len - 1);\r\n            for (i = 1; i < len; i++)\r\n              args[i - 1] = arguments[i];\r\n            emitMany(handler, isFn, this, args);\r\n        }\r\n\r\n        return true;\r\n      };\r\n\r\n      function _addListener(target, type, listener, prepend) {\r\n        var m;\r\n        var events;\r\n        var existing;\r\n\r\n        if (typeof listener !== 'function')\r\n          throw new TypeError('\"listener\" argument must be a function');\r\n\r\n        events = target._events;\r\n        if (!events) {\r\n          events = target._events = objectCreate(null);\r\n          target._eventsCount = 0;\r\n        } else {\r\n          // To avoid recursion in the case that type === \"newListener\"! Before\r\n          // adding it to the listeners, first emit \"newListener\".\r\n          if (events.newListener) {\r\n            target.emit('newListener', type,\r\n              listener.listener ? listener.listener : listener);\r\n\r\n            // Re-assign `events` because a newListener handler could have caused the\r\n            // this._events to be assigned to a new object\r\n            events = target._events;\r\n          }\r\n          existing = events[type];\r\n        }\r\n\r\n        if (!existing) {\r\n          // Optimize the case of one listener. Don't need the extra array object.\r\n          existing = events[type] = listener;\r\n          ++target._eventsCount;\r\n        } else {\r\n          if (typeof existing === 'function') {\r\n            // Adding the second element, need to change to array.\r\n            existing = events[type] =\r\n              prepend ? [listener, existing] : [existing, listener];\r\n          } else {\r\n            // If we've already got an array, just append.\r\n            if (prepend) {\r\n              existing.unshift(listener);\r\n            } else {\r\n              existing.push(listener);\r\n            }\r\n          }\r\n\r\n          // Check for listener leak\r\n          if (!existing.warned) {\r\n            m = $getMaxListeners(target);\r\n            if (m && m > 0 && existing.length > m) {\r\n              existing.warned = true;\r\n              var w = new Error('Possible EventEmitter memory leak detected. ' +\r\n                existing.length + ' \"' + String(type) + '\" listeners ' +\r\n                'added. Use emitter.setMaxListeners() to ' +\r\n                'increase limit.');\r\n              w.name = 'MaxListenersExceededWarning';\r\n              w.emitter = target;\r\n              w.type = type;\r\n              w.count = existing.length;\r\n              if (typeof console === 'object' && console.warn) {\r\n                console.warn('%s: %s', w.name, w.message);\r\n              }\r\n            }\r\n          }\r\n        }\r\n\r\n        return target;\r\n      }\r\n\r\n      EventEmitter.prototype.addListener = function addListener(type, listener) {\r\n        return _addListener(this, type, listener, false);\r\n      };\r\n\r\n      EventEmitter.prototype.on = EventEmitter.prototype.addListener;\r\n\r\n      EventEmitter.prototype.prependListener =\r\n        function prependListener(type, listener) {\r\n          return _addListener(this, type, listener, true);\r\n        };\r\n\r\n      function onceWrapper() {\r\n        if (!this.fired) {\r\n          this.target.removeListener(this.type, this.wrapFn);\r\n          this.fired = true;\r\n          switch (arguments.length) {\r\n            case 0:\r\n              return this.listener.call(this.target);\r\n            case 1:\r\n              return this.listener.call(this.target, arguments[0]);\r\n            case 2:\r\n              return this.listener.call(this.target, arguments[0], arguments[1]);\r\n            case 3:\r\n              return this.listener.call(this.target, arguments[0], arguments[1],\r\n                arguments[2]);\r\n            default:\r\n              var args = new Array(arguments.length);\r\n              for (var i = 0; i < args.length; ++i)\r\n                args[i] = arguments[i];\r\n              this.listener.apply(this.target, args);\r\n          }\r\n        }\r\n      }\r\n\r\n      function _onceWrap(target, type, listener) {\r\n        var state = {\r\n          fired: false,\r\n          wrapFn: undefined,\r\n          target: target,\r\n          type: type,\r\n          listener: listener\r\n        };\r\n        var wrapped = bind.call(onceWrapper, state);\r\n        wrapped.listener = listener;\r\n        state.wrapFn = wrapped;\r\n        return wrapped;\r\n      }\r\n\r\n      EventEmitter.prototype.once = function once(type, listener) {\r\n        if (typeof listener !== 'function')\r\n          throw new TypeError('\"listener\" argument must be a function');\r\n        this.on(type, _onceWrap(this, type, listener));\r\n        return this;\r\n      };\r\n\r\n      EventEmitter.prototype.prependOnceListener =\r\n        function prependOnceListener(type, listener) {\r\n          if (typeof listener !== 'function')\r\n            throw new TypeError('\"listener\" argument must be a function');\r\n          this.prependListener(type, _onceWrap(this, type, listener));\r\n          return this;\r\n        };\r\n\r\n      // Emits a 'removeListener' event if and only if the listener was removed.\r\n      EventEmitter.prototype.removeListener =\r\n        function removeListener(type, listener) {\r\n          var list, events, position, i, originalListener;\r\n\r\n          if (typeof listener !== 'function')\r\n            throw new TypeError('\"listener\" argument must be a function');\r\n\r\n          events = this._events;\r\n          if (!events)\r\n            return this;\r\n\r\n          list = events[type];\r\n          if (!list)\r\n            return this;\r\n\r\n          if (list === listener || list.listener === listener) {\r\n            if (--this._eventsCount === 0)\r\n              this._events = objectCreate(null);\r\n            else {\r\n              delete events[type];\r\n              if (events.removeListener)\r\n                this.emit('removeListener', type, list.listener || listener);\r\n            }\r\n          } else if (typeof list !== 'function') {\r\n            position = -1;\r\n\r\n            for (i = list.length - 1; i >= 0; i--) {\r\n              if (list[i] === listener || list[i].listener === listener) {\r\n                originalListener = list[i].listener;\r\n                position = i;\r\n                break;\r\n              }\r\n            }\r\n\r\n            if (position < 0)\r\n              return this;\r\n\r\n            if (position === 0)\r\n              list.shift();\r\n            else\r\n              spliceOne(list, position);\r\n\r\n            if (list.length === 1)\r\n              events[type] = list[0];\r\n\r\n            if (events.removeListener)\r\n              this.emit('removeListener', type, originalListener || listener);\r\n          }\r\n\r\n          return this;\r\n        };\r\n\r\n      EventEmitter.prototype.removeAllListeners =\r\n        function removeAllListeners(type) {\r\n          var listeners, events, i;\r\n\r\n          events = this._events;\r\n          if (!events)\r\n            return this;\r\n\r\n          // not listening for removeListener, no need to emit\r\n          if (!events.removeListener) {\r\n            if (arguments.length === 0) {\r\n              this._events = objectCreate(null);\r\n              this._eventsCount = 0;\r\n            } else if (events[type]) {\r\n              if (--this._eventsCount === 0)\r\n                this._events = objectCreate(null);\r\n              else\r\n                delete events[type];\r\n            }\r\n            return this;\r\n          }\r\n\r\n          // emit removeListener for all listeners on all events\r\n          if (arguments.length === 0) {\r\n            var keys = objectKeys(events);\r\n            var key;\r\n            for (i = 0; i < keys.length; ++i) {\r\n              key = keys[i];\r\n              if (key === 'removeListener') continue;\r\n              this.removeAllListeners(key);\r\n            }\r\n            this.removeAllListeners('removeListener');\r\n            this._events = objectCreate(null);\r\n            this._eventsCount = 0;\r\n            return this;\r\n          }\r\n\r\n          listeners = events[type];\r\n\r\n          if (typeof listeners === 'function') {\r\n            this.removeListener(type, listeners);\r\n          } else if (listeners) {\r\n            // LIFO order\r\n            for (i = listeners.length - 1; i >= 0; i--) {\r\n              this.removeListener(type, listeners[i]);\r\n            }\r\n          }\r\n\r\n          return this;\r\n        };\r\n\r\n      function _listeners(target, type, unwrap) {\r\n        var events = target._events;\r\n\r\n        if (!events)\r\n          return [];\r\n\r\n        var evlistener = events[type];\r\n        if (!evlistener)\r\n          return [];\r\n\r\n        if (typeof evlistener === 'function')\r\n          return unwrap ? [evlistener.listener || evlistener] : [evlistener];\r\n\r\n        return unwrap ? unwrapListeners(evlistener) : arrayClone(evlistener, evlistener.length);\r\n      }\r\n\r\n      EventEmitter.prototype.listeners = function listeners(type) {\r\n        return _listeners(this, type, true);\r\n      };\r\n\r\n      EventEmitter.prototype.rawListeners = function rawListeners(type) {\r\n        return _listeners(this, type, false);\r\n      };\r\n\r\n      EventEmitter.listenerCount = function (emitter, type) {\r\n        if (typeof emitter.listenerCount === 'function') {\r\n          return emitter.listenerCount(type);\r\n        } else {\r\n          return listenerCount.call(emitter, type);\r\n        }\r\n      };\r\n\r\n      EventEmitter.prototype.listenerCount = listenerCount;\r\n\r\n      function listenerCount(type) {\r\n        var events = this._events;\r\n\r\n        if (events) {\r\n          var evlistener = events[type];\r\n\r\n          if (typeof evlistener === 'function') {\r\n            return 1;\r\n          } else if (evlistener) {\r\n            return evlistener.length;\r\n          }\r\n        }\r\n\r\n        return 0;\r\n      }\r\n\r\n      EventEmitter.prototype.eventNames = function eventNames() {\r\n        return this._eventsCount > 0 ? Reflect.ownKeys(this._events) : [];\r\n      };\r\n\r\n      // About 1.5x faster than the two-arg version of Array#splice().\r\n      function spliceOne(list, index) {\r\n        for (var i = index, k = i + 1, n = list.length; k < n; i += 1, k += 1)\r\n          list[i] = list[k];\r\n        list.pop();\r\n      }\r\n\r\n      function arrayClone(arr, n) {\r\n        var copy = new Array(n);\r\n        for (var i = 0; i < n; ++i)\r\n          copy[i] = arr[i];\r\n        return copy;\r\n      }\r\n\r\n      function unwrapListeners(arr) {\r\n        var ret = new Array(arr.length);\r\n        for (var i = 0; i < ret.length; ++i) {\r\n          ret[i] = arr[i].listener || arr[i];\r\n        }\r\n        return ret;\r\n      }\r\n\r\n      function objectCreatePolyfill(proto) {\r\n        var F = function () {};\r\n        F.prototype = proto;\r\n        return new F;\r\n      }\r\n\r\n      function objectKeysPolyfill(obj) {\r\n        var keys = [];\r\n        for (var k in obj)\r\n          if (Object.prototype.hasOwnProperty.call(obj, k)) {\r\n            keys.push(k);\r\n          }\r\n        return k;\r\n      }\r\n\r\n      function functionBindPolyfill(context) {\r\n        var fn = this;\r\n        return function () {\r\n          return fn.apply(context, arguments);\r\n        };\r\n      }\r\n\r\n    }, {}],\r\n    90: [function (require, module, exports) {\r\n      var Buffer = require('safe-buffer').Buffer\r\n      var MD5 = require('md5.js')\r\n\r\n      /* eslint-disable camelcase */\r\n      function EVP_BytesToKey(password, salt, keyBits, ivLen) {\r\n        if (!Buffer.isBuffer(password)) password = Buffer.from(password, 'binary')\r\n        if (salt) {\r\n          if (!Buffer.isBuffer(salt)) salt = Buffer.from(salt, 'binary')\r\n          if (salt.length !== 8) throw new RangeError('salt should be Buffer with 8 byte length')\r\n        }\r\n\r\n        var keyLen = keyBits / 8\r\n        var key = Buffer.alloc(keyLen)\r\n        var iv = Buffer.alloc(ivLen || 0)\r\n        var tmp = Buffer.alloc(0)\r\n\r\n        while (keyLen > 0 || ivLen > 0) {\r\n          var hash = new MD5()\r\n          hash.update(tmp)\r\n          hash.update(password)\r\n          if (salt) hash.update(salt)\r\n          tmp = hash.digest()\r\n\r\n          var used = 0\r\n\r\n          if (keyLen > 0) {\r\n            var keyStart = key.length - keyLen\r\n            used = Math.min(keyLen, tmp.length)\r\n            tmp.copy(key, keyStart, 0, used)\r\n            keyLen -= used\r\n          }\r\n\r\n          if (used < tmp.length && ivLen > 0) {\r\n            var ivStart = iv.length - ivLen\r\n            var length = Math.min(ivLen, tmp.length - used)\r\n            tmp.copy(iv, ivStart, used, used + length)\r\n            ivLen -= length\r\n          }\r\n        }\r\n\r\n        tmp.fill(0)\r\n        return {\r\n          key: key,\r\n          iv: iv\r\n        }\r\n      }\r\n\r\n      module.exports = EVP_BytesToKey\r\n\r\n    }, {\r\n      \"md5.js\": 109,\r\n      \"safe-buffer\": 147\r\n    }],\r\n    91: [function (require, module, exports) {\r\n      'use strict'\r\n      var Buffer = require('safe-buffer').Buffer\r\n      var Transform = require('stream').Transform\r\n      var inherits = require('inherits')\r\n\r\n      function throwIfNotStringOrBuffer(val, prefix) {\r\n        if (!Buffer.isBuffer(val) && typeof val !== 'string') {\r\n          throw new TypeError(prefix + ' must be a string or a buffer')\r\n        }\r\n      }\r\n\r\n      function HashBase(blockSize) {\r\n        Transform.call(this)\r\n\r\n        this._block = Buffer.allocUnsafe(blockSize)\r\n        this._blockSize = blockSize\r\n        this._blockOffset = 0\r\n        this._length = [0, 0, 0, 0]\r\n\r\n        this._finalized = false\r\n      }\r\n\r\n      inherits(HashBase, Transform)\r\n\r\n      HashBase.prototype._transform = function (chunk, encoding, callback) {\r\n        var error = null\r\n        try {\r\n          this.update(chunk, encoding)\r\n        } catch (err) {\r\n          error = err\r\n        }\r\n\r\n        callback(error)\r\n      }\r\n\r\n      HashBase.prototype._flush = function (callback) {\r\n        var error = null\r\n        try {\r\n          this.push(this.digest())\r\n        } catch (err) {\r\n          error = err\r\n        }\r\n\r\n        callback(error)\r\n      }\r\n\r\n      HashBase.prototype.update = function (data, encoding) {\r\n        throwIfNotStringOrBuffer(data, 'Data')\r\n        if (this._finalized) throw new Error('Digest already called')\r\n        if (!Buffer.isBuffer(data)) data = Buffer.from(data, encoding)\r\n\r\n        // consume data\r\n        var block = this._block\r\n        var offset = 0\r\n        while (this._blockOffset + data.length - offset >= this._blockSize) {\r\n          for (var i = this._blockOffset; i < this._blockSize;) block[i++] = data[offset++]\r\n          this._update()\r\n          this._blockOffset = 0\r\n        }\r\n        while (offset < data.length) block[this._blockOffset++] = data[offset++]\r\n\r\n        // update length\r\n        for (var j = 0, carry = data.length * 8; carry > 0; ++j) {\r\n          this._length[j] += carry\r\n          carry = (this._length[j] / 0x0100000000) | 0\r\n          if (carry > 0) this._length[j] -= 0x0100000000 * carry\r\n        }\r\n\r\n        return this\r\n      }\r\n\r\n      HashBase.prototype._update = function () {\r\n        throw new Error('_update is not implemented')\r\n      }\r\n\r\n      HashBase.prototype.digest = function (encoding) {\r\n        if (this._finalized) throw new Error('Digest already called')\r\n        this._finalized = true\r\n\r\n        var digest = this._digest()\r\n        if (encoding !== undefined) digest = digest.toString(encoding)\r\n\r\n        // reset state\r\n        this._block.fill(0)\r\n        this._blockOffset = 0\r\n        for (var i = 0; i < 4; ++i) this._length[i] = 0\r\n\r\n        return digest\r\n      }\r\n\r\n      HashBase.prototype._digest = function () {\r\n        throw new Error('_digest is not implemented')\r\n      }\r\n\r\n      module.exports = HashBase\r\n\r\n    }, {\r\n      \"inherits\": 106,\r\n      \"safe-buffer\": 147,\r\n      \"stream\": 156\r\n    }],\r\n    92: [function (require, module, exports) {\r\n      var hash = exports;\r\n\r\n      hash.utils = require('./hash/utils');\r\n      hash.common = require('./hash/common');\r\n      hash.sha = require('./hash/sha');\r\n      hash.ripemd = require('./hash/ripemd');\r\n      hash.hmac = require('./hash/hmac');\r\n\r\n      // Proxy hash functions to the main object\r\n      hash.sha1 = hash.sha.sha1;\r\n      hash.sha256 = hash.sha.sha256;\r\n      hash.sha224 = hash.sha.sha224;\r\n      hash.sha384 = hash.sha.sha384;\r\n      hash.sha512 = hash.sha.sha512;\r\n      hash.ripemd160 = hash.ripemd.ripemd160;\r\n\r\n    }, {\r\n      \"./hash/common\": 93,\r\n      \"./hash/hmac\": 94,\r\n      \"./hash/ripemd\": 95,\r\n      \"./hash/sha\": 96,\r\n      \"./hash/utils\": 103\r\n    }],\r\n    93: [function (require, module, exports) {\r\n      'use strict';\r\n\r\n      var utils = require('./utils');\r\n      var assert = require('minimalistic-assert');\r\n\r\n      function BlockHash() {\r\n        this.pending = null;\r\n        this.pendingTotal = 0;\r\n        this.blockSize = this.constructor.blockSize;\r\n        this.outSize = this.constructor.outSize;\r\n        this.hmacStrength = this.constructor.hmacStrength;\r\n        this.padLength = this.constructor.padLength / 8;\r\n        this.endian = 'big';\r\n\r\n        this._delta8 = this.blockSize / 8;\r\n        this._delta32 = this.blockSize / 32;\r\n      }\r\n      exports.BlockHash = BlockHash;\r\n\r\n      BlockHash.prototype.update = function update(msg, enc) {\r\n        // Convert message to array, pad it, and join into 32bit blocks\r\n        msg = utils.toArray(msg, enc);\r\n        if (!this.pending)\r\n          this.pending = msg;\r\n        else\r\n          this.pending = this.pending.concat(msg);\r\n        this.pendingTotal += msg.length;\r\n\r\n        // Enough data, try updating\r\n        if (this.pending.length >= this._delta8) {\r\n          msg = this.pending;\r\n\r\n          // Process pending data in blocks\r\n          var r = msg.length % this._delta8;\r\n          this.pending = msg.slice(msg.length - r, msg.length);\r\n          if (this.pending.length === 0)\r\n            this.pending = null;\r\n\r\n          msg = utils.join32(msg, 0, msg.length - r, this.endian);\r\n          for (var i = 0; i < msg.length; i += this._delta32)\r\n            this._update(msg, i, i + this._delta32);\r\n        }\r\n\r\n        return this;\r\n      };\r\n\r\n      BlockHash.prototype.digest = function digest(enc) {\r\n        this.update(this._pad());\r\n        assert(this.pending === null);\r\n\r\n        return this._digest(enc);\r\n      };\r\n\r\n      BlockHash.prototype._pad = function pad() {\r\n        var len = this.pendingTotal;\r\n        var bytes = this._delta8;\r\n        var k = bytes - ((len + this.padLength) % bytes);\r\n        var res = new Array(k + this.padLength);\r\n        res[0] = 0x80;\r\n        for (var i = 1; i < k; i++)\r\n          res[i] = 0;\r\n\r\n        // Append length\r\n        len <<= 3;\r\n        if (this.endian === 'big') {\r\n          for (var t = 8; t < this.padLength; t++)\r\n            res[i++] = 0;\r\n\r\n          res[i++] = 0;\r\n          res[i++] = 0;\r\n          res[i++] = 0;\r\n          res[i++] = 0;\r\n          res[i++] = (len >>> 24) & 0xff;\r\n          res[i++] = (len >>> 16) & 0xff;\r\n          res[i++] = (len >>> 8) & 0xff;\r\n          res[i++] = len & 0xff;\r\n        } else {\r\n          res[i++] = len & 0xff;\r\n          res[i++] = (len >>> 8) & 0xff;\r\n          res[i++] = (len >>> 16) & 0xff;\r\n          res[i++] = (len >>> 24) & 0xff;\r\n          res[i++] = 0;\r\n          res[i++] = 0;\r\n          res[i++] = 0;\r\n          res[i++] = 0;\r\n\r\n          for (t = 8; t < this.padLength; t++)\r\n            res[i++] = 0;\r\n        }\r\n\r\n        return res;\r\n      };\r\n\r\n    }, {\r\n      \"./utils\": 103,\r\n      \"minimalistic-assert\": 111\r\n    }],\r\n    94: [function (require, module, exports) {\r\n      'use strict';\r\n\r\n      var utils = require('./utils');\r\n      var assert = require('minimalistic-assert');\r\n\r\n      function Hmac(hash, key, enc) {\r\n        if (!(this instanceof Hmac))\r\n          return new Hmac(hash, key, enc);\r\n        this.Hash = hash;\r\n        this.blockSize = hash.blockSize / 8;\r\n        this.outSize = hash.outSize / 8;\r\n        this.inner = null;\r\n        this.outer = null;\r\n\r\n        this._init(utils.toArray(key, enc));\r\n      }\r\n      module.exports = Hmac;\r\n\r\n      Hmac.prototype._init = function init(key) {\r\n        // Shorten key, if needed\r\n        if (key.length > this.blockSize)\r\n          key = new this.Hash().update(key).digest();\r\n        assert(key.length <= this.blockSize);\r\n\r\n        // Add padding to key\r\n        for (var i = key.length; i < this.blockSize; i++)\r\n          key.push(0);\r\n\r\n        for (i = 0; i < key.length; i++)\r\n          key[i] ^= 0x36;\r\n        this.inner = new this.Hash().update(key);\r\n\r\n        // 0x36 ^ 0x5c = 0x6a\r\n        for (i = 0; i < key.length; i++)\r\n          key[i] ^= 0x6a;\r\n        this.outer = new this.Hash().update(key);\r\n      };\r\n\r\n      Hmac.prototype.update = function update(msg, enc) {\r\n        this.inner.update(msg, enc);\r\n        return this;\r\n      };\r\n\r\n      Hmac.prototype.digest = function digest(enc) {\r\n        this.outer.update(this.inner.digest());\r\n        return this.outer.digest(enc);\r\n      };\r\n\r\n    }, {\r\n      \"./utils\": 103,\r\n      \"minimalistic-assert\": 111\r\n    }],\r\n    95: [function (require, module, exports) {\r\n      'use strict';\r\n\r\n      var utils = require('./utils');\r\n      var common = require('./common');\r\n\r\n      var rotl32 = utils.rotl32;\r\n      var sum32 = utils.sum32;\r\n      var sum32_3 = utils.sum32_3;\r\n      var sum32_4 = utils.sum32_4;\r\n      var BlockHash = common.BlockHash;\r\n\r\n      function RIPEMD160() {\r\n        if (!(this instanceof RIPEMD160))\r\n          return new RIPEMD160();\r\n\r\n        BlockHash.call(this);\r\n\r\n        this.h = [0x67452301, 0xefcdab89, 0x98badcfe, 0x10325476, 0xc3d2e1f0];\r\n        this.endian = 'little';\r\n      }\r\n      utils.inherits(RIPEMD160, BlockHash);\r\n      exports.ripemd160 = RIPEMD160;\r\n\r\n      RIPEMD160.blockSize = 512;\r\n      RIPEMD160.outSize = 160;\r\n      RIPEMD160.hmacStrength = 192;\r\n      RIPEMD160.padLength = 64;\r\n\r\n      RIPEMD160.prototype._update = function update(msg, start) {\r\n        var A = this.h[0];\r\n        var B = this.h[1];\r\n        var C = this.h[2];\r\n        var D = this.h[3];\r\n        var E = this.h[4];\r\n        var Ah = A;\r\n        var Bh = B;\r\n        var Ch = C;\r\n        var Dh = D;\r\n        var Eh = E;\r\n        for (var j = 0; j < 80; j++) {\r\n          var T = sum32(\r\n            rotl32(\r\n              sum32_4(A, f(j, B, C, D), msg[r[j] + start], K(j)),\r\n              s[j]),\r\n            E);\r\n          A = E;\r\n          E = D;\r\n          D = rotl32(C, 10);\r\n          C = B;\r\n          B = T;\r\n          T = sum32(\r\n            rotl32(\r\n              sum32_4(Ah, f(79 - j, Bh, Ch, Dh), msg[rh[j] + start], Kh(j)),\r\n              sh[j]),\r\n            Eh);\r\n          Ah = Eh;\r\n          Eh = Dh;\r\n          Dh = rotl32(Ch, 10);\r\n          Ch = Bh;\r\n          Bh = T;\r\n        }\r\n        T = sum32_3(this.h[1], C, Dh);\r\n        this.h[1] = sum32_3(this.h[2], D, Eh);\r\n        this.h[2] = sum32_3(this.h[3], E, Ah);\r\n        this.h[3] = sum32_3(this.h[4], A, Bh);\r\n        this.h[4] = sum32_3(this.h[0], B, Ch);\r\n        this.h[0] = T;\r\n      };\r\n\r\n      RIPEMD160.prototype._digest = function digest(enc) {\r\n        if (enc === 'hex')\r\n          return utils.toHex32(this.h, 'little');\r\n        else\r\n          return utils.split32(this.h, 'little');\r\n      };\r\n\r\n      function f(j, x, y, z) {\r\n        if (j <= 15)\r\n          return x ^ y ^ z;\r\n        else if (j <= 31)\r\n          return (x & y) | ((~x) & z);\r\n        else if (j <= 47)\r\n          return (x | (~y)) ^ z;\r\n        else if (j <= 63)\r\n          return (x & z) | (y & (~z));\r\n        else\r\n          return x ^ (y | (~z));\r\n      }\r\n\r\n      function K(j) {\r\n        if (j <= 15)\r\n          return 0x00000000;\r\n        else if (j <= 31)\r\n          return 0x5a827999;\r\n        else if (j <= 47)\r\n          return 0x6ed9eba1;\r\n        else if (j <= 63)\r\n          return 0x8f1bbcdc;\r\n        else\r\n          return 0xa953fd4e;\r\n      }\r\n\r\n      function Kh(j) {\r\n        if (j <= 15)\r\n          return 0x50a28be6;\r\n        else if (j <= 31)\r\n          return 0x5c4dd124;\r\n        else if (j <= 47)\r\n          return 0x6d703ef3;\r\n        else if (j <= 63)\r\n          return 0x7a6d76e9;\r\n        else\r\n          return 0x00000000;\r\n      }\r\n\r\n      var r = [\r\n        0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15,\r\n        7, 4, 13, 1, 10, 6, 15, 3, 12, 0, 9, 5, 2, 14, 11, 8,\r\n        3, 10, 14, 4, 9, 15, 8, 1, 2, 7, 0, 6, 13, 11, 5, 12,\r\n        1, 9, 11, 10, 0, 8, 12, 4, 13, 3, 7, 15, 14, 5, 6, 2,\r\n        4, 0, 5, 9, 7, 12, 2, 10, 14, 1, 3, 8, 11, 6, 15, 13\r\n      ];\r\n\r\n      var rh = [\r\n        5, 14, 7, 0, 9, 2, 11, 4, 13, 6, 15, 8, 1, 10, 3, 12,\r\n        6, 11, 3, 7, 0, 13, 5, 10, 14, 15, 8, 12, 4, 9, 1, 2,\r\n        15, 5, 1, 3, 7, 14, 6, 9, 11, 8, 12, 2, 10, 0, 4, 13,\r\n        8, 6, 4, 1, 3, 11, 15, 0, 5, 12, 2, 13, 9, 7, 10, 14,\r\n        12, 15, 10, 4, 1, 5, 8, 7, 6, 2, 13, 14, 0, 3, 9, 11\r\n      ];\r\n\r\n      var s = [\r\n        11, 14, 15, 12, 5, 8, 7, 9, 11, 13, 14, 15, 6, 7, 9, 8,\r\n        7, 6, 8, 13, 11, 9, 7, 15, 7, 12, 15, 9, 11, 7, 13, 12,\r\n        11, 13, 6, 7, 14, 9, 13, 15, 14, 8, 13, 6, 5, 12, 7, 5,\r\n        11, 12, 14, 15, 14, 15, 9, 8, 9, 14, 5, 6, 8, 6, 5, 12,\r\n        9, 15, 5, 11, 6, 8, 13, 12, 5, 12, 13, 14, 11, 8, 5, 6\r\n      ];\r\n\r\n      var sh = [\r\n        8, 9, 9, 11, 13, 15, 15, 5, 7, 7, 8, 11, 14, 14, 12, 6,\r\n        9, 13, 15, 7, 12, 8, 9, 11, 7, 7, 12, 7, 6, 15, 13, 11,\r\n        9, 7, 15, 11, 8, 6, 6, 14, 12, 13, 5, 14, 13, 13, 7, 5,\r\n        15, 5, 8, 11, 14, 14, 6, 14, 6, 9, 12, 9, 12, 5, 15, 8,\r\n        8, 5, 12, 9, 12, 5, 14, 6, 8, 13, 6, 5, 15, 13, 11, 11\r\n      ];\r\n\r\n    }, {\r\n      \"./common\": 93,\r\n      \"./utils\": 103\r\n    }],\r\n    96: [function (require, module, exports) {\r\n      'use strict';\r\n\r\n      exports.sha1 = require('./sha/1');\r\n      exports.sha224 = require('./sha/224');\r\n      exports.sha256 = require('./sha/256');\r\n      exports.sha384 = require('./sha/384');\r\n      exports.sha512 = require('./sha/512');\r\n\r\n    }, {\r\n      \"./sha/1\": 97,\r\n      \"./sha/224\": 98,\r\n      \"./sha/256\": 99,\r\n      \"./sha/384\": 100,\r\n      \"./sha/512\": 101\r\n    }],\r\n    97: [function (require, module, exports) {\r\n      'use strict';\r\n\r\n      var utils = require('../utils');\r\n      var common = require('../common');\r\n      var shaCommon = require('./common');\r\n\r\n      var rotl32 = utils.rotl32;\r\n      var sum32 = utils.sum32;\r\n      var sum32_5 = utils.sum32_5;\r\n      var ft_1 = shaCommon.ft_1;\r\n      var BlockHash = common.BlockHash;\r\n\r\n      var sha1_K = [\r\n        0x5A827999, 0x6ED9EBA1,\r\n        0x8F1BBCDC, 0xCA62C1D6\r\n      ];\r\n\r\n      function SHA1() {\r\n        if (!(this instanceof SHA1))\r\n          return new SHA1();\r\n\r\n        BlockHash.call(this);\r\n        this.h = [\r\n          0x67452301, 0xefcdab89, 0x98badcfe,\r\n          0x10325476, 0xc3d2e1f0\r\n        ];\r\n        this.W = new Array(80);\r\n      }\r\n\r\n      utils.inherits(SHA1, BlockHash);\r\n      module.exports = SHA1;\r\n\r\n      SHA1.blockSize = 512;\r\n      SHA1.outSize = 160;\r\n      SHA1.hmacStrength = 80;\r\n      SHA1.padLength = 64;\r\n\r\n      SHA1.prototype._update = function _update(msg, start) {\r\n        var W = this.W;\r\n\r\n        for (var i = 0; i < 16; i++)\r\n          W[i] = msg[start + i];\r\n\r\n        for (; i < W.length; i++)\r\n          W[i] = rotl32(W[i - 3] ^ W[i - 8] ^ W[i - 14] ^ W[i - 16], 1);\r\n\r\n        var a = this.h[0];\r\n        var b = this.h[1];\r\n        var c = this.h[2];\r\n        var d = this.h[3];\r\n        var e = this.h[4];\r\n\r\n        for (i = 0; i < W.length; i++) {\r\n          var s = ~~(i / 20);\r\n          var t = sum32_5(rotl32(a, 5), ft_1(s, b, c, d), e, W[i], sha1_K[s]);\r\n          e = d;\r\n          d = c;\r\n          c = rotl32(b, 30);\r\n          b = a;\r\n          a = t;\r\n        }\r\n\r\n        this.h[0] = sum32(this.h[0], a);\r\n        this.h[1] = sum32(this.h[1], b);\r\n        this.h[2] = sum32(this.h[2], c);\r\n        this.h[3] = sum32(this.h[3], d);\r\n        this.h[4] = sum32(this.h[4], e);\r\n      };\r\n\r\n      SHA1.prototype._digest = function digest(enc) {\r\n        if (enc === 'hex')\r\n          return utils.toHex32(this.h, 'big');\r\n        else\r\n          return utils.split32(this.h, 'big');\r\n      };\r\n\r\n    }, {\r\n      \"../common\": 93,\r\n      \"../utils\": 103,\r\n      \"./common\": 102\r\n    }],\r\n    98: [function (require, module, exports) {\r\n      'use strict';\r\n\r\n      var utils = require('../utils');\r\n      var SHA256 = require('./256');\r\n\r\n      function SHA224() {\r\n        if (!(this instanceof SHA224))\r\n          return new SHA224();\r\n\r\n        SHA256.call(this);\r\n        this.h = [\r\n          0xc1059ed8, 0x367cd507, 0x3070dd17, 0xf70e5939,\r\n          0xffc00b31, 0x68581511, 0x64f98fa7, 0xbefa4fa4\r\n        ];\r\n      }\r\n      utils.inherits(SHA224, SHA256);\r\n      module.exports = SHA224;\r\n\r\n      SHA224.blockSize = 512;\r\n      SHA224.outSize = 224;\r\n      SHA224.hmacStrength = 192;\r\n      SHA224.padLength = 64;\r\n\r\n      SHA224.prototype._digest = function digest(enc) {\r\n        // Just truncate output\r\n        if (enc === 'hex')\r\n          return utils.toHex32(this.h.slice(0, 7), 'big');\r\n        else\r\n          return utils.split32(this.h.slice(0, 7), 'big');\r\n      };\r\n\r\n\r\n    }, {\r\n      \"../utils\": 103,\r\n      \"./256\": 99\r\n    }],\r\n    99: [function (require, module, exports) {\r\n      'use strict';\r\n\r\n      var utils = require('../utils');\r\n      var common = require('../common');\r\n      var shaCommon = require('./common');\r\n      var assert = require('minimalistic-assert');\r\n\r\n      var sum32 = utils.sum32;\r\n      var sum32_4 = utils.sum32_4;\r\n      var sum32_5 = utils.sum32_5;\r\n      var ch32 = shaCommon.ch32;\r\n      var maj32 = shaCommon.maj32;\r\n      var s0_256 = shaCommon.s0_256;\r\n      var s1_256 = shaCommon.s1_256;\r\n      var g0_256 = shaCommon.g0_256;\r\n      var g1_256 = shaCommon.g1_256;\r\n\r\n      var BlockHash = common.BlockHash;\r\n\r\n      var sha256_K = [\r\n        0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5,\r\n        0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,\r\n        0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3,\r\n        0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,\r\n        0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc,\r\n        0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,\r\n        0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7,\r\n        0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,\r\n        0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13,\r\n        0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,\r\n        0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3,\r\n        0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,\r\n        0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5,\r\n        0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,\r\n        0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208,\r\n        0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2\r\n      ];\r\n\r\n      function SHA256() {\r\n        if (!(this instanceof SHA256))\r\n          return new SHA256();\r\n\r\n        BlockHash.call(this);\r\n        this.h = [\r\n          0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a,\r\n          0x510e527f, 0x9b05688c, 0x1f83d9ab, 0x5be0cd19\r\n        ];\r\n        this.k = sha256_K;\r\n        this.W = new Array(64);\r\n      }\r\n      utils.inherits(SHA256, BlockHash);\r\n      module.exports = SHA256;\r\n\r\n      SHA256.blockSize = 512;\r\n      SHA256.outSize = 256;\r\n      SHA256.hmacStrength = 192;\r\n      SHA256.padLength = 64;\r\n\r\n      SHA256.prototype._update = function _update(msg, start) {\r\n        var W = this.W;\r\n\r\n        for (var i = 0; i < 16; i++)\r\n          W[i] = msg[start + i];\r\n        for (; i < W.length; i++)\r\n          W[i] = sum32_4(g1_256(W[i - 2]), W[i - 7], g0_256(W[i - 15]), W[i - 16]);\r\n\r\n        var a = this.h[0];\r\n        var b = this.h[1];\r\n        var c = this.h[2];\r\n        var d = this.h[3];\r\n        var e = this.h[4];\r\n        var f = this.h[5];\r\n        var g = this.h[6];\r\n        var h = this.h[7];\r\n\r\n        assert(this.k.length === W.length);\r\n        for (i = 0; i < W.length; i++) {\r\n          var T1 = sum32_5(h, s1_256(e), ch32(e, f, g), this.k[i], W[i]);\r\n          var T2 = sum32(s0_256(a), maj32(a, b, c));\r\n          h = g;\r\n          g = f;\r\n          f = e;\r\n          e = sum32(d, T1);\r\n          d = c;\r\n          c = b;\r\n          b = a;\r\n          a = sum32(T1, T2);\r\n        }\r\n\r\n        this.h[0] = sum32(this.h[0], a);\r\n        this.h[1] = sum32(this.h[1], b);\r\n        this.h[2] = sum32(this.h[2], c);\r\n        this.h[3] = sum32(this.h[3], d);\r\n        this.h[4] = sum32(this.h[4], e);\r\n        this.h[5] = sum32(this.h[5], f);\r\n        this.h[6] = sum32(this.h[6], g);\r\n        this.h[7] = sum32(this.h[7], h);\r\n      };\r\n\r\n      SHA256.prototype._digest = function digest(enc) {\r\n        if (enc === 'hex')\r\n          return utils.toHex32(this.h, 'big');\r\n        else\r\n          return utils.split32(this.h, 'big');\r\n      };\r\n\r\n    }, {\r\n      \"../common\": 93,\r\n      \"../utils\": 103,\r\n      \"./common\": 102,\r\n      \"minimalistic-assert\": 111\r\n    }],\r\n    100: [function (require, module, exports) {\r\n      'use strict';\r\n\r\n      var utils = require('../utils');\r\n\r\n      var SHA512 = require('./512');\r\n\r\n      function SHA384() {\r\n        if (!(this instanceof SHA384))\r\n          return new SHA384();\r\n\r\n        SHA512.call(this);\r\n        this.h = [\r\n          0xcbbb9d5d, 0xc1059ed8,\r\n          0x629a292a, 0x367cd507,\r\n          0x9159015a, 0x3070dd17,\r\n          0x152fecd8, 0xf70e5939,\r\n          0x67332667, 0xffc00b31,\r\n          0x8eb44a87, 0x68581511,\r\n          0xdb0c2e0d, 0x64f98fa7,\r\n          0x47b5481d, 0xbefa4fa4\r\n        ];\r\n      }\r\n      utils.inherits(SHA384, SHA512);\r\n      module.exports = SHA384;\r\n\r\n      SHA384.blockSize = 1024;\r\n      SHA384.outSize = 384;\r\n      SHA384.hmacStrength = 192;\r\n      SHA384.padLength = 128;\r\n\r\n      SHA384.prototype._digest = function digest(enc) {\r\n        if (enc === 'hex')\r\n          return utils.toHex32(this.h.slice(0, 12), 'big');\r\n        else\r\n          return utils.split32(this.h.slice(0, 12), 'big');\r\n      };\r\n\r\n    }, {\r\n      \"../utils\": 103,\r\n      \"./512\": 101\r\n    }],\r\n    101: [function (require, module, exports) {\r\n      'use strict';\r\n\r\n      var utils = require('../utils');\r\n      var common = require('../common');\r\n      var assert = require('minimalistic-assert');\r\n\r\n      var rotr64_hi = utils.rotr64_hi;\r\n      var rotr64_lo = utils.rotr64_lo;\r\n      var shr64_hi = utils.shr64_hi;\r\n      var shr64_lo = utils.shr64_lo;\r\n      var sum64 = utils.sum64;\r\n      var sum64_hi = utils.sum64_hi;\r\n      var sum64_lo = utils.sum64_lo;\r\n      var sum64_4_hi = utils.sum64_4_hi;\r\n      var sum64_4_lo = utils.sum64_4_lo;\r\n      var sum64_5_hi = utils.sum64_5_hi;\r\n      var sum64_5_lo = utils.sum64_5_lo;\r\n\r\n      var BlockHash = common.BlockHash;\r\n\r\n      var sha512_K = [\r\n        0x428a2f98, 0xd728ae22, 0x71374491, 0x23ef65cd,\r\n        0xb5c0fbcf, 0xec4d3b2f, 0xe9b5dba5, 0x8189dbbc,\r\n        0x3956c25b, 0xf348b538, 0x59f111f1, 0xb605d019,\r\n        0x923f82a4, 0xaf194f9b, 0xab1c5ed5, 0xda6d8118,\r\n        0xd807aa98, 0xa3030242, 0x12835b01, 0x45706fbe,\r\n        0x243185be, 0x4ee4b28c, 0x550c7dc3, 0xd5ffb4e2,\r\n        0x72be5d74, 0xf27b896f, 0x80deb1fe, 0x3b1696b1,\r\n        0x9bdc06a7, 0x25c71235, 0xc19bf174, 0xcf692694,\r\n        0xe49b69c1, 0x9ef14ad2, 0xefbe4786, 0x384f25e3,\r\n        0x0fc19dc6, 0x8b8cd5b5, 0x240ca1cc, 0x77ac9c65,\r\n        0x2de92c6f, 0x592b0275, 0x4a7484aa, 0x6ea6e483,\r\n        0x5cb0a9dc, 0xbd41fbd4, 0x76f988da, 0x831153b5,\r\n        0x983e5152, 0xee66dfab, 0xa831c66d, 0x2db43210,\r\n        0xb00327c8, 0x98fb213f, 0xbf597fc7, 0xbeef0ee4,\r\n        0xc6e00bf3, 0x3da88fc2, 0xd5a79147, 0x930aa725,\r\n        0x06ca6351, 0xe003826f, 0x14292967, 0x0a0e6e70,\r\n        0x27b70a85, 0x46d22ffc, 0x2e1b2138, 0x5c26c926,\r\n        0x4d2c6dfc, 0x5ac42aed, 0x53380d13, 0x9d95b3df,\r\n        0x650a7354, 0x8baf63de, 0x766a0abb, 0x3c77b2a8,\r\n        0x81c2c92e, 0x47edaee6, 0x92722c85, 0x1482353b,\r\n        0xa2bfe8a1, 0x4cf10364, 0xa81a664b, 0xbc423001,\r\n        0xc24b8b70, 0xd0f89791, 0xc76c51a3, 0x0654be30,\r\n        0xd192e819, 0xd6ef5218, 0xd6990624, 0x5565a910,\r\n        0xf40e3585, 0x5771202a, 0x106aa070, 0x32bbd1b8,\r\n        0x19a4c116, 0xb8d2d0c8, 0x1e376c08, 0x5141ab53,\r\n        0x2748774c, 0xdf8eeb99, 0x34b0bcb5, 0xe19b48a8,\r\n        0x391c0cb3, 0xc5c95a63, 0x4ed8aa4a, 0xe3418acb,\r\n        0x5b9cca4f, 0x7763e373, 0x682e6ff3, 0xd6b2b8a3,\r\n        0x748f82ee, 0x5defb2fc, 0x78a5636f, 0x43172f60,\r\n        0x84c87814, 0xa1f0ab72, 0x8cc70208, 0x1a6439ec,\r\n        0x90befffa, 0x23631e28, 0xa4506ceb, 0xde82bde9,\r\n        0xbef9a3f7, 0xb2c67915, 0xc67178f2, 0xe372532b,\r\n        0xca273ece, 0xea26619c, 0xd186b8c7, 0x21c0c207,\r\n        0xeada7dd6, 0xcde0eb1e, 0xf57d4f7f, 0xee6ed178,\r\n        0x06f067aa, 0x72176fba, 0x0a637dc5, 0xa2c898a6,\r\n        0x113f9804, 0xbef90dae, 0x1b710b35, 0x131c471b,\r\n        0x28db77f5, 0x23047d84, 0x32caab7b, 0x40c72493,\r\n        0x3c9ebe0a, 0x15c9bebc, 0x431d67c4, 0x9c100d4c,\r\n        0x4cc5d4be, 0xcb3e42b6, 0x597f299c, 0xfc657e2a,\r\n        0x5fcb6fab, 0x3ad6faec, 0x6c44198c, 0x4a475817\r\n      ];\r\n\r\n      function SHA512() {\r\n        if (!(this instanceof SHA512))\r\n          return new SHA512();\r\n\r\n        BlockHash.call(this);\r\n        this.h = [\r\n          0x6a09e667, 0xf3bcc908,\r\n          0xbb67ae85, 0x84caa73b,\r\n          0x3c6ef372, 0xfe94f82b,\r\n          0xa54ff53a, 0x5f1d36f1,\r\n          0x510e527f, 0xade682d1,\r\n          0x9b05688c, 0x2b3e6c1f,\r\n          0x1f83d9ab, 0xfb41bd6b,\r\n          0x5be0cd19, 0x137e2179\r\n        ];\r\n        this.k = sha512_K;\r\n        this.W = new Array(160);\r\n      }\r\n      utils.inherits(SHA512, BlockHash);\r\n      module.exports = SHA512;\r\n\r\n      SHA512.blockSize = 1024;\r\n      SHA512.outSize = 512;\r\n      SHA512.hmacStrength = 192;\r\n      SHA512.padLength = 128;\r\n\r\n      SHA512.prototype._prepareBlock = function _prepareBlock(msg, start) {\r\n        var W = this.W;\r\n\r\n        // 32 x 32bit words\r\n        for (var i = 0; i < 32; i++)\r\n          W[i] = msg[start + i];\r\n        for (; i < W.length; i += 2) {\r\n          var c0_hi = g1_512_hi(W[i - 4], W[i - 3]); // i - 2\r\n          var c0_lo = g1_512_lo(W[i - 4], W[i - 3]);\r\n          var c1_hi = W[i - 14]; // i - 7\r\n          var c1_lo = W[i - 13];\r\n          var c2_hi = g0_512_hi(W[i - 30], W[i - 29]); // i - 15\r\n          var c2_lo = g0_512_lo(W[i - 30], W[i - 29]);\r\n          var c3_hi = W[i - 32]; // i - 16\r\n          var c3_lo = W[i - 31];\r\n\r\n          W[i] = sum64_4_hi(\r\n            c0_hi, c0_lo,\r\n            c1_hi, c1_lo,\r\n            c2_hi, c2_lo,\r\n            c3_hi, c3_lo);\r\n          W[i + 1] = sum64_4_lo(\r\n            c0_hi, c0_lo,\r\n            c1_hi, c1_lo,\r\n            c2_hi, c2_lo,\r\n            c3_hi, c3_lo);\r\n        }\r\n      };\r\n\r\n      SHA512.prototype._update = function _update(msg, start) {\r\n        this._prepareBlock(msg, start);\r\n\r\n        var W = this.W;\r\n\r\n        var ah = this.h[0];\r\n        var al = this.h[1];\r\n        var bh = this.h[2];\r\n        var bl = this.h[3];\r\n        var ch = this.h[4];\r\n        var cl = this.h[5];\r\n        var dh = this.h[6];\r\n        var dl = this.h[7];\r\n        var eh = this.h[8];\r\n        var el = this.h[9];\r\n        var fh = this.h[10];\r\n        var fl = this.h[11];\r\n        var gh = this.h[12];\r\n        var gl = this.h[13];\r\n        var hh = this.h[14];\r\n        var hl = this.h[15];\r\n\r\n        assert(this.k.length === W.length);\r\n        for (var i = 0; i < W.length; i += 2) {\r\n          var c0_hi = hh;\r\n          var c0_lo = hl;\r\n          var c1_hi = s1_512_hi(eh, el);\r\n          var c1_lo = s1_512_lo(eh, el);\r\n          var c2_hi = ch64_hi(eh, el, fh, fl, gh, gl);\r\n          var c2_lo = ch64_lo(eh, el, fh, fl, gh, gl);\r\n          var c3_hi = this.k[i];\r\n          var c3_lo = this.k[i + 1];\r\n          var c4_hi = W[i];\r\n          var c4_lo = W[i + 1];\r\n\r\n          var T1_hi = sum64_5_hi(\r\n            c0_hi, c0_lo,\r\n            c1_hi, c1_lo,\r\n            c2_hi, c2_lo,\r\n            c3_hi, c3_lo,\r\n            c4_hi, c4_lo);\r\n          var T1_lo = sum64_5_lo(\r\n            c0_hi, c0_lo,\r\n            c1_hi, c1_lo,\r\n            c2_hi, c2_lo,\r\n            c3_hi, c3_lo,\r\n            c4_hi, c4_lo);\r\n\r\n          c0_hi = s0_512_hi(ah, al);\r\n          c0_lo = s0_512_lo(ah, al);\r\n          c1_hi = maj64_hi(ah, al, bh, bl, ch, cl);\r\n          c1_lo = maj64_lo(ah, al, bh, bl, ch, cl);\r\n\r\n          var T2_hi = sum64_hi(c0_hi, c0_lo, c1_hi, c1_lo);\r\n          var T2_lo = sum64_lo(c0_hi, c0_lo, c1_hi, c1_lo);\r\n\r\n          hh = gh;\r\n          hl = gl;\r\n\r\n          gh = fh;\r\n          gl = fl;\r\n\r\n          fh = eh;\r\n          fl = el;\r\n\r\n          eh = sum64_hi(dh, dl, T1_hi, T1_lo);\r\n          el = sum64_lo(dl, dl, T1_hi, T1_lo);\r\n\r\n          dh = ch;\r\n          dl = cl;\r\n\r\n          ch = bh;\r\n          cl = bl;\r\n\r\n          bh = ah;\r\n          bl = al;\r\n\r\n          ah = sum64_hi(T1_hi, T1_lo, T2_hi, T2_lo);\r\n          al = sum64_lo(T1_hi, T1_lo, T2_hi, T2_lo);\r\n        }\r\n\r\n        sum64(this.h, 0, ah, al);\r\n        sum64(this.h, 2, bh, bl);\r\n        sum64(this.h, 4, ch, cl);\r\n        sum64(this.h, 6, dh, dl);\r\n        sum64(this.h, 8, eh, el);\r\n        sum64(this.h, 10, fh, fl);\r\n        sum64(this.h, 12, gh, gl);\r\n        sum64(this.h, 14, hh, hl);\r\n      };\r\n\r\n      SHA512.prototype._digest = function digest(enc) {\r\n        if (enc === 'hex')\r\n          return utils.toHex32(this.h, 'big');\r\n        else\r\n          return utils.split32(this.h, 'big');\r\n      };\r\n\r\n      function ch64_hi(xh, xl, yh, yl, zh) {\r\n        var r = (xh & yh) ^ ((~xh) & zh);\r\n        if (r < 0)\r\n          r += 0x100000000;\r\n        return r;\r\n      }\r\n\r\n      function ch64_lo(xh, xl, yh, yl, zh, zl) {\r\n        var r = (xl & yl) ^ ((~xl) & zl);\r\n        if (r < 0)\r\n          r += 0x100000000;\r\n        return r;\r\n      }\r\n\r\n      function maj64_hi(xh, xl, yh, yl, zh) {\r\n        var r = (xh & yh) ^ (xh & zh) ^ (yh & zh);\r\n        if (r < 0)\r\n          r += 0x100000000;\r\n        return r;\r\n      }\r\n\r\n      function maj64_lo(xh, xl, yh, yl, zh, zl) {\r\n        var r = (xl & yl) ^ (xl & zl) ^ (yl & zl);\r\n        if (r < 0)\r\n          r += 0x100000000;\r\n        return r;\r\n      }\r\n\r\n      function s0_512_hi(xh, xl) {\r\n        var c0_hi = rotr64_hi(xh, xl, 28);\r\n        var c1_hi = rotr64_hi(xl, xh, 2); // 34\r\n        var c2_hi = rotr64_hi(xl, xh, 7); // 39\r\n\r\n        var r = c0_hi ^ c1_hi ^ c2_hi;\r\n        if (r < 0)\r\n          r += 0x100000000;\r\n        return r;\r\n      }\r\n\r\n      function s0_512_lo(xh, xl) {\r\n        var c0_lo = rotr64_lo(xh, xl, 28);\r\n        var c1_lo = rotr64_lo(xl, xh, 2); // 34\r\n        var c2_lo = rotr64_lo(xl, xh, 7); // 39\r\n\r\n        var r = c0_lo ^ c1_lo ^ c2_lo;\r\n        if (r < 0)\r\n          r += 0x100000000;\r\n        return r;\r\n      }\r\n\r\n      function s1_512_hi(xh, xl) {\r\n        var c0_hi = rotr64_hi(xh, xl, 14);\r\n        var c1_hi = rotr64_hi(xh, xl, 18);\r\n        var c2_hi = rotr64_hi(xl, xh, 9); // 41\r\n\r\n        var r = c0_hi ^ c1_hi ^ c2_hi;\r\n        if (r < 0)\r\n          r += 0x100000000;\r\n        return r;\r\n      }\r\n\r\n      function s1_512_lo(xh, xl) {\r\n        var c0_lo = rotr64_lo(xh, xl, 14);\r\n        var c1_lo = rotr64_lo(xh, xl, 18);\r\n        var c2_lo = rotr64_lo(xl, xh, 9); // 41\r\n\r\n        var r = c0_lo ^ c1_lo ^ c2_lo;\r\n        if (r < 0)\r\n          r += 0x100000000;\r\n        return r;\r\n      }\r\n\r\n      function g0_512_hi(xh, xl) {\r\n        var c0_hi = rotr64_hi(xh, xl, 1);\r\n        var c1_hi = rotr64_hi(xh, xl, 8);\r\n        var c2_hi = shr64_hi(xh, xl, 7);\r\n\r\n        var r = c0_hi ^ c1_hi ^ c2_hi;\r\n        if (r < 0)\r\n          r += 0x100000000;\r\n        return r;\r\n      }\r\n\r\n      function g0_512_lo(xh, xl) {\r\n        var c0_lo = rotr64_lo(xh, xl, 1);\r\n        var c1_lo = rotr64_lo(xh, xl, 8);\r\n        var c2_lo = shr64_lo(xh, xl, 7);\r\n\r\n        var r = c0_lo ^ c1_lo ^ c2_lo;\r\n        if (r < 0)\r\n          r += 0x100000000;\r\n        return r;\r\n      }\r\n\r\n      function g1_512_hi(xh, xl) {\r\n        var c0_hi = rotr64_hi(xh, xl, 19);\r\n        var c1_hi = rotr64_hi(xl, xh, 29); // 61\r\n        var c2_hi = shr64_hi(xh, xl, 6);\r\n\r\n        var r = c0_hi ^ c1_hi ^ c2_hi;\r\n        if (r < 0)\r\n          r += 0x100000000;\r\n        return r;\r\n      }\r\n\r\n      function g1_512_lo(xh, xl) {\r\n        var c0_lo = rotr64_lo(xh, xl, 19);\r\n        var c1_lo = rotr64_lo(xl, xh, 29); // 61\r\n        var c2_lo = shr64_lo(xh, xl, 6);\r\n\r\n        var r = c0_lo ^ c1_lo ^ c2_lo;\r\n        if (r < 0)\r\n          r += 0x100000000;\r\n        return r;\r\n      }\r\n\r\n    }, {\r\n      \"../common\": 93,\r\n      \"../utils\": 103,\r\n      \"minimalistic-assert\": 111\r\n    }],\r\n    102: [function (require, module, exports) {\r\n      'use strict';\r\n\r\n      var utils = require('../utils');\r\n      var rotr32 = utils.rotr32;\r\n\r\n      function ft_1(s, x, y, z) {\r\n        if (s === 0)\r\n          return ch32(x, y, z);\r\n        if (s === 1 || s === 3)\r\n          return p32(x, y, z);\r\n        if (s === 2)\r\n          return maj32(x, y, z);\r\n      }\r\n      exports.ft_1 = ft_1;\r\n\r\n      function ch32(x, y, z) {\r\n        return (x & y) ^ ((~x) & z);\r\n      }\r\n      exports.ch32 = ch32;\r\n\r\n      function maj32(x, y, z) {\r\n        return (x & y) ^ (x & z) ^ (y & z);\r\n      }\r\n      exports.maj32 = maj32;\r\n\r\n      function p32(x, y, z) {\r\n        return x ^ y ^ z;\r\n      }\r\n      exports.p32 = p32;\r\n\r\n      function s0_256(x) {\r\n        return rotr32(x, 2) ^ rotr32(x, 13) ^ rotr32(x, 22);\r\n      }\r\n      exports.s0_256 = s0_256;\r\n\r\n      function s1_256(x) {\r\n        return rotr32(x, 6) ^ rotr32(x, 11) ^ rotr32(x, 25);\r\n      }\r\n      exports.s1_256 = s1_256;\r\n\r\n      function g0_256(x) {\r\n        return rotr32(x, 7) ^ rotr32(x, 18) ^ (x >>> 3);\r\n      }\r\n      exports.g0_256 = g0_256;\r\n\r\n      function g1_256(x) {\r\n        return rotr32(x, 17) ^ rotr32(x, 19) ^ (x >>> 10);\r\n      }\r\n      exports.g1_256 = g1_256;\r\n\r\n    }, {\r\n      \"../utils\": 103\r\n    }],\r\n    103: [function (require, module, exports) {\r\n      'use strict';\r\n\r\n      var assert = require('minimalistic-assert');\r\n      var inherits = require('inherits');\r\n\r\n      exports.inherits = inherits;\r\n\r\n      function toArray(msg, enc) {\r\n        if (Array.isArray(msg))\r\n          return msg.slice();\r\n        if (!msg)\r\n          return [];\r\n        var res = [];\r\n        if (typeof msg === 'string') {\r\n          if (!enc) {\r\n            for (var i = 0; i < msg.length; i++) {\r\n              var c = msg.charCodeAt(i);\r\n              var hi = c >> 8;\r\n              var lo = c & 0xff;\r\n              if (hi)\r\n                res.push(hi, lo);\r\n              else\r\n                res.push(lo);\r\n            }\r\n          } else if (enc === 'hex') {\r\n            msg = msg.replace(/[^a-z0-9]+/ig, '');\r\n            if (msg.length % 2 !== 0)\r\n              msg = '0' + msg;\r\n            for (i = 0; i < msg.length; i += 2)\r\n              res.push(parseInt(msg[i] + msg[i + 1], 16));\r\n          }\r\n        } else {\r\n          for (i = 0; i < msg.length; i++)\r\n            res[i] = msg[i] | 0;\r\n        }\r\n        return res;\r\n      }\r\n      exports.toArray = toArray;\r\n\r\n      function toHex(msg) {\r\n        var res = '';\r\n        for (var i = 0; i < msg.length; i++)\r\n          res += zero2(msg[i].toString(16));\r\n        return res;\r\n      }\r\n      exports.toHex = toHex;\r\n\r\n      function htonl(w) {\r\n        var res = (w >>> 24) |\r\n          ((w >>> 8) & 0xff00) |\r\n          ((w << 8) & 0xff0000) |\r\n          ((w & 0xff) << 24);\r\n        return res >>> 0;\r\n      }\r\n      exports.htonl = htonl;\r\n\r\n      function toHex32(msg, endian) {\r\n        var res = '';\r\n        for (var i = 0; i < msg.length; i++) {\r\n          var w = msg[i];\r\n          if (endian === 'little')\r\n            w = htonl(w);\r\n          res += zero8(w.toString(16));\r\n        }\r\n        return res;\r\n      }\r\n      exports.toHex32 = toHex32;\r\n\r\n      function zero2(word) {\r\n        if (word.length === 1)\r\n          return '0' + word;\r\n        else\r\n          return word;\r\n      }\r\n      exports.zero2 = zero2;\r\n\r\n      function zero8(word) {\r\n        if (word.length === 7)\r\n          return '0' + word;\r\n        else if (word.length === 6)\r\n          return '00' + word;\r\n        else if (word.length === 5)\r\n          return '000' + word;\r\n        else if (word.length === 4)\r\n          return '0000' + word;\r\n        else if (word.length === 3)\r\n          return '00000' + word;\r\n        else if (word.length === 2)\r\n          return '000000' + word;\r\n        else if (word.length === 1)\r\n          return '0000000' + word;\r\n        else\r\n          return word;\r\n      }\r\n      exports.zero8 = zero8;\r\n\r\n      function join32(msg, start, end, endian) {\r\n        var len = end - start;\r\n        assert(len % 4 === 0);\r\n        var res = new Array(len / 4);\r\n        for (var i = 0, k = start; i < res.length; i++, k += 4) {\r\n          var w;\r\n          if (endian === 'big')\r\n            w = (msg[k] << 24) | (msg[k + 1] << 16) | (msg[k + 2] << 8) | msg[k + 3];\r\n          else\r\n            w = (msg[k + 3] << 24) | (msg[k + 2] << 16) | (msg[k + 1] << 8) | msg[k];\r\n          res[i] = w >>> 0;\r\n        }\r\n        return res;\r\n      }\r\n      exports.join32 = join32;\r\n\r\n      function split32(msg, endian) {\r\n        var res = new Array(msg.length * 4);\r\n        for (var i = 0, k = 0; i < msg.length; i++, k += 4) {\r\n          var m = msg[i];\r\n          if (endian === 'big') {\r\n            res[k] = m >>> 24;\r\n            res[k + 1] = (m >>> 16) & 0xff;\r\n            res[k + 2] = (m >>> 8) & 0xff;\r\n            res[k + 3] = m & 0xff;\r\n          } else {\r\n            res[k + 3] = m >>> 24;\r\n            res[k + 2] = (m >>> 16) & 0xff;\r\n            res[k + 1] = (m >>> 8) & 0xff;\r\n            res[k] = m & 0xff;\r\n          }\r\n        }\r\n        return res;\r\n      }\r\n      exports.split32 = split32;\r\n\r\n      function rotr32(w, b) {\r\n        return (w >>> b) | (w << (32 - b));\r\n      }\r\n      exports.rotr32 = rotr32;\r\n\r\n      function rotl32(w, b) {\r\n        return (w << b) | (w >>> (32 - b));\r\n      }\r\n      exports.rotl32 = rotl32;\r\n\r\n      function sum32(a, b) {\r\n        return (a + b) >>> 0;\r\n      }\r\n      exports.sum32 = sum32;\r\n\r\n      function sum32_3(a, b, c) {\r\n        return (a + b + c) >>> 0;\r\n      }\r\n      exports.sum32_3 = sum32_3;\r\n\r\n      function sum32_4(a, b, c, d) {\r\n        return (a + b + c + d) >>> 0;\r\n      }\r\n      exports.sum32_4 = sum32_4;\r\n\r\n      function sum32_5(a, b, c, d, e) {\r\n        return (a + b + c + d + e) >>> 0;\r\n      }\r\n      exports.sum32_5 = sum32_5;\r\n\r\n      function sum64(buf, pos, ah, al) {\r\n        var bh = buf[pos];\r\n        var bl = buf[pos + 1];\r\n\r\n        var lo = (al + bl) >>> 0;\r\n        var hi = (lo < al ? 1 : 0) + ah + bh;\r\n        buf[pos] = hi >>> 0;\r\n        buf[pos + 1] = lo;\r\n      }\r\n      exports.sum64 = sum64;\r\n\r\n      function sum64_hi(ah, al, bh, bl) {\r\n        var lo = (al + bl) >>> 0;\r\n        var hi = (lo < al ? 1 : 0) + ah + bh;\r\n        return hi >>> 0;\r\n      }\r\n      exports.sum64_hi = sum64_hi;\r\n\r\n      function sum64_lo(ah, al, bh, bl) {\r\n        var lo = al + bl;\r\n        return lo >>> 0;\r\n      }\r\n      exports.sum64_lo = sum64_lo;\r\n\r\n      function sum64_4_hi(ah, al, bh, bl, ch, cl, dh, dl) {\r\n        var carry = 0;\r\n        var lo = al;\r\n        lo = (lo + bl) >>> 0;\r\n        carry += lo < al ? 1 : 0;\r\n        lo = (lo + cl) >>> 0;\r\n        carry += lo < cl ? 1 : 0;\r\n        lo = (lo + dl) >>> 0;\r\n        carry += lo < dl ? 1 : 0;\r\n\r\n        var hi = ah + bh + ch + dh + carry;\r\n        return hi >>> 0;\r\n      }\r\n      exports.sum64_4_hi = sum64_4_hi;\r\n\r\n      function sum64_4_lo(ah, al, bh, bl, ch, cl, dh, dl) {\r\n        var lo = al + bl + cl + dl;\r\n        return lo >>> 0;\r\n      }\r\n      exports.sum64_4_lo = sum64_4_lo;\r\n\r\n      function sum64_5_hi(ah, al, bh, bl, ch, cl, dh, dl, eh, el) {\r\n        var carry = 0;\r\n        var lo = al;\r\n        lo = (lo + bl) >>> 0;\r\n        carry += lo < al ? 1 : 0;\r\n        lo = (lo + cl) >>> 0;\r\n        carry += lo < cl ? 1 : 0;\r\n        lo = (lo + dl) >>> 0;\r\n        carry += lo < dl ? 1 : 0;\r\n        lo = (lo + el) >>> 0;\r\n        carry += lo < el ? 1 : 0;\r\n\r\n        var hi = ah + bh + ch + dh + eh + carry;\r\n        return hi >>> 0;\r\n      }\r\n      exports.sum64_5_hi = sum64_5_hi;\r\n\r\n      function sum64_5_lo(ah, al, bh, bl, ch, cl, dh, dl, eh, el) {\r\n        var lo = al + bl + cl + dl + el;\r\n\r\n        return lo >>> 0;\r\n      }\r\n      exports.sum64_5_lo = sum64_5_lo;\r\n\r\n      function rotr64_hi(ah, al, num) {\r\n        var r = (al << (32 - num)) | (ah >>> num);\r\n        return r >>> 0;\r\n      }\r\n      exports.rotr64_hi = rotr64_hi;\r\n\r\n      function rotr64_lo(ah, al, num) {\r\n        var r = (ah << (32 - num)) | (al >>> num);\r\n        return r >>> 0;\r\n      }\r\n      exports.rotr64_lo = rotr64_lo;\r\n\r\n      function shr64_hi(ah, al, num) {\r\n        return ah >>> num;\r\n      }\r\n      exports.shr64_hi = shr64_hi;\r\n\r\n      function shr64_lo(ah, al, num) {\r\n        var r = (ah << (32 - num)) | (al >>> num);\r\n        return r >>> 0;\r\n      }\r\n      exports.shr64_lo = shr64_lo;\r\n\r\n    }, {\r\n      \"inherits\": 106,\r\n      \"minimalistic-assert\": 111\r\n    }],\r\n    104: [function (require, module, exports) {\r\n      'use strict';\r\n\r\n      var hash = require('hash.js');\r\n      var utils = require('minimalistic-crypto-utils');\r\n      var assert = require('minimalistic-assert');\r\n\r\n      function HmacDRBG(options) {\r\n        if (!(this instanceof HmacDRBG))\r\n          return new HmacDRBG(options);\r\n        this.hash = options.hash;\r\n        this.predResist = !!options.predResist;\r\n\r\n        this.outLen = this.hash.outSize;\r\n        this.minEntropy = options.minEntropy || this.hash.hmacStrength;\r\n\r\n        this._reseed = null;\r\n        this.reseedInterval = null;\r\n        this.K = null;\r\n        this.V = null;\r\n\r\n        var entropy = utils.toArray(options.entropy, options.entropyEnc || 'hex');\r\n        var nonce = utils.toArray(options.nonce, options.nonceEnc || 'hex');\r\n        var pers = utils.toArray(options.pers, options.persEnc || 'hex');\r\n        assert(entropy.length >= (this.minEntropy / 8),\r\n          'Not enough entropy. Minimum is: ' + this.minEntropy + ' bits');\r\n        this._init(entropy, nonce, pers);\r\n      }\r\n      module.exports = HmacDRBG;\r\n\r\n      HmacDRBG.prototype._init = function init(entropy, nonce, pers) {\r\n        var seed = entropy.concat(nonce).concat(pers);\r\n\r\n        this.K = new Array(this.outLen / 8);\r\n        this.V = new Array(this.outLen / 8);\r\n        for (var i = 0; i < this.V.length; i++) {\r\n          this.K[i] = 0x00;\r\n          this.V[i] = 0x01;\r\n        }\r\n\r\n        this._update(seed);\r\n        this._reseed = 1;\r\n        this.reseedInterval = 0x1000000000000; // 2^48\r\n      };\r\n\r\n      HmacDRBG.prototype._hmac = function hmac() {\r\n        return new hash.hmac(this.hash, this.K);\r\n      };\r\n\r\n      HmacDRBG.prototype._update = function update(seed) {\r\n        var kmac = this._hmac()\r\n          .update(this.V)\r\n          .update([0x00]);\r\n        if (seed)\r\n          kmac = kmac.update(seed);\r\n        this.K = kmac.digest();\r\n        this.V = this._hmac().update(this.V).digest();\r\n        if (!seed)\r\n          return;\r\n\r\n        this.K = this._hmac()\r\n          .update(this.V)\r\n          .update([0x01])\r\n          .update(seed)\r\n          .digest();\r\n        this.V = this._hmac().update(this.V).digest();\r\n      };\r\n\r\n      HmacDRBG.prototype.reseed = function reseed(entropy, entropyEnc, add, addEnc) {\r\n        // Optional entropy enc\r\n        if (typeof entropyEnc !== 'string') {\r\n          addEnc = add;\r\n          add = entropyEnc;\r\n          entropyEnc = null;\r\n        }\r\n\r\n        entropy = utils.toArray(entropy, entropyEnc);\r\n        add = utils.toArray(add, addEnc);\r\n\r\n        assert(entropy.length >= (this.minEntropy / 8),\r\n          'Not enough entropy. Minimum is: ' + this.minEntropy + ' bits');\r\n\r\n        this._update(entropy.concat(add || []));\r\n        this._reseed = 1;\r\n      };\r\n\r\n      HmacDRBG.prototype.generate = function generate(len, enc, add, addEnc) {\r\n        if (this._reseed > this.reseedInterval)\r\n          throw new Error('Reseed is required');\r\n\r\n        // Optional encoding\r\n        if (typeof enc !== 'string') {\r\n          addEnc = add;\r\n          add = enc;\r\n          enc = null;\r\n        }\r\n\r\n        // Optional additional data\r\n        if (add) {\r\n          add = utils.toArray(add, addEnc || 'hex');\r\n          this._update(add);\r\n        }\r\n\r\n        var temp = [];\r\n        while (temp.length < len) {\r\n          this.V = this._hmac().update(this.V).digest();\r\n          temp = temp.concat(this.V);\r\n        }\r\n\r\n        var res = temp.slice(0, len);\r\n        this._update(add);\r\n        this._reseed++;\r\n        return utils.encode(res, enc);\r\n      };\r\n\r\n    }, {\r\n      \"hash.js\": 92,\r\n      \"minimalistic-assert\": 111,\r\n      \"minimalistic-crypto-utils\": 112\r\n    }],\r\n    105: [function (require, module, exports) {\r\n      exports.read = function (buffer, offset, isLE, mLen, nBytes) {\r\n        var e, m\r\n        var eLen = (nBytes * 8) - mLen - 1\r\n        var eMax = (1 << eLen) - 1\r\n        var eBias = eMax >> 1\r\n        var nBits = -7\r\n        var i = isLE ? (nBytes - 1) : 0\r\n        var d = isLE ? -1 : 1\r\n        var s = buffer[offset + i]\r\n\r\n        i += d\r\n\r\n        e = s & ((1 << (-nBits)) - 1)\r\n        s >>= (-nBits)\r\n        nBits += eLen\r\n        for (; nBits > 0; e = (e * 256) + buffer[offset + i], i += d, nBits -= 8) {}\r\n\r\n        m = e & ((1 << (-nBits)) - 1)\r\n        e >>= (-nBits)\r\n        nBits += mLen\r\n        for (; nBits > 0; m = (m * 256) + buffer[offset + i], i += d, nBits -= 8) {}\r\n\r\n        if (e === 0) {\r\n          e = 1 - eBias\r\n        } else if (e === eMax) {\r\n          return m ? NaN : ((s ? -1 : 1) * Infinity)\r\n        } else {\r\n          m = m + Math.pow(2, mLen)\r\n          e = e - eBias\r\n        }\r\n        return (s ? -1 : 1) * m * Math.pow(2, e - mLen)\r\n      }\r\n\r\n      exports.write = function (buffer, value, offset, isLE, mLen, nBytes) {\r\n        var e, m, c\r\n        var eLen = (nBytes * 8) - mLen - 1\r\n        var eMax = (1 << eLen) - 1\r\n        var eBias = eMax >> 1\r\n        var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)\r\n        var i = isLE ? 0 : (nBytes - 1)\r\n        var d = isLE ? 1 : -1\r\n        var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0\r\n\r\n        value = Math.abs(value)\r\n\r\n        if (isNaN(value) || value === Infinity) {\r\n          m = isNaN(value) ? 1 : 0\r\n          e = eMax\r\n        } else {\r\n          e = Math.floor(Math.log(value) / Math.LN2)\r\n          if (value * (c = Math.pow(2, -e)) < 1) {\r\n            e--\r\n            c *= 2\r\n          }\r\n          if (e + eBias >= 1) {\r\n            value += rt / c\r\n          } else {\r\n            value += rt * Math.pow(2, 1 - eBias)\r\n          }\r\n          if (value * c >= 2) {\r\n            e++\r\n            c /= 2\r\n          }\r\n\r\n          if (e + eBias >= eMax) {\r\n            m = 0\r\n            e = eMax\r\n          } else if (e + eBias >= 1) {\r\n            m = ((value * c) - 1) * Math.pow(2, mLen)\r\n            e = e + eBias\r\n          } else {\r\n            m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)\r\n            e = 0\r\n          }\r\n        }\r\n\r\n        for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}\r\n\r\n        e = (e << mLen) | m\r\n        eLen += mLen\r\n        for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}\r\n\r\n        buffer[offset + i - d] |= s * 128\r\n      }\r\n\r\n    }, {}],\r\n    106: [function (require, module, exports) {\r\n      arguments[4][18][0].apply(exports, arguments)\r\n    }, {\r\n      \"dup\": 18\r\n    }],\r\n    107: [function (require, module, exports) {\r\n      /*!\r\n       * Determine if an object is a Buffer\r\n       *\r\n       * @author   Feross Aboukhadijeh <https://feross.org>\r\n       * @license  MIT\r\n       */\r\n\r\n      // The _isBuffer check is for Safari 5-7 support, because it's missing\r\n      // Object.prototype.constructor. Remove this eventually\r\n      module.exports = function (obj) {\r\n        return obj != null && (isBuffer(obj) || isSlowBuffer(obj) || !!obj._isBuffer)\r\n      }\r\n\r\n      function isBuffer(obj) {\r\n        return !!obj.constructor && typeof obj.constructor.isBuffer === 'function' && obj.constructor.isBuffer(obj)\r\n      }\r\n\r\n      // For Node v0.10 support. Remove this eventually.\r\n      function isSlowBuffer(obj) {\r\n        return typeof obj.readFloatLE === 'function' && typeof obj.slice === 'function' && isBuffer(obj.slice(0, 0))\r\n      }\r\n\r\n    }, {}],\r\n    108: [function (require, module, exports) {\r\n      var toString = {}.toString;\r\n\r\n      module.exports = Array.isArray || function (arr) {\r\n        return toString.call(arr) == '[object Array]';\r\n      };\r\n\r\n    }, {}],\r\n    109: [function (require, module, exports) {\r\n      'use strict'\r\n      var inherits = require('inherits')\r\n      var HashBase = require('hash-base')\r\n      var Buffer = require('safe-buffer').Buffer\r\n\r\n      var ARRAY16 = new Array(16)\r\n\r\n      function MD5() {\r\n        HashBase.call(this, 64)\r\n\r\n        // state\r\n        this._a = 0x67452301\r\n        this._b = 0xefcdab89\r\n        this._c = 0x98badcfe\r\n        this._d = 0x10325476\r\n      }\r\n\r\n      inherits(MD5, HashBase)\r\n\r\n      MD5.prototype._update = function () {\r\n        var M = ARRAY16\r\n        for (var i = 0; i < 16; ++i) M[i] = this._block.readInt32LE(i * 4)\r\n\r\n        var a = this._a\r\n        var b = this._b\r\n        var c = this._c\r\n        var d = this._d\r\n\r\n        a = fnF(a, b, c, d, M[0], 0xd76aa478, 7)\r\n        d = fnF(d, a, b, c, M[1], 0xe8c7b756, 12)\r\n        c = fnF(c, d, a, b, M[2], 0x242070db, 17)\r\n        b = fnF(b, c, d, a, M[3], 0xc1bdceee, 22)\r\n        a = fnF(a, b, c, d, M[4], 0xf57c0faf, 7)\r\n        d = fnF(d, a, b, c, M[5], 0x4787c62a, 12)\r\n        c = fnF(c, d, a, b, M[6], 0xa8304613, 17)\r\n        b = fnF(b, c, d, a, M[7], 0xfd469501, 22)\r\n        a = fnF(a, b, c, d, M[8], 0x698098d8, 7)\r\n        d = fnF(d, a, b, c, M[9], 0x8b44f7af, 12)\r\n        c = fnF(c, d, a, b, M[10], 0xffff5bb1, 17)\r\n        b = fnF(b, c, d, a, M[11], 0x895cd7be, 22)\r\n        a = fnF(a, b, c, d, M[12], 0x6b901122, 7)\r\n        d = fnF(d, a, b, c, M[13], 0xfd987193, 12)\r\n        c = fnF(c, d, a, b, M[14], 0xa679438e, 17)\r\n        b = fnF(b, c, d, a, M[15], 0x49b40821, 22)\r\n\r\n        a = fnG(a, b, c, d, M[1], 0xf61e2562, 5)\r\n        d = fnG(d, a, b, c, M[6], 0xc040b340, 9)\r\n        c = fnG(c, d, a, b, M[11], 0x265e5a51, 14)\r\n        b = fnG(b, c, d, a, M[0], 0xe9b6c7aa, 20)\r\n        a = fnG(a, b, c, d, M[5], 0xd62f105d, 5)\r\n        d = fnG(d, a, b, c, M[10], 0x02441453, 9)\r\n        c = fnG(c, d, a, b, M[15], 0xd8a1e681, 14)\r\n        b = fnG(b, c, d, a, M[4], 0xe7d3fbc8, 20)\r\n        a = fnG(a, b, c, d, M[9], 0x21e1cde6, 5)\r\n        d = fnG(d, a, b, c, M[14], 0xc33707d6, 9)\r\n        c = fnG(c, d, a, b, M[3], 0xf4d50d87, 14)\r\n        b = fnG(b, c, d, a, M[8], 0x455a14ed, 20)\r\n        a = fnG(a, b, c, d, M[13], 0xa9e3e905, 5)\r\n        d = fnG(d, a, b, c, M[2], 0xfcefa3f8, 9)\r\n        c = fnG(c, d, a, b, M[7], 0x676f02d9, 14)\r\n        b = fnG(b, c, d, a, M[12], 0x8d2a4c8a, 20)\r\n\r\n        a = fnH(a, b, c, d, M[5], 0xfffa3942, 4)\r\n        d = fnH(d, a, b, c, M[8], 0x8771f681, 11)\r\n        c = fnH(c, d, a, b, M[11], 0x6d9d6122, 16)\r\n        b = fnH(b, c, d, a, M[14], 0xfde5380c, 23)\r\n        a = fnH(a, b, c, d, M[1], 0xa4beea44, 4)\r\n        d = fnH(d, a, b, c, M[4], 0x4bdecfa9, 11)\r\n        c = fnH(c, d, a, b, M[7], 0xf6bb4b60, 16)\r\n        b = fnH(b, c, d, a, M[10], 0xbebfbc70, 23)\r\n        a = fnH(a, b, c, d, M[13], 0x289b7ec6, 4)\r\n        d = fnH(d, a, b, c, M[0], 0xeaa127fa, 11)\r\n        c = fnH(c, d, a, b, M[3], 0xd4ef3085, 16)\r\n        b = fnH(b, c, d, a, M[6], 0x04881d05, 23)\r\n        a = fnH(a, b, c, d, M[9], 0xd9d4d039, 4)\r\n        d = fnH(d, a, b, c, M[12], 0xe6db99e5, 11)\r\n        c = fnH(c, d, a, b, M[15], 0x1fa27cf8, 16)\r\n        b = fnH(b, c, d, a, M[2], 0xc4ac5665, 23)\r\n\r\n        a = fnI(a, b, c, d, M[0], 0xf4292244, 6)\r\n        d = fnI(d, a, b, c, M[7], 0x432aff97, 10)\r\n        c = fnI(c, d, a, b, M[14], 0xab9423a7, 15)\r\n        b = fnI(b, c, d, a, M[5], 0xfc93a039, 21)\r\n        a = fnI(a, b, c, d, M[12], 0x655b59c3, 6)\r\n        d = fnI(d, a, b, c, M[3], 0x8f0ccc92, 10)\r\n        c = fnI(c, d, a, b, M[10], 0xffeff47d, 15)\r\n        b = fnI(b, c, d, a, M[1], 0x85845dd1, 21)\r\n        a = fnI(a, b, c, d, M[8], 0x6fa87e4f, 6)\r\n        d = fnI(d, a, b, c, M[15], 0xfe2ce6e0, 10)\r\n        c = fnI(c, d, a, b, M[6], 0xa3014314, 15)\r\n        b = fnI(b, c, d, a, M[13], 0x4e0811a1, 21)\r\n        a = fnI(a, b, c, d, M[4], 0xf7537e82, 6)\r\n        d = fnI(d, a, b, c, M[11], 0xbd3af235, 10)\r\n        c = fnI(c, d, a, b, M[2], 0x2ad7d2bb, 15)\r\n        b = fnI(b, c, d, a, M[9], 0xeb86d391, 21)\r\n\r\n        this._a = (this._a + a) | 0\r\n        this._b = (this._b + b) | 0\r\n        this._c = (this._c + c) | 0\r\n        this._d = (this._d + d) | 0\r\n      }\r\n\r\n      MD5.prototype._digest = function () {\r\n        // create padding and handle blocks\r\n        this._block[this._blockOffset++] = 0x80\r\n        if (this._blockOffset > 56) {\r\n          this._block.fill(0, this._blockOffset, 64)\r\n          this._update()\r\n          this._blockOffset = 0\r\n        }\r\n\r\n        this._block.fill(0, this._blockOffset, 56)\r\n        this._block.writeUInt32LE(this._length[0], 56)\r\n        this._block.writeUInt32LE(this._length[1], 60)\r\n        this._update()\r\n\r\n        // produce result\r\n        var buffer = Buffer.allocUnsafe(16)\r\n        buffer.writeInt32LE(this._a, 0)\r\n        buffer.writeInt32LE(this._b, 4)\r\n        buffer.writeInt32LE(this._c, 8)\r\n        buffer.writeInt32LE(this._d, 12)\r\n        return buffer\r\n      }\r\n\r\n      function rotl(x, n) {\r\n        return (x << n) | (x >>> (32 - n))\r\n      }\r\n\r\n      function fnF(a, b, c, d, m, k, s) {\r\n        return (rotl((a + ((b & c) | ((~b) & d)) + m + k) | 0, s) + b) | 0\r\n      }\r\n\r\n      function fnG(a, b, c, d, m, k, s) {\r\n        return (rotl((a + ((b & d) | (c & (~d))) + m + k) | 0, s) + b) | 0\r\n      }\r\n\r\n      function fnH(a, b, c, d, m, k, s) {\r\n        return (rotl((a + (b ^ c ^ d) + m + k) | 0, s) + b) | 0\r\n      }\r\n\r\n      function fnI(a, b, c, d, m, k, s) {\r\n        return (rotl((a + ((c ^ (b | (~d)))) + m + k) | 0, s) + b) | 0\r\n      }\r\n\r\n      module.exports = MD5\r\n\r\n    }, {\r\n      \"hash-base\": 91,\r\n      \"inherits\": 106,\r\n      \"safe-buffer\": 147\r\n    }],\r\n    110: [function (require, module, exports) {\r\n      var bn = require('bn.js');\r\n      var brorand = require('brorand');\r\n\r\n      function MillerRabin(rand) {\r\n        this.rand = rand || new brorand.Rand();\r\n      }\r\n      module.exports = MillerRabin;\r\n\r\n      MillerRabin.create = function create(rand) {\r\n        return new MillerRabin(rand);\r\n      };\r\n\r\n      MillerRabin.prototype._randbelow = function _randbelow(n) {\r\n        var len = n.bitLength();\r\n        var min_bytes = Math.ceil(len / 8);\r\n\r\n        // Generage random bytes until a number less than n is found.\r\n        // This ensures that 0..n-1 have an equal probability of being selected.\r\n        do\r\n          var a = new bn(this.rand.generate(min_bytes));\r\n        while (a.cmp(n) >= 0);\r\n\r\n        return a;\r\n      };\r\n\r\n      MillerRabin.prototype._randrange = function _randrange(start, stop) {\r\n        // Generate a random number greater than or equal to start and less than stop.\r\n        var size = stop.sub(start);\r\n        return start.add(this._randbelow(size));\r\n      };\r\n\r\n      MillerRabin.prototype.test = function test(n, k, cb) {\r\n        var len = n.bitLength();\r\n        var red = bn.mont(n);\r\n        var rone = new bn(1).toRed(red);\r\n\r\n        if (!k)\r\n          k = Math.max(1, (len / 48) | 0);\r\n\r\n        // Find d and s, (n - 1) = (2 ^ s) * d;\r\n        var n1 = n.subn(1);\r\n        for (var s = 0; !n1.testn(s); s++) {}\r\n        var d = n.shrn(s);\r\n\r\n        var rn1 = n1.toRed(red);\r\n\r\n        var prime = true;\r\n        for (; k > 0; k--) {\r\n          var a = this._randrange(new bn(2), n1);\r\n          if (cb)\r\n            cb(a);\r\n\r\n          var x = a.toRed(red).redPow(d);\r\n          if (x.cmp(rone) === 0 || x.cmp(rn1) === 0)\r\n            continue;\r\n\r\n          for (var i = 1; i < s; i++) {\r\n            x = x.redSqr();\r\n\r\n            if (x.cmp(rone) === 0)\r\n              return false;\r\n            if (x.cmp(rn1) === 0)\r\n              break;\r\n          }\r\n\r\n          if (i === s)\r\n            return false;\r\n        }\r\n\r\n        return prime;\r\n      };\r\n\r\n      MillerRabin.prototype.getDivisor = function getDivisor(n, k) {\r\n        var len = n.bitLength();\r\n        var red = bn.mont(n);\r\n        var rone = new bn(1).toRed(red);\r\n\r\n        if (!k)\r\n          k = Math.max(1, (len / 48) | 0);\r\n\r\n        // Find d and s, (n - 1) = (2 ^ s) * d;\r\n        var n1 = n.subn(1);\r\n        for (var s = 0; !n1.testn(s); s++) {}\r\n        var d = n.shrn(s);\r\n\r\n        var rn1 = n1.toRed(red);\r\n\r\n        for (; k > 0; k--) {\r\n          var a = this._randrange(new bn(2), n1);\r\n\r\n          var g = n.gcd(a);\r\n          if (g.cmpn(1) !== 0)\r\n            return g;\r\n\r\n          var x = a.toRed(red).redPow(d);\r\n          if (x.cmp(rone) === 0 || x.cmp(rn1) === 0)\r\n            continue;\r\n\r\n          for (var i = 1; i < s; i++) {\r\n            x = x.redSqr();\r\n\r\n            if (x.cmp(rone) === 0)\r\n              return x.fromRed().subn(1).gcd(n);\r\n            if (x.cmp(rn1) === 0)\r\n              break;\r\n          }\r\n\r\n          if (i === s) {\r\n            x = x.redSqr();\r\n            return x.fromRed().subn(1).gcd(n);\r\n          }\r\n        }\r\n\r\n        return false;\r\n      };\r\n\r\n    }, {\r\n      \"bn.js\": 23,\r\n      \"brorand\": 24\r\n    }],\r\n    111: [function (require, module, exports) {\r\n      module.exports = assert;\r\n\r\n      function assert(val, msg) {\r\n        if (!val)\r\n          throw new Error(msg || 'Assertion failed');\r\n      }\r\n\r\n      assert.equal = function assertEqual(l, r, msg) {\r\n        if (l != r)\r\n          throw new Error(msg || ('Assertion failed: ' + l + ' != ' + r));\r\n      };\r\n\r\n    }, {}],\r\n    112: [function (require, module, exports) {\r\n      'use strict';\r\n\r\n      var utils = exports;\r\n\r\n      function toArray(msg, enc) {\r\n        if (Array.isArray(msg))\r\n          return msg.slice();\r\n        if (!msg)\r\n          return [];\r\n        var res = [];\r\n        if (typeof msg !== 'string') {\r\n          for (var i = 0; i < msg.length; i++)\r\n            res[i] = msg[i] | 0;\r\n          return res;\r\n        }\r\n        if (enc === 'hex') {\r\n          msg = msg.replace(/[^a-z0-9]+/ig, '');\r\n          if (msg.length % 2 !== 0)\r\n            msg = '0' + msg;\r\n          for (var i = 0; i < msg.length; i += 2)\r\n            res.push(parseInt(msg[i] + msg[i + 1], 16));\r\n        } else {\r\n          for (var i = 0; i < msg.length; i++) {\r\n            var c = msg.charCodeAt(i);\r\n            var hi = c >> 8;\r\n            var lo = c & 0xff;\r\n            if (hi)\r\n              res.push(hi, lo);\r\n            else\r\n              res.push(lo);\r\n          }\r\n        }\r\n        return res;\r\n      }\r\n      utils.toArray = toArray;\r\n\r\n      function zero2(word) {\r\n        if (word.length === 1)\r\n          return '0' + word;\r\n        else\r\n          return word;\r\n      }\r\n      utils.zero2 = zero2;\r\n\r\n      function toHex(msg) {\r\n        var res = '';\r\n        for (var i = 0; i < msg.length; i++)\r\n          res += zero2(msg[i].toString(16));\r\n        return res;\r\n      }\r\n      utils.toHex = toHex;\r\n\r\n      utils.encode = function encode(arr, enc) {\r\n        if (enc === 'hex')\r\n          return toHex(arr);\r\n        else\r\n          return arr;\r\n      };\r\n\r\n    }, {}],\r\n    113: [function (require, module, exports) {\r\n      module.exports = {\r\n        \"2.16.840.1.101.3.4.1.1\": \"aes-128-ecb\",\r\n        \"2.16.840.1.101.3.4.1.2\": \"aes-128-cbc\",\r\n        \"2.16.840.1.101.3.4.1.3\": \"aes-128-ofb\",\r\n        \"2.16.840.1.101.3.4.1.4\": \"aes-128-cfb\",\r\n        \"2.16.840.1.101.3.4.1.21\": \"aes-192-ecb\",\r\n        \"2.16.840.1.101.3.4.1.22\": \"aes-192-cbc\",\r\n        \"2.16.840.1.101.3.4.1.23\": \"aes-192-ofb\",\r\n        \"2.16.840.1.101.3.4.1.24\": \"aes-192-cfb\",\r\n        \"2.16.840.1.101.3.4.1.41\": \"aes-256-ecb\",\r\n        \"2.16.840.1.101.3.4.1.42\": \"aes-256-cbc\",\r\n        \"2.16.840.1.101.3.4.1.43\": \"aes-256-ofb\",\r\n        \"2.16.840.1.101.3.4.1.44\": \"aes-256-cfb\"\r\n      }\r\n    }, {}],\r\n    114: [function (require, module, exports) {\r\n      // from https://github.com/indutny/self-signed/blob/gh-pages/lib/asn1.js\r\n      // Fedor, you are amazing.\r\n      'use strict'\r\n\r\n      var asn1 = require('asn1.js')\r\n\r\n      exports.certificate = require('./certificate')\r\n\r\n      var RSAPrivateKey = asn1.define('RSAPrivateKey', function () {\r\n        this.seq().obj(\r\n          this.key('version').int(),\r\n          this.key('modulus').int(),\r\n          this.key('publicExponent').int(),\r\n          this.key('privateExponent').int(),\r\n          this.key('prime1').int(),\r\n          this.key('prime2').int(),\r\n          this.key('exponent1').int(),\r\n          this.key('exponent2').int(),\r\n          this.key('coefficient').int()\r\n        )\r\n      })\r\n      exports.RSAPrivateKey = RSAPrivateKey\r\n\r\n      var RSAPublicKey = asn1.define('RSAPublicKey', function () {\r\n        this.seq().obj(\r\n          this.key('modulus').int(),\r\n          this.key('publicExponent').int()\r\n        )\r\n      })\r\n      exports.RSAPublicKey = RSAPublicKey\r\n\r\n      var PublicKey = asn1.define('SubjectPublicKeyInfo', function () {\r\n        this.seq().obj(\r\n          this.key('algorithm').use(AlgorithmIdentifier),\r\n          this.key('subjectPublicKey').bitstr()\r\n        )\r\n      })\r\n      exports.PublicKey = PublicKey\r\n\r\n      var AlgorithmIdentifier = asn1.define('AlgorithmIdentifier', function () {\r\n        this.seq().obj(\r\n          this.key('algorithm').objid(),\r\n          this.key('none').null_().optional(),\r\n          this.key('curve').objid().optional(),\r\n          this.key('params').seq().obj(\r\n            this.key('p').int(),\r\n            this.key('q').int(),\r\n            this.key('g').int()\r\n          ).optional()\r\n        )\r\n      })\r\n\r\n      var PrivateKeyInfo = asn1.define('PrivateKeyInfo', function () {\r\n        this.seq().obj(\r\n          this.key('version').int(),\r\n          this.key('algorithm').use(AlgorithmIdentifier),\r\n          this.key('subjectPrivateKey').octstr()\r\n        )\r\n      })\r\n      exports.PrivateKey = PrivateKeyInfo\r\n      var EncryptedPrivateKeyInfo = asn1.define('EncryptedPrivateKeyInfo', function () {\r\n        this.seq().obj(\r\n          this.key('algorithm').seq().obj(\r\n            this.key('id').objid(),\r\n            this.key('decrypt').seq().obj(\r\n              this.key('kde').seq().obj(\r\n                this.key('id').objid(),\r\n                this.key('kdeparams').seq().obj(\r\n                  this.key('salt').octstr(),\r\n                  this.key('iters').int()\r\n                )\r\n              ),\r\n              this.key('cipher').seq().obj(\r\n                this.key('algo').objid(),\r\n                this.key('iv').octstr()\r\n              )\r\n            )\r\n          ),\r\n          this.key('subjectPrivateKey').octstr()\r\n        )\r\n      })\r\n\r\n      exports.EncryptedPrivateKey = EncryptedPrivateKeyInfo\r\n\r\n      var DSAPrivateKey = asn1.define('DSAPrivateKey', function () {\r\n        this.seq().obj(\r\n          this.key('version').int(),\r\n          this.key('p').int(),\r\n          this.key('q').int(),\r\n          this.key('g').int(),\r\n          this.key('pub_key').int(),\r\n          this.key('priv_key').int()\r\n        )\r\n      })\r\n      exports.DSAPrivateKey = DSAPrivateKey\r\n\r\n      exports.DSAparam = asn1.define('DSAparam', function () {\r\n        this.int()\r\n      })\r\n\r\n      var ECPrivateKey = asn1.define('ECPrivateKey', function () {\r\n        this.seq().obj(\r\n          this.key('version').int(),\r\n          this.key('privateKey').octstr(),\r\n          this.key('parameters').optional().explicit(0).use(ECParameters),\r\n          this.key('publicKey').optional().explicit(1).bitstr()\r\n        )\r\n      })\r\n      exports.ECPrivateKey = ECPrivateKey\r\n\r\n      var ECParameters = asn1.define('ECParameters', function () {\r\n        this.choice({\r\n          namedCurve: this.objid()\r\n        })\r\n      })\r\n\r\n      exports.signature = asn1.define('signature', function () {\r\n        this.seq().obj(\r\n          this.key('r').int(),\r\n          this.key('s').int()\r\n        )\r\n      })\r\n\r\n    }, {\r\n      \"./certificate\": 115,\r\n      \"asn1.js\": 3\r\n    }],\r\n    115: [function (require, module, exports) {\r\n      // from https://github.com/Rantanen/node-dtls/blob/25a7dc861bda38cfeac93a723500eea4f0ac2e86/Certificate.js\r\n      // thanks to @Rantanen\r\n\r\n      'use strict'\r\n\r\n      var asn = require('asn1.js')\r\n\r\n      var Time = asn.define('Time', function () {\r\n        this.choice({\r\n          utcTime: this.utctime(),\r\n          generalTime: this.gentime()\r\n        })\r\n      })\r\n\r\n      var AttributeTypeValue = asn.define('AttributeTypeValue', function () {\r\n        this.seq().obj(\r\n          this.key('type').objid(),\r\n          this.key('value').any()\r\n        )\r\n      })\r\n\r\n      var AlgorithmIdentifier = asn.define('AlgorithmIdentifier', function () {\r\n        this.seq().obj(\r\n          this.key('algorithm').objid(),\r\n          this.key('parameters').optional()\r\n        )\r\n      })\r\n\r\n      var SubjectPublicKeyInfo = asn.define('SubjectPublicKeyInfo', function () {\r\n        this.seq().obj(\r\n          this.key('algorithm').use(AlgorithmIdentifier),\r\n          this.key('subjectPublicKey').bitstr()\r\n        )\r\n      })\r\n\r\n      var RelativeDistinguishedName = asn.define('RelativeDistinguishedName', function () {\r\n        this.setof(AttributeTypeValue)\r\n      })\r\n\r\n      var RDNSequence = asn.define('RDNSequence', function () {\r\n        this.seqof(RelativeDistinguishedName)\r\n      })\r\n\r\n      var Name = asn.define('Name', function () {\r\n        this.choice({\r\n          rdnSequence: this.use(RDNSequence)\r\n        })\r\n      })\r\n\r\n      var Validity = asn.define('Validity', function () {\r\n        this.seq().obj(\r\n          this.key('notBefore').use(Time),\r\n          this.key('notAfter').use(Time)\r\n        )\r\n      })\r\n\r\n      var Extension = asn.define('Extension', function () {\r\n        this.seq().obj(\r\n          this.key('extnID').objid(),\r\n          this.key('critical').bool().def(false),\r\n          this.key('extnValue').octstr()\r\n        )\r\n      })\r\n\r\n      var TBSCertificate = asn.define('TBSCertificate', function () {\r\n        this.seq().obj(\r\n          this.key('version').explicit(0).int(),\r\n          this.key('serialNumber').int(),\r\n          this.key('signature').use(AlgorithmIdentifier),\r\n          this.key('issuer').use(Name),\r\n          this.key('validity').use(Validity),\r\n          this.key('subject').use(Name),\r\n          this.key('subjectPublicKeyInfo').use(SubjectPublicKeyInfo),\r\n          this.key('issuerUniqueID').implicit(1).bitstr().optional(),\r\n          this.key('subjectUniqueID').implicit(2).bitstr().optional(),\r\n          this.key('extensions').explicit(3).seqof(Extension).optional()\r\n        )\r\n      })\r\n\r\n      var X509Certificate = asn.define('X509Certificate', function () {\r\n        this.seq().obj(\r\n          this.key('tbsCertificate').use(TBSCertificate),\r\n          this.key('signatureAlgorithm').use(AlgorithmIdentifier),\r\n          this.key('signatureValue').bitstr()\r\n        )\r\n      })\r\n\r\n      module.exports = X509Certificate\r\n\r\n    }, {\r\n      \"asn1.js\": 3\r\n    }],\r\n    116: [function (require, module, exports) {\r\n      (function (Buffer) {\r\n        // adapted from https://github.com/apatil/pemstrip\r\n        var findProc = /Proc-Type: 4,ENCRYPTED[\\n\\r]+DEK-Info: AES-((?:128)|(?:192)|(?:256))-CBC,([0-9A-H]+)[\\n\\r]+([0-9A-z\\n\\r\\+\\/\\=]+)[\\n\\r]+/m\r\n        var startRegex = /^-----BEGIN ((?:.* KEY)|CERTIFICATE)-----/m\r\n        var fullRegex = /^-----BEGIN ((?:.* KEY)|CERTIFICATE)-----([0-9A-z\\n\\r\\+\\/\\=]+)-----END \\1-----$/m\r\n        var evp = require('evp_bytestokey')\r\n        var ciphers = require('browserify-aes')\r\n        module.exports = function (okey, password) {\r\n          var key = okey.toString()\r\n          var match = key.match(findProc)\r\n          var decrypted\r\n          if (!match) {\r\n            var match2 = key.match(fullRegex)\r\n            decrypted = new Buffer(match2[2].replace(/[\\r\\n]/g, ''), 'base64')\r\n          } else {\r\n            var suite = 'aes' + match[1]\r\n            var iv = new Buffer(match[2], 'hex')\r\n            var cipherText = new Buffer(match[3].replace(/[\\r\\n]/g, ''), 'base64')\r\n            var cipherKey = evp(password, iv.slice(0, 8), parseInt(match[1], 10)).key\r\n            var out = []\r\n            var cipher = ciphers.createDecipheriv(suite, cipherKey, iv)\r\n            out.push(cipher.update(cipherText))\r\n            out.push(cipher.final())\r\n            decrypted = Buffer.concat(out)\r\n          }\r\n          var tag = key.match(startRegex)[1]\r\n          return {\r\n            tag: tag,\r\n            data: decrypted\r\n          }\r\n        }\r\n\r\n      }).call(this, require(\"buffer\").Buffer)\r\n    }, {\r\n      \"browserify-aes\": 28,\r\n      \"buffer\": 54,\r\n      \"evp_bytestokey\": 90\r\n    }],\r\n    117: [function (require, module, exports) {\r\n      (function (Buffer) {\r\n        var asn1 = require('./asn1')\r\n        var aesid = require('./aesid.json')\r\n        var fixProc = require('./fixProc')\r\n        var ciphers = require('browserify-aes')\r\n        var compat = require('pbkdf2')\r\n        module.exports = parseKeys\r\n\r\n        function parseKeys(buffer) {\r\n          var password\r\n          if (typeof buffer === 'object' && !Buffer.isBuffer(buffer)) {\r\n            password = buffer.passphrase\r\n            buffer = buffer.key\r\n          }\r\n          if (typeof buffer === 'string') {\r\n            buffer = new Buffer(buffer)\r\n          }\r\n\r\n          var stripped = fixProc(buffer, password)\r\n\r\n          var type = stripped.tag\r\n          var data = stripped.data\r\n          var subtype, ndata\r\n          switch (type) {\r\n            case 'CERTIFICATE':\r\n              ndata = asn1.certificate.decode(data, 'der').tbsCertificate.subjectPublicKeyInfo\r\n              // falls through\r\n            case 'PUBLIC KEY':\r\n              if (!ndata) {\r\n                ndata = asn1.PublicKey.decode(data, 'der')\r\n              }\r\n              subtype = ndata.algorithm.algorithm.join('.')\r\n              switch (subtype) {\r\n                case '1.2.840.113549.1.1.1':\r\n                  return asn1.RSAPublicKey.decode(ndata.subjectPublicKey.data, 'der')\r\n                case '1.2.840.10045.2.1':\r\n                  ndata.subjectPrivateKey = ndata.subjectPublicKey\r\n                  return {\r\n                    type: 'ec',\r\n                      data: ndata\r\n                  }\r\n                  case '1.2.840.10040.4.1':\r\n                    ndata.algorithm.params.pub_key = asn1.DSAparam.decode(ndata.subjectPublicKey.data, 'der')\r\n                    return {\r\n                      type: 'dsa',\r\n                        data: ndata.algorithm.params\r\n                    }\r\n                    default:\r\n                      throw new Error('unknown key id ' + subtype)\r\n              }\r\n              throw new Error('unknown key type ' + type)\r\n            case 'ENCRYPTED PRIVATE KEY':\r\n              data = asn1.EncryptedPrivateKey.decode(data, 'der')\r\n              data = decrypt(data, password)\r\n              // falls through\r\n            case 'PRIVATE KEY':\r\n              ndata = asn1.PrivateKey.decode(data, 'der')\r\n              subtype = ndata.algorithm.algorithm.join('.')\r\n              switch (subtype) {\r\n                case '1.2.840.113549.1.1.1':\r\n                  return asn1.RSAPrivateKey.decode(ndata.subjectPrivateKey, 'der')\r\n                case '1.2.840.10045.2.1':\r\n                  return {\r\n                    curve: ndata.algorithm.curve,\r\n                      privateKey: asn1.ECPrivateKey.decode(ndata.subjectPrivateKey, 'der').privateKey\r\n                  }\r\n                  case '1.2.840.10040.4.1':\r\n                    ndata.algorithm.params.priv_key = asn1.DSAparam.decode(ndata.subjectPrivateKey, 'der')\r\n                    return {\r\n                      type: 'dsa',\r\n                        params: ndata.algorithm.params\r\n                    }\r\n                    default:\r\n                      throw new Error('unknown key id ' + subtype)\r\n              }\r\n              throw new Error('unknown key type ' + type)\r\n            case 'RSA PUBLIC KEY':\r\n              return asn1.RSAPublicKey.decode(data, 'der')\r\n            case 'RSA PRIVATE KEY':\r\n              return asn1.RSAPrivateKey.decode(data, 'der')\r\n            case 'DSA PRIVATE KEY':\r\n              return {\r\n                type: 'dsa',\r\n                  params: asn1.DSAPrivateKey.decode(data, 'der')\r\n              }\r\n              case 'EC PRIVATE KEY':\r\n                data = asn1.ECPrivateKey.decode(data, 'der')\r\n                return {\r\n                  curve: data.parameters.value,\r\n                    privateKey: data.privateKey\r\n                }\r\n                default:\r\n                  throw new Error('unknown key type ' + type)\r\n          }\r\n        }\r\n        parseKeys.signature = asn1.signature\r\n\r\n        function decrypt(data, password) {\r\n          var salt = data.algorithm.decrypt.kde.kdeparams.salt\r\n          var iters = parseInt(data.algorithm.decrypt.kde.kdeparams.iters.toString(), 10)\r\n          var algo = aesid[data.algorithm.decrypt.cipher.algo.join('.')]\r\n          var iv = data.algorithm.decrypt.cipher.iv\r\n          var cipherText = data.subjectPrivateKey\r\n          var keylen = parseInt(algo.split('-')[1], 10) / 8\r\n          var key = compat.pbkdf2Sync(password, salt, iters, keylen)\r\n          var cipher = ciphers.createDecipheriv(algo, key, iv)\r\n          var out = []\r\n          out.push(cipher.update(cipherText))\r\n          out.push(cipher.final())\r\n          return Buffer.concat(out)\r\n        }\r\n\r\n      }).call(this, require(\"buffer\").Buffer)\r\n    }, {\r\n      \"./aesid.json\": 113,\r\n      \"./asn1\": 114,\r\n      \"./fixProc\": 116,\r\n      \"browserify-aes\": 28,\r\n      \"buffer\": 54,\r\n      \"pbkdf2\": 118\r\n    }],\r\n    118: [function (require, module, exports) {\r\n      exports.pbkdf2 = require('./lib/async')\r\n      exports.pbkdf2Sync = require('./lib/sync')\r\n\r\n    }, {\r\n      \"./lib/async\": 119,\r\n      \"./lib/sync\": 122\r\n    }],\r\n    119: [function (require, module, exports) {\r\n      (function (process, global) {\r\n        var checkParameters = require('./precondition')\r\n        var defaultEncoding = require('./default-encoding')\r\n        var sync = require('./sync')\r\n        var Buffer = require('safe-buffer').Buffer\r\n\r\n        var ZERO_BUF\r\n        var subtle = global.crypto && global.crypto.subtle\r\n        var toBrowser = {\r\n          'sha': 'SHA-1',\r\n          'sha-1': 'SHA-1',\r\n          'sha1': 'SHA-1',\r\n          'sha256': 'SHA-256',\r\n          'sha-256': 'SHA-256',\r\n          'sha384': 'SHA-384',\r\n          'sha-384': 'SHA-384',\r\n          'sha-512': 'SHA-512',\r\n          'sha512': 'SHA-512'\r\n        }\r\n        var checks = []\r\n\r\n        function checkNative(algo) {\r\n          if (global.process && !global.process.browser) {\r\n            return Promise.resolve(false)\r\n          }\r\n          if (!subtle || !subtle.importKey || !subtle.deriveBits) {\r\n            return Promise.resolve(false)\r\n          }\r\n          if (checks[algo] !== undefined) {\r\n            return checks[algo]\r\n          }\r\n          ZERO_BUF = ZERO_BUF || Buffer.alloc(8)\r\n          var prom = browserPbkdf2(ZERO_BUF, ZERO_BUF, 10, 128, algo)\r\n            .then(function () {\r\n              return true\r\n            }).catch(function () {\r\n              return false\r\n            })\r\n          checks[algo] = prom\r\n          return prom\r\n        }\r\n\r\n        function browserPbkdf2(password, salt, iterations, length, algo) {\r\n          return subtle.importKey(\r\n            'raw', password, {\r\n              name: 'PBKDF2'\r\n            }, false, ['deriveBits']\r\n          ).then(function (key) {\r\n            return subtle.deriveBits({\r\n              name: 'PBKDF2',\r\n              salt: salt,\r\n              iterations: iterations,\r\n              hash: {\r\n                name: algo\r\n              }\r\n            }, key, length << 3)\r\n          }).then(function (res) {\r\n            return Buffer.from(res)\r\n          })\r\n        }\r\n\r\n        function resolvePromise(promise, callback) {\r\n          promise.then(function (out) {\r\n            process.nextTick(function () {\r\n              callback(null, out)\r\n            })\r\n          }, function (e) {\r\n            process.nextTick(function () {\r\n              callback(e)\r\n            })\r\n          })\r\n        }\r\n        module.exports = function (password, salt, iterations, keylen, digest, callback) {\r\n          if (typeof digest === 'function') {\r\n            callback = digest\r\n            digest = undefined\r\n          }\r\n\r\n          digest = digest || 'sha1'\r\n          var algo = toBrowser[digest.toLowerCase()]\r\n\r\n          if (!algo || typeof global.Promise !== 'function') {\r\n            return process.nextTick(function () {\r\n              var out\r\n              try {\r\n                out = sync(password, salt, iterations, keylen, digest)\r\n              } catch (e) {\r\n                return callback(e)\r\n              }\r\n              callback(null, out)\r\n            })\r\n          }\r\n\r\n          checkParameters(password, salt, iterations, keylen)\r\n          if (typeof callback !== 'function') throw new Error('No callback provided to pbkdf2')\r\n          if (!Buffer.isBuffer(password)) password = Buffer.from(password, defaultEncoding)\r\n          if (!Buffer.isBuffer(salt)) salt = Buffer.from(salt, defaultEncoding)\r\n\r\n          resolvePromise(checkNative(algo).then(function (resp) {\r\n            if (resp) return browserPbkdf2(password, salt, iterations, keylen, algo)\r\n\r\n            return sync(password, salt, iterations, keylen, digest)\r\n          }), callback)\r\n        }\r\n\r\n      }).call(this, require('_process'), typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {})\r\n    }, {\r\n      \"./default-encoding\": 120,\r\n      \"./precondition\": 121,\r\n      \"./sync\": 122,\r\n      \"_process\": 124,\r\n      \"safe-buffer\": 147\r\n    }],\r\n    120: [function (require, module, exports) {\r\n      (function (process) {\r\n        var defaultEncoding\r\n        /* istanbul ignore next */\r\n        if (process.browser) {\r\n          defaultEncoding = 'utf-8'\r\n        } else {\r\n          var pVersionMajor = parseInt(process.version.split('.')[0].slice(1), 10)\r\n\r\n          defaultEncoding = pVersionMajor >= 6 ? 'utf-8' : 'binary'\r\n        }\r\n        module.exports = defaultEncoding\r\n\r\n      }).call(this, require('_process'))\r\n    }, {\r\n      \"_process\": 124\r\n    }],\r\n    121: [function (require, module, exports) {\r\n      (function (Buffer) {\r\n        var MAX_ALLOC = Math.pow(2, 30) - 1 // default in iojs\r\n\r\n        function checkBuffer(buf, name) {\r\n          if (typeof buf !== 'string' && !Buffer.isBuffer(buf)) {\r\n            throw new TypeError(name + ' must be a buffer or string')\r\n          }\r\n        }\r\n\r\n        module.exports = function (password, salt, iterations, keylen) {\r\n          checkBuffer(password, 'Password')\r\n          checkBuffer(salt, 'Salt')\r\n\r\n          if (typeof iterations !== 'number') {\r\n            throw new TypeError('Iterations not a number')\r\n          }\r\n\r\n          if (iterations < 0) {\r\n            throw new TypeError('Bad iterations')\r\n          }\r\n\r\n          if (typeof keylen !== 'number') {\r\n            throw new TypeError('Key length not a number')\r\n          }\r\n\r\n          if (keylen < 0 || keylen > MAX_ALLOC || keylen !== keylen) {\r\n            /* eslint no-self-compare: 0 */\r\n            throw new TypeError('Bad key length')\r\n          }\r\n        }\r\n\r\n      }).call(this, {\r\n        \"isBuffer\": require(\"../../is-buffer/index.js\")\r\n      })\r\n    }, {\r\n      \"../../is-buffer/index.js\": 107\r\n    }],\r\n    122: [function (require, module, exports) {\r\n      var md5 = require('create-hash/md5')\r\n      var RIPEMD160 = require('ripemd160')\r\n      var sha = require('sha.js')\r\n\r\n      var checkParameters = require('./precondition')\r\n      var defaultEncoding = require('./default-encoding')\r\n      var Buffer = require('safe-buffer').Buffer\r\n      var ZEROS = Buffer.alloc(128)\r\n      var sizes = {\r\n        md5: 16,\r\n        sha1: 20,\r\n        sha224: 28,\r\n        sha256: 32,\r\n        sha384: 48,\r\n        sha512: 64,\r\n        rmd160: 20,\r\n        ripemd160: 20\r\n      }\r\n\r\n      function Hmac(alg, key, saltLen) {\r\n        var hash = getDigest(alg)\r\n        var blocksize = (alg === 'sha512' || alg === 'sha384') ? 128 : 64\r\n\r\n        if (key.length > blocksize) {\r\n          key = hash(key)\r\n        } else if (key.length < blocksize) {\r\n          key = Buffer.concat([key, ZEROS], blocksize)\r\n        }\r\n\r\n        var ipad = Buffer.allocUnsafe(blocksize + sizes[alg])\r\n        var opad = Buffer.allocUnsafe(blocksize + sizes[alg])\r\n        for (var i = 0; i < blocksize; i++) {\r\n          ipad[i] = key[i] ^ 0x36\r\n          opad[i] = key[i] ^ 0x5C\r\n        }\r\n\r\n        var ipad1 = Buffer.allocUnsafe(blocksize + saltLen + 4)\r\n        ipad.copy(ipad1, 0, 0, blocksize)\r\n        this.ipad1 = ipad1\r\n        this.ipad2 = ipad\r\n        this.opad = opad\r\n        this.alg = alg\r\n        this.blocksize = blocksize\r\n        this.hash = hash\r\n        this.size = sizes[alg]\r\n      }\r\n\r\n      Hmac.prototype.run = function (data, ipad) {\r\n        data.copy(ipad, this.blocksize)\r\n        var h = this.hash(ipad)\r\n        h.copy(this.opad, this.blocksize)\r\n        return this.hash(this.opad)\r\n      }\r\n\r\n      function getDigest(alg) {\r\n        function shaFunc(data) {\r\n          return sha(alg).update(data).digest()\r\n        }\r\n\r\n        function rmd160Func(data) {\r\n          return new RIPEMD160().update(data).digest()\r\n        }\r\n\r\n        if (alg === 'rmd160' || alg === 'ripemd160') return rmd160Func\r\n        if (alg === 'md5') return md5\r\n        return shaFunc\r\n      }\r\n\r\n      function pbkdf2(password, salt, iterations, keylen, digest) {\r\n        checkParameters(password, salt, iterations, keylen)\r\n\r\n        if (!Buffer.isBuffer(password)) password = Buffer.from(password, defaultEncoding)\r\n        if (!Buffer.isBuffer(salt)) salt = Buffer.from(salt, defaultEncoding)\r\n\r\n        digest = digest || 'sha1'\r\n\r\n        var hmac = new Hmac(digest, password, salt.length)\r\n\r\n        var DK = Buffer.allocUnsafe(keylen)\r\n        var block1 = Buffer.allocUnsafe(salt.length + 4)\r\n        salt.copy(block1, 0, 0, salt.length)\r\n\r\n        var destPos = 0\r\n        var hLen = sizes[digest]\r\n        var l = Math.ceil(keylen / hLen)\r\n\r\n        for (var i = 1; i <= l; i++) {\r\n          block1.writeUInt32BE(i, salt.length)\r\n\r\n          var T = hmac.run(block1, hmac.ipad1)\r\n          var U = T\r\n\r\n          for (var j = 1; j < iterations; j++) {\r\n            U = hmac.run(U, hmac.ipad2)\r\n            for (var k = 0; k < hLen; k++) T[k] ^= U[k]\r\n          }\r\n\r\n          T.copy(DK, destPos)\r\n          destPos += hLen\r\n        }\r\n\r\n        return DK\r\n      }\r\n\r\n      module.exports = pbkdf2\r\n\r\n    }, {\r\n      \"./default-encoding\": 120,\r\n      \"./precondition\": 121,\r\n      \"create-hash/md5\": 59,\r\n      \"ripemd160\": 146,\r\n      \"safe-buffer\": 147,\r\n      \"sha.js\": 149\r\n    }],\r\n    123: [function (require, module, exports) {\r\n      (function (process) {\r\n        'use strict';\r\n\r\n        if (!process.version ||\r\n          process.version.indexOf('v0.') === 0 ||\r\n          process.version.indexOf('v1.') === 0 && process.version.indexOf('v1.8.') !== 0) {\r\n          module.exports = {\r\n            nextTick: nextTick\r\n          };\r\n        } else {\r\n          module.exports = process\r\n        }\r\n\r\n        function nextTick(fn, arg1, arg2, arg3) {\r\n          if (typeof fn !== 'function') {\r\n            throw new TypeError('\"callback\" argument must be a function');\r\n          }\r\n          var len = arguments.length;\r\n          var args, i;\r\n          switch (len) {\r\n            case 0:\r\n            case 1:\r\n              return process.nextTick(fn);\r\n            case 2:\r\n              return process.nextTick(function afterTickOne() {\r\n                fn.call(null, arg1);\r\n              });\r\n            case 3:\r\n              return process.nextTick(function afterTickTwo() {\r\n                fn.call(null, arg1, arg2);\r\n              });\r\n            case 4:\r\n              return process.nextTick(function afterTickThree() {\r\n                fn.call(null, arg1, arg2, arg3);\r\n              });\r\n            default:\r\n              args = new Array(len - 1);\r\n              i = 0;\r\n              while (i < args.length) {\r\n                args[i++] = arguments[i];\r\n              }\r\n              return process.nextTick(function afterTick() {\r\n                fn.apply(null, args);\r\n              });\r\n          }\r\n        }\r\n\r\n\r\n      }).call(this, require('_process'))\r\n    }, {\r\n      \"_process\": 124\r\n    }],\r\n    124: [function (require, module, exports) {\r\n      // shim for using process in browser\r\n      var process = module.exports = {};\r\n\r\n      // cached from whatever global is present so that test runners that stub it\r\n      // don't break things.  But we need to wrap it in a try catch in case it is\r\n      // wrapped in strict mode code which doesn't define any globals.  It's inside a\r\n      // function because try/catches deoptimize in certain engines.\r\n\r\n      var cachedSetTimeout;\r\n      var cachedClearTimeout;\r\n\r\n      function defaultSetTimout() {\r\n        throw new Error('setTimeout has not been defined');\r\n      }\r\n\r\n      function defaultClearTimeout() {\r\n        throw new Error('clearTimeout has not been defined');\r\n      }\r\n      (function () {\r\n        try {\r\n          if (typeof setTimeout === 'function') {\r\n            cachedSetTimeout = setTimeout;\r\n          } else {\r\n            cachedSetTimeout = defaultSetTimout;\r\n          }\r\n        } catch (e) {\r\n          cachedSetTimeout = defaultSetTimout;\r\n        }\r\n        try {\r\n          if (typeof clearTimeout === 'function') {\r\n            cachedClearTimeout = clearTimeout;\r\n          } else {\r\n            cachedClearTimeout = defaultClearTimeout;\r\n          }\r\n        } catch (e) {\r\n          cachedClearTimeout = defaultClearTimeout;\r\n        }\r\n      }())\r\n\r\n      function runTimeout(fun) {\r\n        if (cachedSetTimeout === setTimeout) {\r\n          //normal enviroments in sane situations\r\n          return setTimeout(fun, 0);\r\n        }\r\n        // if setTimeout wasn't available but was latter defined\r\n        if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {\r\n          cachedSetTimeout = setTimeout;\r\n          return setTimeout(fun, 0);\r\n        }\r\n        try {\r\n          // when when somebody has screwed with setTimeout but no I.E. maddness\r\n          return cachedSetTimeout(fun, 0);\r\n        } catch (e) {\r\n          try {\r\n            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally\r\n            return cachedSetTimeout.call(null, fun, 0);\r\n          } catch (e) {\r\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error\r\n            return cachedSetTimeout.call(this, fun, 0);\r\n          }\r\n        }\r\n\r\n\r\n      }\r\n\r\n      function runClearTimeout(marker) {\r\n        if (cachedClearTimeout === clearTimeout) {\r\n          //normal enviroments in sane situations\r\n          return clearTimeout(marker);\r\n        }\r\n        // if clearTimeout wasn't available but was latter defined\r\n        if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {\r\n          cachedClearTimeout = clearTimeout;\r\n          return clearTimeout(marker);\r\n        }\r\n        try {\r\n          // when when somebody has screwed with setTimeout but no I.E. maddness\r\n          return cachedClearTimeout(marker);\r\n        } catch (e) {\r\n          try {\r\n            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally\r\n            return cachedClearTimeout.call(null, marker);\r\n          } catch (e) {\r\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.\r\n            // Some versions of I.E. have different rules for clearTimeout vs setTimeout\r\n            return cachedClearTimeout.call(this, marker);\r\n          }\r\n        }\r\n\r\n\r\n\r\n      }\r\n      var queue = [];\r\n      var draining = false;\r\n      var currentQueue;\r\n      var queueIndex = -1;\r\n\r\n      function cleanUpNextTick() {\r\n        if (!draining || !currentQueue) {\r\n          return;\r\n        }\r\n        draining = false;\r\n        if (currentQueue.length) {\r\n          queue = currentQueue.concat(queue);\r\n        } else {\r\n          queueIndex = -1;\r\n        }\r\n        if (queue.length) {\r\n          drainQueue();\r\n        }\r\n      }\r\n\r\n      function drainQueue() {\r\n        if (draining) {\r\n          return;\r\n        }\r\n        var timeout = runTimeout(cleanUpNextTick);\r\n        draining = true;\r\n\r\n        var len = queue.length;\r\n        while (len) {\r\n          currentQueue = queue;\r\n          queue = [];\r\n          while (++queueIndex < len) {\r\n            if (currentQueue) {\r\n              currentQueue[queueIndex].run();\r\n            }\r\n          }\r\n          queueIndex = -1;\r\n          len = queue.length;\r\n        }\r\n        currentQueue = null;\r\n        draining = false;\r\n        runClearTimeout(timeout);\r\n      }\r\n\r\n      process.nextTick = function (fun) {\r\n        var args = new Array(arguments.length - 1);\r\n        if (arguments.length > 1) {\r\n          for (var i = 1; i < arguments.length; i++) {\r\n            args[i - 1] = arguments[i];\r\n          }\r\n        }\r\n        queue.push(new Item(fun, args));\r\n        if (queue.length === 1 && !draining) {\r\n          runTimeout(drainQueue);\r\n        }\r\n      };\r\n\r\n      // v8 likes predictible objects\r\n      function Item(fun, array) {\r\n        this.fun = fun;\r\n        this.array = array;\r\n      }\r\n      Item.prototype.run = function () {\r\n        this.fun.apply(null, this.array);\r\n      };\r\n      process.title = 'browser';\r\n      process.browser = true;\r\n      process.env = {};\r\n      process.argv = [];\r\n      process.version = ''; // empty string to avoid regexp issues\r\n      process.versions = {};\r\n\r\n      function noop() {}\r\n\r\n      process.on = noop;\r\n      process.addListener = noop;\r\n      process.once = noop;\r\n      process.off = noop;\r\n      process.removeListener = noop;\r\n      process.removeAllListeners = noop;\r\n      process.emit = noop;\r\n      process.prependListener = noop;\r\n      process.prependOnceListener = noop;\r\n\r\n      process.listeners = function (name) {\r\n        return []\r\n      }\r\n\r\n      process.binding = function (name) {\r\n        throw new Error('process.binding is not supported');\r\n      };\r\n\r\n      process.cwd = function () {\r\n        return '/'\r\n      };\r\n      process.chdir = function (dir) {\r\n        throw new Error('process.chdir is not supported');\r\n      };\r\n      process.umask = function () {\r\n        return 0;\r\n      };\r\n\r\n    }, {}],\r\n    125: [function (require, module, exports) {\r\n      exports.publicEncrypt = require('./publicEncrypt')\r\n      exports.privateDecrypt = require('./privateDecrypt')\r\n\r\n      exports.privateEncrypt = function privateEncrypt(key, buf) {\r\n        return exports.publicEncrypt(key, buf, true)\r\n      }\r\n\r\n      exports.publicDecrypt = function publicDecrypt(key, buf) {\r\n        return exports.privateDecrypt(key, buf, true)\r\n      }\r\n\r\n    }, {\r\n      \"./privateDecrypt\": 127,\r\n      \"./publicEncrypt\": 128\r\n    }],\r\n    126: [function (require, module, exports) {\r\n      var createHash = require('create-hash')\r\n      var Buffer = require('safe-buffer').Buffer\r\n\r\n      module.exports = function (seed, len) {\r\n        var t = Buffer.alloc(0)\r\n        var i = 0\r\n        var c\r\n        while (t.length < len) {\r\n          c = i2ops(i++)\r\n          t = Buffer.concat([t, createHash('sha1').update(seed).update(c).digest()])\r\n        }\r\n        return t.slice(0, len)\r\n      }\r\n\r\n      function i2ops(c) {\r\n        var out = Buffer.allocUnsafe(4)\r\n        out.writeUInt32BE(c, 0)\r\n        return out\r\n      }\r\n\r\n    }, {\r\n      \"create-hash\": 58,\r\n      \"safe-buffer\": 147\r\n    }],\r\n    127: [function (require, module, exports) {\r\n      var parseKeys = require('parse-asn1')\r\n      var mgf = require('./mgf')\r\n      var xor = require('./xor')\r\n      var BN = require('bn.js')\r\n      var crt = require('browserify-rsa')\r\n      var createHash = require('create-hash')\r\n      var withPublic = require('./withPublic')\r\n      var Buffer = require('safe-buffer').Buffer\r\n\r\n      module.exports = function privateDecrypt(privateKey, enc, reverse) {\r\n        var padding\r\n        if (privateKey.padding) {\r\n          padding = privateKey.padding\r\n        } else if (reverse) {\r\n          padding = 1\r\n        } else {\r\n          padding = 4\r\n        }\r\n\r\n        var key = parseKeys(privateKey)\r\n        var k = key.modulus.byteLength()\r\n        if (enc.length > k || new BN(enc).cmp(key.modulus) >= 0) {\r\n          throw new Error('decryption error')\r\n        }\r\n        var msg\r\n        if (reverse) {\r\n          msg = withPublic(new BN(enc), key)\r\n        } else {\r\n          msg = crt(enc, key)\r\n        }\r\n        var zBuffer = Buffer.alloc(k - msg.length)\r\n        msg = Buffer.concat([zBuffer, msg], k)\r\n        if (padding === 4) {\r\n          return oaep(key, msg)\r\n        } else if (padding === 1) {\r\n          return pkcs1(key, msg, reverse)\r\n        } else if (padding === 3) {\r\n          return msg\r\n        } else {\r\n          throw new Error('unknown padding')\r\n        }\r\n      }\r\n\r\n      function oaep(key, msg) {\r\n        var k = key.modulus.byteLength()\r\n        var iHash = createHash('sha1').update(Buffer.alloc(0)).digest()\r\n        var hLen = iHash.length\r\n        if (msg[0] !== 0) {\r\n          throw new Error('decryption error')\r\n        }\r\n        var maskedSeed = msg.slice(1, hLen + 1)\r\n        var maskedDb = msg.slice(hLen + 1)\r\n        var seed = xor(maskedSeed, mgf(maskedDb, hLen))\r\n        var db = xor(maskedDb, mgf(seed, k - hLen - 1))\r\n        if (compare(iHash, db.slice(0, hLen))) {\r\n          throw new Error('decryption error')\r\n        }\r\n        var i = hLen\r\n        while (db[i] === 0) {\r\n          i++\r\n        }\r\n        if (db[i++] !== 1) {\r\n          throw new Error('decryption error')\r\n        }\r\n        return db.slice(i)\r\n      }\r\n\r\n      function pkcs1(key, msg, reverse) {\r\n        var p1 = msg.slice(0, 2)\r\n        var i = 2\r\n        var status = 0\r\n        while (msg[i++] !== 0) {\r\n          if (i >= msg.length) {\r\n            status++\r\n            break\r\n          }\r\n        }\r\n        var ps = msg.slice(2, i - 1)\r\n\r\n        if ((p1.toString('hex') !== '0002' && !reverse) || (p1.toString('hex') !== '0001' && reverse)) {\r\n          status++\r\n        }\r\n        if (ps.length < 8) {\r\n          status++\r\n        }\r\n        if (status) {\r\n          throw new Error('decryption error')\r\n        }\r\n        return msg.slice(i)\r\n      }\r\n\r\n      function compare(a, b) {\r\n        a = Buffer.from(a)\r\n        b = Buffer.from(b)\r\n        var dif = 0\r\n        var len = a.length\r\n        if (a.length !== b.length) {\r\n          dif++\r\n          len = Math.min(a.length, b.length)\r\n        }\r\n        var i = -1\r\n        while (++i < len) {\r\n          dif += (a[i] ^ b[i])\r\n        }\r\n        return dif\r\n      }\r\n\r\n    }, {\r\n      \"./mgf\": 126,\r\n      \"./withPublic\": 129,\r\n      \"./xor\": 130,\r\n      \"bn.js\": 23,\r\n      \"browserify-rsa\": 46,\r\n      \"create-hash\": 58,\r\n      \"parse-asn1\": 117,\r\n      \"safe-buffer\": 147\r\n    }],\r\n    128: [function (require, module, exports) {\r\n      var parseKeys = require('parse-asn1')\r\n      var randomBytes = require('randombytes')\r\n      var createHash = require('create-hash')\r\n      var mgf = require('./mgf')\r\n      var xor = require('./xor')\r\n      var BN = require('bn.js')\r\n      var withPublic = require('./withPublic')\r\n      var crt = require('browserify-rsa')\r\n      var Buffer = require('safe-buffer').Buffer\r\n\r\n      module.exports = function publicEncrypt(publicKey, msg, reverse) {\r\n        var padding\r\n        if (publicKey.padding) {\r\n          padding = publicKey.padding\r\n        } else if (reverse) {\r\n          padding = 1\r\n        } else {\r\n          padding = 4\r\n        }\r\n        var key = parseKeys(publicKey)\r\n        var paddedMsg\r\n        if (padding === 4) {\r\n          paddedMsg = oaep(key, msg)\r\n        } else if (padding === 1) {\r\n          paddedMsg = pkcs1(key, msg, reverse)\r\n        } else if (padding === 3) {\r\n          paddedMsg = new BN(msg)\r\n          if (paddedMsg.cmp(key.modulus) >= 0) {\r\n            throw new Error('data too long for modulus')\r\n          }\r\n        } else {\r\n          throw new Error('unknown padding')\r\n        }\r\n        if (reverse) {\r\n          return crt(paddedMsg, key)\r\n        } else {\r\n          return withPublic(paddedMsg, key)\r\n        }\r\n      }\r\n\r\n      function oaep(key, msg) {\r\n        var k = key.modulus.byteLength()\r\n        var mLen = msg.length\r\n        var iHash = createHash('sha1').update(Buffer.alloc(0)).digest()\r\n        var hLen = iHash.length\r\n        var hLen2 = 2 * hLen\r\n        if (mLen > k - hLen2 - 2) {\r\n          throw new Error('message too long')\r\n        }\r\n        var ps = Buffer.alloc(k - mLen - hLen2 - 2)\r\n        var dblen = k - hLen - 1\r\n        var seed = randomBytes(hLen)\r\n        var maskedDb = xor(Buffer.concat([iHash, ps, Buffer.alloc(1, 1), msg], dblen), mgf(seed, dblen))\r\n        var maskedSeed = xor(seed, mgf(maskedDb, hLen))\r\n        return new BN(Buffer.concat([Buffer.alloc(1), maskedSeed, maskedDb], k))\r\n      }\r\n\r\n      function pkcs1(key, msg, reverse) {\r\n        var mLen = msg.length\r\n        var k = key.modulus.byteLength()\r\n        if (mLen > k - 11) {\r\n          throw new Error('message too long')\r\n        }\r\n        var ps\r\n        if (reverse) {\r\n          ps = Buffer.alloc(k - mLen - 3, 0xff)\r\n        } else {\r\n          ps = nonZero(k - mLen - 3)\r\n        }\r\n        return new BN(Buffer.concat([Buffer.from([0, reverse ? 1 : 2]), ps, Buffer.alloc(1), msg], k))\r\n      }\r\n\r\n      function nonZero(len) {\r\n        var out = Buffer.allocUnsafe(len)\r\n        var i = 0\r\n        var cache = randomBytes(len * 2)\r\n        var cur = 0\r\n        var num\r\n        while (i < len) {\r\n          if (cur === cache.length) {\r\n            cache = randomBytes(len * 2)\r\n            cur = 0\r\n          }\r\n          num = cache[cur++]\r\n          if (num) {\r\n            out[i++] = num\r\n          }\r\n        }\r\n        return out\r\n      }\r\n\r\n    }, {\r\n      \"./mgf\": 126,\r\n      \"./withPublic\": 129,\r\n      \"./xor\": 130,\r\n      \"bn.js\": 23,\r\n      \"browserify-rsa\": 46,\r\n      \"create-hash\": 58,\r\n      \"parse-asn1\": 117,\r\n      \"randombytes\": 131,\r\n      \"safe-buffer\": 147\r\n    }],\r\n    129: [function (require, module, exports) {\r\n      var BN = require('bn.js')\r\n      var Buffer = require('safe-buffer').Buffer\r\n\r\n      function withPublic(paddedMsg, key) {\r\n        return Buffer.from(paddedMsg\r\n          .toRed(BN.mont(key.modulus))\r\n          .redPow(new BN(key.publicExponent))\r\n          .fromRed()\r\n          .toArray())\r\n      }\r\n\r\n      module.exports = withPublic\r\n\r\n    }, {\r\n      \"bn.js\": 23,\r\n      \"safe-buffer\": 147\r\n    }],\r\n    130: [function (require, module, exports) {\r\n      module.exports = function xor(a, b) {\r\n        var len = a.length\r\n        var i = -1\r\n        while (++i < len) {\r\n          a[i] ^= b[i]\r\n        }\r\n        return a\r\n      }\r\n\r\n    }, {}],\r\n    131: [function (require, module, exports) {\r\n      (function (process, global) {\r\n        'use strict'\r\n\r\n        function oldBrowser() {\r\n          throw new Error('Secure random number generation is not supported by this browser.\\nUse Chrome, Firefox or Internet Explorer 11')\r\n        }\r\n\r\n        var Buffer = require('safe-buffer').Buffer\r\n        var crypto = global.crypto || global.msCrypto\r\n\r\n        if (crypto && crypto.getRandomValues) {\r\n          module.exports = randomBytes\r\n        } else {\r\n          module.exports = oldBrowser\r\n        }\r\n\r\n        function randomBytes(size, cb) {\r\n          // phantomjs needs to throw\r\n          if (size > 65536) throw new Error('requested too many random bytes')\r\n          // in case browserify  isn't using the Uint8Array version\r\n          var rawBytes = new global.Uint8Array(size)\r\n\r\n          // This will not work in older browsers.\r\n          // See https://developer.mozilla.org/en-US/docs/Web/API/window.crypto.getRandomValues\r\n          if (size > 0) { // getRandomValues fails on IE if size == 0\r\n            crypto.getRandomValues(rawBytes)\r\n          }\r\n\r\n          // XXX: phantomjs doesn't like a buffer being passed here\r\n          var bytes = Buffer.from(rawBytes.buffer)\r\n\r\n          if (typeof cb === 'function') {\r\n            return process.nextTick(function () {\r\n              cb(null, bytes)\r\n            })\r\n          }\r\n\r\n          return bytes\r\n        }\r\n\r\n      }).call(this, require('_process'), typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {})\r\n    }, {\r\n      \"_process\": 124,\r\n      \"safe-buffer\": 147\r\n    }],\r\n    132: [function (require, module, exports) {\r\n      (function (process, global) {\r\n        'use strict'\r\n\r\n        function oldBrowser() {\r\n          throw new Error('secure random number generation not supported by this browser\\nuse chrome, FireFox or Internet Explorer 11')\r\n        }\r\n        var safeBuffer = require('safe-buffer')\r\n        var randombytes = require('randombytes')\r\n        var Buffer = safeBuffer.Buffer\r\n        var kBufferMaxLength = safeBuffer.kMaxLength\r\n        var crypto = global.crypto || global.msCrypto\r\n        var kMaxUint32 = Math.pow(2, 32) - 1\r\n\r\n        function assertOffset(offset, length) {\r\n          if (typeof offset !== 'number' || offset !== offset) { // eslint-disable-line no-self-compare\r\n            throw new TypeError('offset must be a number')\r\n          }\r\n\r\n          if (offset > kMaxUint32 || offset < 0) {\r\n            throw new TypeError('offset must be a uint32')\r\n          }\r\n\r\n          if (offset > kBufferMaxLength || offset > length) {\r\n            throw new RangeError('offset out of range')\r\n          }\r\n        }\r\n\r\n        function assertSize(size, offset, length) {\r\n          if (typeof size !== 'number' || size !== size) { // eslint-disable-line no-self-compare\r\n            throw new TypeError('size must be a number')\r\n          }\r\n\r\n          if (size > kMaxUint32 || size < 0) {\r\n            throw new TypeError('size must be a uint32')\r\n          }\r\n\r\n          if (size + offset > length || size > kBufferMaxLength) {\r\n            throw new RangeError('buffer too small')\r\n          }\r\n        }\r\n        if ((crypto && crypto.getRandomValues) || !process.browser) {\r\n          exports.randomFill = randomFill\r\n          exports.randomFillSync = randomFillSync\r\n        } else {\r\n          exports.randomFill = oldBrowser\r\n          exports.randomFillSync = oldBrowser\r\n        }\r\n\r\n        function randomFill(buf, offset, size, cb) {\r\n          if (!Buffer.isBuffer(buf) && !(buf instanceof global.Uint8Array)) {\r\n            throw new TypeError('\"buf\" argument must be a Buffer or Uint8Array')\r\n          }\r\n\r\n          if (typeof offset === 'function') {\r\n            cb = offset\r\n            offset = 0\r\n            size = buf.length\r\n          } else if (typeof size === 'function') {\r\n            cb = size\r\n            size = buf.length - offset\r\n          } else if (typeof cb !== 'function') {\r\n            throw new TypeError('\"cb\" argument must be a function')\r\n          }\r\n          assertOffset(offset, buf.length)\r\n          assertSize(size, offset, buf.length)\r\n          return actualFill(buf, offset, size, cb)\r\n        }\r\n\r\n        function actualFill(buf, offset, size, cb) {\r\n          if (process.browser) {\r\n            var ourBuf = buf.buffer\r\n            var uint = new Uint8Array(ourBuf, offset, size)\r\n            crypto.getRandomValues(uint)\r\n            if (cb) {\r\n              process.nextTick(function () {\r\n                cb(null, buf)\r\n              })\r\n              return\r\n            }\r\n            return buf\r\n          }\r\n          if (cb) {\r\n            randombytes(size, function (err, bytes) {\r\n              if (err) {\r\n                return cb(err)\r\n              }\r\n              bytes.copy(buf, offset)\r\n              cb(null, buf)\r\n            })\r\n            return\r\n          }\r\n          var bytes = randombytes(size)\r\n          bytes.copy(buf, offset)\r\n          return buf\r\n        }\r\n\r\n        function randomFillSync(buf, offset, size) {\r\n          if (typeof offset === 'undefined') {\r\n            offset = 0\r\n          }\r\n          if (!Buffer.isBuffer(buf) && !(buf instanceof global.Uint8Array)) {\r\n            throw new TypeError('\"buf\" argument must be a Buffer or Uint8Array')\r\n          }\r\n\r\n          assertOffset(offset, buf.length)\r\n\r\n          if (size === undefined) size = buf.length - offset\r\n\r\n          assertSize(size, offset, buf.length)\r\n\r\n          return actualFill(buf, offset, size)\r\n        }\r\n\r\n      }).call(this, require('_process'), typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {})\r\n    }, {\r\n      \"_process\": 124,\r\n      \"randombytes\": 131,\r\n      \"safe-buffer\": 147\r\n    }],\r\n    133: [function (require, module, exports) {\r\n      module.exports = require('./lib/_stream_duplex.js');\r\n\r\n    }, {\r\n      \"./lib/_stream_duplex.js\": 134\r\n    }],\r\n    134: [function (require, module, exports) {\r\n      // Copyright Joyent, Inc. and other Node contributors.\r\n      //\r\n      // Permission is hereby granted, free of charge, to any person obtaining a\r\n      // copy of this software and associated documentation files (the\r\n      // \"Software\"), to deal in the Software without restriction, including\r\n      // without limitation the rights to use, copy, modify, merge, publish,\r\n      // distribute, sublicense, and/or sell copies of the Software, and to permit\r\n      // persons to whom the Software is furnished to do so, subject to the\r\n      // following conditions:\r\n      //\r\n      // The above copyright notice and this permission notice shall be included\r\n      // in all copies or substantial portions of the Software.\r\n      //\r\n      // THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\r\n      // OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\r\n      // MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\r\n      // NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\r\n      // DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\r\n      // OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\r\n      // USE OR OTHER DEALINGS IN THE SOFTWARE.\r\n\r\n      // a duplex stream is just a stream that is both readable and writable.\r\n      // Since JS doesn't have multiple prototypal inheritance, this class\r\n      // prototypally inherits from Readable, and then parasitically from\r\n      // Writable.\r\n\r\n      'use strict';\r\n\r\n      /*<replacement>*/\r\n\r\n      var pna = require('process-nextick-args');\r\n      /*</replacement>*/\r\n\r\n      /*<replacement>*/\r\n      var objectKeys = Object.keys || function (obj) {\r\n        var keys = [];\r\n        for (var key in obj) {\r\n          keys.push(key);\r\n        }\r\n        return keys;\r\n      };\r\n      /*</replacement>*/\r\n\r\n      module.exports = Duplex;\r\n\r\n      /*<replacement>*/\r\n      var util = require('core-util-is');\r\n      util.inherits = require('inherits');\r\n      /*</replacement>*/\r\n\r\n      var Readable = require('./_stream_readable');\r\n      var Writable = require('./_stream_writable');\r\n\r\n      util.inherits(Duplex, Readable);\r\n\r\n      {\r\n        // avoid scope creep, the keys array can then be collected\r\n        var keys = objectKeys(Writable.prototype);\r\n        for (var v = 0; v < keys.length; v++) {\r\n          var method = keys[v];\r\n          if (!Duplex.prototype[method]) Duplex.prototype[method] = Writable.prototype[method];\r\n        }\r\n      }\r\n\r\n      function Duplex(options) {\r\n        if (!(this instanceof Duplex)) return new Duplex(options);\r\n\r\n        Readable.call(this, options);\r\n        Writable.call(this, options);\r\n\r\n        if (options && options.readable === false) this.readable = false;\r\n\r\n        if (options && options.writable === false) this.writable = false;\r\n\r\n        this.allowHalfOpen = true;\r\n        if (options && options.allowHalfOpen === false) this.allowHalfOpen = false;\r\n\r\n        this.once('end', onend);\r\n      }\r\n\r\n      Object.defineProperty(Duplex.prototype, 'writableHighWaterMark', {\r\n        // making it explicit this property is not enumerable\r\n        // because otherwise some prototype manipulation in\r\n        // userland will fail\r\n        enumerable: false,\r\n        get: function () {\r\n          return this._writableState.highWaterMark;\r\n        }\r\n      });\r\n\r\n      // the no-half-open enforcer\r\n      function onend() {\r\n        // if we allow half-open state, or if the writable side ended,\r\n        // then we're ok.\r\n        if (this.allowHalfOpen || this._writableState.ended) return;\r\n\r\n        // no more data can be written.\r\n        // But allow more writes to happen in this tick.\r\n        pna.nextTick(onEndNT, this);\r\n      }\r\n\r\n      function onEndNT(self) {\r\n        self.end();\r\n      }\r\n\r\n      Object.defineProperty(Duplex.prototype, 'destroyed', {\r\n        get: function () {\r\n          if (this._readableState === undefined || this._writableState === undefined) {\r\n            return false;\r\n          }\r\n          return this._readableState.destroyed && this._writableState.destroyed;\r\n        },\r\n        set: function (value) {\r\n          // we ignore the value if the stream\r\n          // has not been initialized yet\r\n          if (this._readableState === undefined || this._writableState === undefined) {\r\n            return;\r\n          }\r\n\r\n          // backward compatibility, the user is explicitly\r\n          // managing destroyed\r\n          this._readableState.destroyed = value;\r\n          this._writableState.destroyed = value;\r\n        }\r\n      });\r\n\r\n      Duplex.prototype._destroy = function (err, cb) {\r\n        this.push(null);\r\n        this.end();\r\n\r\n        pna.nextTick(cb, err);\r\n      };\r\n    }, {\r\n      \"./_stream_readable\": 136,\r\n      \"./_stream_writable\": 138,\r\n      \"core-util-is\": 56,\r\n      \"inherits\": 106,\r\n      \"process-nextick-args\": 123\r\n    }],\r\n    135: [function (require, module, exports) {\r\n      // Copyright Joyent, Inc. and other Node contributors.\r\n      //\r\n      // Permission is hereby granted, free of charge, to any person obtaining a\r\n      // copy of this software and associated documentation files (the\r\n      // \"Software\"), to deal in the Software without restriction, including\r\n      // without limitation the rights to use, copy, modify, merge, publish,\r\n      // distribute, sublicense, and/or sell copies of the Software, and to permit\r\n      // persons to whom the Software is furnished to do so, subject to the\r\n      // following conditions:\r\n      //\r\n      // The above copyright notice and this permission notice shall be included\r\n      // in all copies or substantial portions of the Software.\r\n      //\r\n      // THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\r\n      // OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\r\n      // MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\r\n      // NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\r\n      // DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\r\n      // OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\r\n      // USE OR OTHER DEALINGS IN THE SOFTWARE.\r\n\r\n      // a passthrough stream.\r\n      // basically just the most minimal sort of Transform stream.\r\n      // Every written chunk gets output as-is.\r\n\r\n      'use strict';\r\n\r\n      module.exports = PassThrough;\r\n\r\n      var Transform = require('./_stream_transform');\r\n\r\n      /*<replacement>*/\r\n      var util = require('core-util-is');\r\n      util.inherits = require('inherits');\r\n      /*</replacement>*/\r\n\r\n      util.inherits(PassThrough, Transform);\r\n\r\n      function PassThrough(options) {\r\n        if (!(this instanceof PassThrough)) return new PassThrough(options);\r\n\r\n        Transform.call(this, options);\r\n      }\r\n\r\n      PassThrough.prototype._transform = function (chunk, encoding, cb) {\r\n        cb(null, chunk);\r\n      };\r\n    }, {\r\n      \"./_stream_transform\": 137,\r\n      \"core-util-is\": 56,\r\n      \"inherits\": 106\r\n    }],\r\n    136: [function (require, module, exports) {\r\n      (function (process, global) {\r\n        // Copyright Joyent, Inc. and other Node contributors.\r\n        //\r\n        // Permission is hereby granted, free of charge, to any person obtaining a\r\n        // copy of this software and associated documentation files (the\r\n        // \"Software\"), to deal in the Software without restriction, including\r\n        // without limitation the rights to use, copy, modify, merge, publish,\r\n        // distribute, sublicense, and/or sell copies of the Software, and to permit\r\n        // persons to whom the Software is furnished to do so, subject to the\r\n        // following conditions:\r\n        //\r\n        // The above copyright notice and this permission notice shall be included\r\n        // in all copies or substantial portions of the Software.\r\n        //\r\n        // THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\r\n        // OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\r\n        // MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\r\n        // NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\r\n        // DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\r\n        // OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\r\n        // USE OR OTHER DEALINGS IN THE SOFTWARE.\r\n\r\n        'use strict';\r\n\r\n        /*<replacement>*/\r\n\r\n        var pna = require('process-nextick-args');\r\n        /*</replacement>*/\r\n\r\n        module.exports = Readable;\r\n\r\n        /*<replacement>*/\r\n        var isArray = require('isarray');\r\n        /*</replacement>*/\r\n\r\n        /*<replacement>*/\r\n        var Duplex;\r\n        /*</replacement>*/\r\n\r\n        Readable.ReadableState = ReadableState;\r\n\r\n        /*<replacement>*/\r\n        var EE = require('events').EventEmitter;\r\n\r\n        var EElistenerCount = function (emitter, type) {\r\n          return emitter.listeners(type).length;\r\n        };\r\n        /*</replacement>*/\r\n\r\n        /*<replacement>*/\r\n        var Stream = require('./internal/streams/stream');\r\n        /*</replacement>*/\r\n\r\n        /*<replacement>*/\r\n\r\n        var Buffer = require('safe-buffer').Buffer;\r\n        var OurUint8Array = global.Uint8Array || function () {};\r\n\r\n        function _uint8ArrayToBuffer(chunk) {\r\n          return Buffer.from(chunk);\r\n        }\r\n\r\n        function _isUint8Array(obj) {\r\n          return Buffer.isBuffer(obj) || obj instanceof OurUint8Array;\r\n        }\r\n\r\n        /*</replacement>*/\r\n\r\n        /*<replacement>*/\r\n        var util = require('core-util-is');\r\n        util.inherits = require('inherits');\r\n        /*</replacement>*/\r\n\r\n        /*<replacement>*/\r\n        var debugUtil = require('util');\r\n        var debug = void 0;\r\n        if (debugUtil && debugUtil.debuglog) {\r\n          debug = debugUtil.debuglog('stream');\r\n        } else {\r\n          debug = function () {};\r\n        }\r\n        /*</replacement>*/\r\n\r\n        var BufferList = require('./internal/streams/BufferList');\r\n        var destroyImpl = require('./internal/streams/destroy');\r\n        var StringDecoder;\r\n\r\n        util.inherits(Readable, Stream);\r\n\r\n        var kProxyEvents = ['error', 'close', 'destroy', 'pause', 'resume'];\r\n\r\n        function prependListener(emitter, event, fn) {\r\n          // Sadly this is not cacheable as some libraries bundle their own\r\n          // event emitter implementation with them.\r\n          if (typeof emitter.prependListener === 'function') return emitter.prependListener(event, fn);\r\n\r\n          // This is a hack to make sure that our error handler is attached before any\r\n          // userland ones.  NEVER DO THIS. This is here only because this code needs\r\n          // to continue to work with older versions of Node.js that do not include\r\n          // the prependListener() method. The goal is to eventually remove this hack.\r\n          if (!emitter._events || !emitter._events[event]) emitter.on(event, fn);\r\n          else if (isArray(emitter._events[event])) emitter._events[event].unshift(fn);\r\n          else emitter._events[event] = [fn, emitter._events[event]];\r\n        }\r\n\r\n        function ReadableState(options, stream) {\r\n          Duplex = Duplex || require('./_stream_duplex');\r\n\r\n          options = options || {};\r\n\r\n          // Duplex streams are both readable and writable, but share\r\n          // the same options object.\r\n          // However, some cases require setting options to different\r\n          // values for the readable and the writable sides of the duplex stream.\r\n          // These options can be provided separately as readableXXX and writableXXX.\r\n          var isDuplex = stream instanceof Duplex;\r\n\r\n          // object stream flag. Used to make read(n) ignore n and to\r\n          // make all the buffer merging and length checks go away\r\n          this.objectMode = !!options.objectMode;\r\n\r\n          if (isDuplex) this.objectMode = this.objectMode || !!options.readableObjectMode;\r\n\r\n          // the point at which it stops calling _read() to fill the buffer\r\n          // Note: 0 is a valid value, means \"don't call _read preemptively ever\"\r\n          var hwm = options.highWaterMark;\r\n          var readableHwm = options.readableHighWaterMark;\r\n          var defaultHwm = this.objectMode ? 16 : 16 * 1024;\r\n\r\n          if (hwm || hwm === 0) this.highWaterMark = hwm;\r\n          else if (isDuplex && (readableHwm || readableHwm === 0)) this.highWaterMark = readableHwm;\r\n          else this.highWaterMark = defaultHwm;\r\n\r\n          // cast to ints.\r\n          this.highWaterMark = Math.floor(this.highWaterMark);\r\n\r\n          // A linked list is used to store data chunks instead of an array because the\r\n          // linked list can remove elements from the beginning faster than\r\n          // array.shift()\r\n          this.buffer = new BufferList();\r\n          this.length = 0;\r\n          this.pipes = null;\r\n          this.pipesCount = 0;\r\n          this.flowing = null;\r\n          this.ended = false;\r\n          this.endEmitted = false;\r\n          this.reading = false;\r\n\r\n          // a flag to be able to tell if the event 'readable'/'data' is emitted\r\n          // immediately, or on a later tick.  We set this to true at first, because\r\n          // any actions that shouldn't happen until \"later\" should generally also\r\n          // not happen before the first read call.\r\n          this.sync = true;\r\n\r\n          // whenever we return null, then we set a flag to say\r\n          // that we're awaiting a 'readable' event emission.\r\n          this.needReadable = false;\r\n          this.emittedReadable = false;\r\n          this.readableListening = false;\r\n          this.resumeScheduled = false;\r\n\r\n          // has it been destroyed\r\n          this.destroyed = false;\r\n\r\n          // Crypto is kind of old and crusty.  Historically, its default string\r\n          // encoding is 'binary' so we have to make this configurable.\r\n          // Everything else in the universe uses 'utf8', though.\r\n          this.defaultEncoding = options.defaultEncoding || 'utf8';\r\n\r\n          // the number of writers that are awaiting a drain event in .pipe()s\r\n          this.awaitDrain = 0;\r\n\r\n          // if true, a maybeReadMore has been scheduled\r\n          this.readingMore = false;\r\n\r\n          this.decoder = null;\r\n          this.encoding = null;\r\n          if (options.encoding) {\r\n            if (!StringDecoder) StringDecoder = require('string_decoder/').StringDecoder;\r\n            this.decoder = new StringDecoder(options.encoding);\r\n            this.encoding = options.encoding;\r\n          }\r\n        }\r\n\r\n        function Readable(options) {\r\n          Duplex = Duplex || require('./_stream_duplex');\r\n\r\n          if (!(this instanceof Readable)) return new Readable(options);\r\n\r\n          this._readableState = new ReadableState(options, this);\r\n\r\n          // legacy\r\n          this.readable = true;\r\n\r\n          if (options) {\r\n            if (typeof options.read === 'function') this._read = options.read;\r\n\r\n            if (typeof options.destroy === 'function') this._destroy = options.destroy;\r\n          }\r\n\r\n          Stream.call(this);\r\n        }\r\n\r\n        Object.defineProperty(Readable.prototype, 'destroyed', {\r\n          get: function () {\r\n            if (this._readableState === undefined) {\r\n              return false;\r\n            }\r\n            return this._readableState.destroyed;\r\n          },\r\n          set: function (value) {\r\n            // we ignore the value if the stream\r\n            // has not been initialized yet\r\n            if (!this._readableState) {\r\n              return;\r\n            }\r\n\r\n            // backward compatibility, the user is explicitly\r\n            // managing destroyed\r\n            this._readableState.destroyed = value;\r\n          }\r\n        });\r\n\r\n        Readable.prototype.destroy = destroyImpl.destroy;\r\n        Readable.prototype._undestroy = destroyImpl.undestroy;\r\n        Readable.prototype._destroy = function (err, cb) {\r\n          this.push(null);\r\n          cb(err);\r\n        };\r\n\r\n        // Manually shove something into the read() buffer.\r\n        // This returns true if the highWaterMark has not been hit yet,\r\n        // similar to how Writable.write() returns true if you should\r\n        // write() some more.\r\n        Readable.prototype.push = function (chunk, encoding) {\r\n          var state = this._readableState;\r\n          var skipChunkCheck;\r\n\r\n          if (!state.objectMode) {\r\n            if (typeof chunk === 'string') {\r\n              encoding = encoding || state.defaultEncoding;\r\n              if (encoding !== state.encoding) {\r\n                chunk = Buffer.from(chunk, encoding);\r\n                encoding = '';\r\n              }\r\n              skipChunkCheck = true;\r\n            }\r\n          } else {\r\n            skipChunkCheck = true;\r\n          }\r\n\r\n          return readableAddChunk(this, chunk, encoding, false, skipChunkCheck);\r\n        };\r\n\r\n        // Unshift should *always* be something directly out of read()\r\n        Readable.prototype.unshift = function (chunk) {\r\n          return readableAddChunk(this, chunk, null, true, false);\r\n        };\r\n\r\n        function readableAddChunk(stream, chunk, encoding, addToFront, skipChunkCheck) {\r\n          var state = stream._readableState;\r\n          if (chunk === null) {\r\n            state.reading = false;\r\n            onEofChunk(stream, state);\r\n          } else {\r\n            var er;\r\n            if (!skipChunkCheck) er = chunkInvalid(state, chunk);\r\n            if (er) {\r\n              stream.emit('error', er);\r\n            } else if (state.objectMode || chunk && chunk.length > 0) {\r\n              if (typeof chunk !== 'string' && !state.objectMode && Object.getPrototypeOf(chunk) !== Buffer.prototype) {\r\n                chunk = _uint8ArrayToBuffer(chunk);\r\n              }\r\n\r\n              if (addToFront) {\r\n                if (state.endEmitted) stream.emit('error', new Error('stream.unshift() after end event'));\r\n                else addChunk(stream, state, chunk, true);\r\n              } else if (state.ended) {\r\n                stream.emit('error', new Error('stream.push() after EOF'));\r\n              } else {\r\n                state.reading = false;\r\n                if (state.decoder && !encoding) {\r\n                  chunk = state.decoder.write(chunk);\r\n                  if (state.objectMode || chunk.length !== 0) addChunk(stream, state, chunk, false);\r\n                  else maybeReadMore(stream, state);\r\n                } else {\r\n                  addChunk(stream, state, chunk, false);\r\n                }\r\n              }\r\n            } else if (!addToFront) {\r\n              state.reading = false;\r\n            }\r\n          }\r\n\r\n          return needMoreData(state);\r\n        }\r\n\r\n        function addChunk(stream, state, chunk, addToFront) {\r\n          if (state.flowing && state.length === 0 && !state.sync) {\r\n            stream.emit('data', chunk);\r\n            stream.read(0);\r\n          } else {\r\n            // update the buffer info.\r\n            state.length += state.objectMode ? 1 : chunk.length;\r\n            if (addToFront) state.buffer.unshift(chunk);\r\n            else state.buffer.push(chunk);\r\n\r\n            if (state.needReadable) emitReadable(stream);\r\n          }\r\n          maybeReadMore(stream, state);\r\n        }\r\n\r\n        function chunkInvalid(state, chunk) {\r\n          var er;\r\n          if (!_isUint8Array(chunk) && typeof chunk !== 'string' && chunk !== undefined && !state.objectMode) {\r\n            er = new TypeError('Invalid non-string/buffer chunk');\r\n          }\r\n          return er;\r\n        }\r\n\r\n        // if it's past the high water mark, we can push in some more.\r\n        // Also, if we have no data yet, we can stand some\r\n        // more bytes.  This is to work around cases where hwm=0,\r\n        // such as the repl.  Also, if the push() triggered a\r\n        // readable event, and the user called read(largeNumber) such that\r\n        // needReadable was set, then we ought to push more, so that another\r\n        // 'readable' event will be triggered.\r\n        function needMoreData(state) {\r\n          return !state.ended && (state.needReadable || state.length < state.highWaterMark || state.length === 0);\r\n        }\r\n\r\n        Readable.prototype.isPaused = function () {\r\n          return this._readableState.flowing === false;\r\n        };\r\n\r\n        // backwards compatibility.\r\n        Readable.prototype.setEncoding = function (enc) {\r\n          if (!StringDecoder) StringDecoder = require('string_decoder/').StringDecoder;\r\n          this._readableState.decoder = new StringDecoder(enc);\r\n          this._readableState.encoding = enc;\r\n          return this;\r\n        };\r\n\r\n        // Don't raise the hwm > 8MB\r\n        var MAX_HWM = 0x800000;\r\n\r\n        function computeNewHighWaterMark(n) {\r\n          if (n >= MAX_HWM) {\r\n            n = MAX_HWM;\r\n          } else {\r\n            // Get the next highest power of 2 to prevent increasing hwm excessively in\r\n            // tiny amounts\r\n            n--;\r\n            n |= n >>> 1;\r\n            n |= n >>> 2;\r\n            n |= n >>> 4;\r\n            n |= n >>> 8;\r\n            n |= n >>> 16;\r\n            n++;\r\n          }\r\n          return n;\r\n        }\r\n\r\n        // This function is designed to be inlinable, so please take care when making\r\n        // changes to the function body.\r\n        function howMuchToRead(n, state) {\r\n          if (n <= 0 || state.length === 0 && state.ended) return 0;\r\n          if (state.objectMode) return 1;\r\n          if (n !== n) {\r\n            // Only flow one buffer at a time\r\n            if (state.flowing && state.length) return state.buffer.head.data.length;\r\n            else return state.length;\r\n          }\r\n          // If we're asking for more than the current hwm, then raise the hwm.\r\n          if (n > state.highWaterMark) state.highWaterMark = computeNewHighWaterMark(n);\r\n          if (n <= state.length) return n;\r\n          // Don't have enough\r\n          if (!state.ended) {\r\n            state.needReadable = true;\r\n            return 0;\r\n          }\r\n          return state.length;\r\n        }\r\n\r\n        // you can override either this method, or the async _read(n) below.\r\n        Readable.prototype.read = function (n) {\r\n          debug('read', n);\r\n          n = parseInt(n, 10);\r\n          var state = this._readableState;\r\n          var nOrig = n;\r\n\r\n          if (n !== 0) state.emittedReadable = false;\r\n\r\n          // if we're doing read(0) to trigger a readable event, but we\r\n          // already have a bunch of data in the buffer, then just trigger\r\n          // the 'readable' event and move on.\r\n          if (n === 0 && state.needReadable && (state.length >= state.highWaterMark || state.ended)) {\r\n            debug('read: emitReadable', state.length, state.ended);\r\n            if (state.length === 0 && state.ended) endReadable(this);\r\n            else emitReadable(this);\r\n            return null;\r\n          }\r\n\r\n          n = howMuchToRead(n, state);\r\n\r\n          // if we've ended, and we're now clear, then finish it up.\r\n          if (n === 0 && state.ended) {\r\n            if (state.length === 0) endReadable(this);\r\n            return null;\r\n          }\r\n\r\n          // All the actual chunk generation logic needs to be\r\n          // *below* the call to _read.  The reason is that in certain\r\n          // synthetic stream cases, such as passthrough streams, _read\r\n          // may be a completely synchronous operation which may change\r\n          // the state of the read buffer, providing enough data when\r\n          // before there was *not* enough.\r\n          //\r\n          // So, the steps are:\r\n          // 1. Figure out what the state of things will be after we do\r\n          // a read from the buffer.\r\n          //\r\n          // 2. If that resulting state will trigger a _read, then call _read.\r\n          // Note that this may be asynchronous, or synchronous.  Yes, it is\r\n          // deeply ugly to write APIs this way, but that still doesn't mean\r\n          // that the Readable class should behave improperly, as streams are\r\n          // designed to be sync/async agnostic.\r\n          // Take note if the _read call is sync or async (ie, if the read call\r\n          // has returned yet), so that we know whether or not it's safe to emit\r\n          // 'readable' etc.\r\n          //\r\n          // 3. Actually pull the requested chunks out of the buffer and return.\r\n\r\n          // if we need a readable event, then we need to do some reading.\r\n          var doRead = state.needReadable;\r\n          debug('need readable', doRead);\r\n\r\n          // if we currently have less than the highWaterMark, then also read some\r\n          if (state.length === 0 || state.length - n < state.highWaterMark) {\r\n            doRead = true;\r\n            debug('length less than watermark', doRead);\r\n          }\r\n\r\n          // however, if we've ended, then there's no point, and if we're already\r\n          // reading, then it's unnecessary.\r\n          if (state.ended || state.reading) {\r\n            doRead = false;\r\n            debug('reading or ended', doRead);\r\n          } else if (doRead) {\r\n            debug('do read');\r\n            state.reading = true;\r\n            state.sync = true;\r\n            // if the length is currently zero, then we *need* a readable event.\r\n            if (state.length === 0) state.needReadable = true;\r\n            // call internal read method\r\n            this._read(state.highWaterMark);\r\n            state.sync = false;\r\n            // If _read pushed data synchronously, then `reading` will be false,\r\n            // and we need to re-evaluate how much data we can return to the user.\r\n            if (!state.reading) n = howMuchToRead(nOrig, state);\r\n          }\r\n\r\n          var ret;\r\n          if (n > 0) ret = fromList(n, state);\r\n          else ret = null;\r\n\r\n          if (ret === null) {\r\n            state.needReadable = true;\r\n            n = 0;\r\n          } else {\r\n            state.length -= n;\r\n          }\r\n\r\n          if (state.length === 0) {\r\n            // If we have nothing in the buffer, then we want to know\r\n            // as soon as we *do* get something into the buffer.\r\n            if (!state.ended) state.needReadable = true;\r\n\r\n            // If we tried to read() past the EOF, then emit end on the next tick.\r\n            if (nOrig !== n && state.ended) endReadable(this);\r\n          }\r\n\r\n          if (ret !== null) this.emit('data', ret);\r\n\r\n          return ret;\r\n        };\r\n\r\n        function onEofChunk(stream, state) {\r\n          if (state.ended) return;\r\n          if (state.decoder) {\r\n            var chunk = state.decoder.end();\r\n            if (chunk && chunk.length) {\r\n              state.buffer.push(chunk);\r\n              state.length += state.objectMode ? 1 : chunk.length;\r\n            }\r\n          }\r\n          state.ended = true;\r\n\r\n          // emit 'readable' now to make sure it gets picked up.\r\n          emitReadable(stream);\r\n        }\r\n\r\n        // Don't emit readable right away in sync mode, because this can trigger\r\n        // another read() call => stack overflow.  This way, it might trigger\r\n        // a nextTick recursion warning, but that's not so bad.\r\n        function emitReadable(stream) {\r\n          var state = stream._readableState;\r\n          state.needReadable = false;\r\n          if (!state.emittedReadable) {\r\n            debug('emitReadable', state.flowing);\r\n            state.emittedReadable = true;\r\n            if (state.sync) pna.nextTick(emitReadable_, stream);\r\n            else emitReadable_(stream);\r\n          }\r\n        }\r\n\r\n        function emitReadable_(stream) {\r\n          debug('emit readable');\r\n          stream.emit('readable');\r\n          flow(stream);\r\n        }\r\n\r\n        // at this point, the user has presumably seen the 'readable' event,\r\n        // and called read() to consume some data.  that may have triggered\r\n        // in turn another _read(n) call, in which case reading = true if\r\n        // it's in progress.\r\n        // However, if we're not ended, or reading, and the length < hwm,\r\n        // then go ahead and try to read some more preemptively.\r\n        function maybeReadMore(stream, state) {\r\n          if (!state.readingMore) {\r\n            state.readingMore = true;\r\n            pna.nextTick(maybeReadMore_, stream, state);\r\n          }\r\n        }\r\n\r\n        function maybeReadMore_(stream, state) {\r\n          var len = state.length;\r\n          while (!state.reading && !state.flowing && !state.ended && state.length < state.highWaterMark) {\r\n            debug('maybeReadMore read 0');\r\n            stream.read(0);\r\n            if (len === state.length)\r\n              // didn't get any data, stop spinning.\r\n              break;\r\n            else len = state.length;\r\n          }\r\n          state.readingMore = false;\r\n        }\r\n\r\n        // abstract method.  to be overridden in specific implementation classes.\r\n        // call cb(er, data) where data is <= n in length.\r\n        // for virtual (non-string, non-buffer) streams, \"length\" is somewhat\r\n        // arbitrary, and perhaps not very meaningful.\r\n        Readable.prototype._read = function (n) {\r\n          this.emit('error', new Error('_read() is not implemented'));\r\n        };\r\n\r\n        Readable.prototype.pipe = function (dest, pipeOpts) {\r\n          var src = this;\r\n          var state = this._readableState;\r\n\r\n          switch (state.pipesCount) {\r\n            case 0:\r\n              state.pipes = dest;\r\n              break;\r\n            case 1:\r\n              state.pipes = [state.pipes, dest];\r\n              break;\r\n            default:\r\n              state.pipes.push(dest);\r\n              break;\r\n          }\r\n          state.pipesCount += 1;\r\n          debug('pipe count=%d opts=%j', state.pipesCount, pipeOpts);\r\n\r\n          var doEnd = (!pipeOpts || pipeOpts.end !== false) && dest !== process.stdout && dest !== process.stderr;\r\n\r\n          var endFn = doEnd ? onend : unpipe;\r\n          if (state.endEmitted) pna.nextTick(endFn);\r\n          else src.once('end', endFn);\r\n\r\n          dest.on('unpipe', onunpipe);\r\n\r\n          function onunpipe(readable, unpipeInfo) {\r\n            debug('onunpipe');\r\n            if (readable === src) {\r\n              if (unpipeInfo && unpipeInfo.hasUnpiped === false) {\r\n                unpipeInfo.hasUnpiped = true;\r\n                cleanup();\r\n              }\r\n            }\r\n          }\r\n\r\n          function onend() {\r\n            debug('onend');\r\n            dest.end();\r\n          }\r\n\r\n          // when the dest drains, it reduces the awaitDrain counter\r\n          // on the source.  This would be more elegant with a .once()\r\n          // handler in flow(), but adding and removing repeatedly is\r\n          // too slow.\r\n          var ondrain = pipeOnDrain(src);\r\n          dest.on('drain', ondrain);\r\n\r\n          var cleanedUp = false;\r\n\r\n          function cleanup() {\r\n            debug('cleanup');\r\n            // cleanup event handlers once the pipe is broken\r\n            dest.removeListener('close', onclose);\r\n            dest.removeListener('finish', onfinish);\r\n            dest.removeListener('drain', ondrain);\r\n            dest.removeListener('error', onerror);\r\n            dest.removeListener('unpipe', onunpipe);\r\n            src.removeListener('end', onend);\r\n            src.removeListener('end', unpipe);\r\n            src.removeListener('data', ondata);\r\n\r\n            cleanedUp = true;\r\n\r\n            // if the reader is waiting for a drain event from this\r\n            // specific writer, then it would cause it to never start\r\n            // flowing again.\r\n            // So, if this is awaiting a drain, then we just call it now.\r\n            // If we don't know, then assume that we are waiting for one.\r\n            if (state.awaitDrain && (!dest._writableState || dest._writableState.needDrain)) ondrain();\r\n          }\r\n\r\n          // If the user pushes more data while we're writing to dest then we'll end up\r\n          // in ondata again. However, we only want to increase awaitDrain once because\r\n          // dest will only emit one 'drain' event for the multiple writes.\r\n          // => Introduce a guard on increasing awaitDrain.\r\n          var increasedAwaitDrain = false;\r\n          src.on('data', ondata);\r\n\r\n          function ondata(chunk) {\r\n            debug('ondata');\r\n            increasedAwaitDrain = false;\r\n            var ret = dest.write(chunk);\r\n            if (false === ret && !increasedAwaitDrain) {\r\n              // If the user unpiped during `dest.write()`, it is possible\r\n              // to get stuck in a permanently paused state if that write\r\n              // also returned false.\r\n              // => Check whether `dest` is still a piping destination.\r\n              if ((state.pipesCount === 1 && state.pipes === dest || state.pipesCount > 1 && indexOf(state.pipes, dest) !== -1) && !cleanedUp) {\r\n                debug('false write response, pause', src._readableState.awaitDrain);\r\n                src._readableState.awaitDrain++;\r\n                increasedAwaitDrain = true;\r\n              }\r\n              src.pause();\r\n            }\r\n          }\r\n\r\n          // if the dest has an error, then stop piping into it.\r\n          // however, don't suppress the throwing behavior for this.\r\n          function onerror(er) {\r\n            debug('onerror', er);\r\n            unpipe();\r\n            dest.removeListener('error', onerror);\r\n            if (EElistenerCount(dest, 'error') === 0) dest.emit('error', er);\r\n          }\r\n\r\n          // Make sure our error handler is attached before userland ones.\r\n          prependListener(dest, 'error', onerror);\r\n\r\n          // Both close and finish should trigger unpipe, but only once.\r\n          function onclose() {\r\n            dest.removeListener('finish', onfinish);\r\n            unpipe();\r\n          }\r\n          dest.once('close', onclose);\r\n\r\n          function onfinish() {\r\n            debug('onfinish');\r\n            dest.removeListener('close', onclose);\r\n            unpipe();\r\n          }\r\n          dest.once('finish', onfinish);\r\n\r\n          function unpipe() {\r\n            debug('unpipe');\r\n            src.unpipe(dest);\r\n          }\r\n\r\n          // tell the dest that it's being piped to\r\n          dest.emit('pipe', src);\r\n\r\n          // start the flow if it hasn't been started already.\r\n          if (!state.flowing) {\r\n            debug('pipe resume');\r\n            src.resume();\r\n          }\r\n\r\n          return dest;\r\n        };\r\n\r\n        function pipeOnDrain(src) {\r\n          return function () {\r\n            var state = src._readableState;\r\n            debug('pipeOnDrain', state.awaitDrain);\r\n            if (state.awaitDrain) state.awaitDrain--;\r\n            if (state.awaitDrain === 0 && EElistenerCount(src, 'data')) {\r\n              state.flowing = true;\r\n              flow(src);\r\n            }\r\n          };\r\n        }\r\n\r\n        Readable.prototype.unpipe = function (dest) {\r\n          var state = this._readableState;\r\n          var unpipeInfo = {\r\n            hasUnpiped: false\r\n          };\r\n\r\n          // if we're not piping anywhere, then do nothing.\r\n          if (state.pipesCount === 0) return this;\r\n\r\n          // just one destination.  most common case.\r\n          if (state.pipesCount === 1) {\r\n            // passed in one, but it's not the right one.\r\n            if (dest && dest !== state.pipes) return this;\r\n\r\n            if (!dest) dest = state.pipes;\r\n\r\n            // got a match.\r\n            state.pipes = null;\r\n            state.pipesCount = 0;\r\n            state.flowing = false;\r\n            if (dest) dest.emit('unpipe', this, unpipeInfo);\r\n            return this;\r\n          }\r\n\r\n          // slow case. multiple pipe destinations.\r\n\r\n          if (!dest) {\r\n            // remove all.\r\n            var dests = state.pipes;\r\n            var len = state.pipesCount;\r\n            state.pipes = null;\r\n            state.pipesCount = 0;\r\n            state.flowing = false;\r\n\r\n            for (var i = 0; i < len; i++) {\r\n              dests[i].emit('unpipe', this, unpipeInfo);\r\n            }\r\n            return this;\r\n          }\r\n\r\n          // try to find the right one.\r\n          var index = indexOf(state.pipes, dest);\r\n          if (index === -1) return this;\r\n\r\n          state.pipes.splice(index, 1);\r\n          state.pipesCount -= 1;\r\n          if (state.pipesCount === 1) state.pipes = state.pipes[0];\r\n\r\n          dest.emit('unpipe', this, unpipeInfo);\r\n\r\n          return this;\r\n        };\r\n\r\n        // set up data events if they are asked for\r\n        // Ensure readable listeners eventually get something\r\n        Readable.prototype.on = function (ev, fn) {\r\n          var res = Stream.prototype.on.call(this, ev, fn);\r\n\r\n          if (ev === 'data') {\r\n            // Start flowing on next tick if stream isn't explicitly paused\r\n            if (this._readableState.flowing !== false) this.resume();\r\n          } else if (ev === 'readable') {\r\n            var state = this._readableState;\r\n            if (!state.endEmitted && !state.readableListening) {\r\n              state.readableListening = state.needReadable = true;\r\n              state.emittedReadable = false;\r\n              if (!state.reading) {\r\n                pna.nextTick(nReadingNextTick, this);\r\n              } else if (state.length) {\r\n                emitReadable(this);\r\n              }\r\n            }\r\n          }\r\n\r\n          return res;\r\n        };\r\n        Readable.prototype.addListener = Readable.prototype.on;\r\n\r\n        function nReadingNextTick(self) {\r\n          debug('readable nexttick read 0');\r\n          self.read(0);\r\n        }\r\n\r\n        // pause() and resume() are remnants of the legacy readable stream API\r\n        // If the user uses them, then switch into old mode.\r\n        Readable.prototype.resume = function () {\r\n          var state = this._readableState;\r\n          if (!state.flowing) {\r\n            debug('resume');\r\n            state.flowing = true;\r\n            resume(this, state);\r\n          }\r\n          return this;\r\n        };\r\n\r\n        function resume(stream, state) {\r\n          if (!state.resumeScheduled) {\r\n            state.resumeScheduled = true;\r\n            pna.nextTick(resume_, stream, state);\r\n          }\r\n        }\r\n\r\n        function resume_(stream, state) {\r\n          if (!state.reading) {\r\n            debug('resume read 0');\r\n            stream.read(0);\r\n          }\r\n\r\n          state.resumeScheduled = false;\r\n          state.awaitDrain = 0;\r\n          stream.emit('resume');\r\n          flow(stream);\r\n          if (state.flowing && !state.reading) stream.read(0);\r\n        }\r\n\r\n        Readable.prototype.pause = function () {\r\n          debug('call pause flowing=%j', this._readableState.flowing);\r\n          if (false !== this._readableState.flowing) {\r\n            debug('pause');\r\n            this._readableState.flowing = false;\r\n            this.emit('pause');\r\n          }\r\n          return this;\r\n        };\r\n\r\n        function flow(stream) {\r\n          var state = stream._readableState;\r\n          debug('flow', state.flowing);\r\n          while (state.flowing && stream.read() !== null) {}\r\n        }\r\n\r\n        // wrap an old-style stream as the async data source.\r\n        // This is *not* part of the readable stream interface.\r\n        // It is an ugly unfortunate mess of history.\r\n        Readable.prototype.wrap = function (stream) {\r\n          var _this = this;\r\n\r\n          var state = this._readableState;\r\n          var paused = false;\r\n\r\n          stream.on('end', function () {\r\n            debug('wrapped end');\r\n            if (state.decoder && !state.ended) {\r\n              var chunk = state.decoder.end();\r\n              if (chunk && chunk.length) _this.push(chunk);\r\n            }\r\n\r\n            _this.push(null);\r\n          });\r\n\r\n          stream.on('data', function (chunk) {\r\n            debug('wrapped data');\r\n            if (state.decoder) chunk = state.decoder.write(chunk);\r\n\r\n            // don't skip over falsy values in objectMode\r\n            if (state.objectMode && (chunk === null || chunk === undefined)) return;\r\n            else if (!state.objectMode && (!chunk || !chunk.length)) return;\r\n\r\n            var ret = _this.push(chunk);\r\n            if (!ret) {\r\n              paused = true;\r\n              stream.pause();\r\n            }\r\n          });\r\n\r\n          // proxy all the other methods.\r\n          // important when wrapping filters and duplexes.\r\n          for (var i in stream) {\r\n            if (this[i] === undefined && typeof stream[i] === 'function') {\r\n              this[i] = function (method) {\r\n                return function () {\r\n                  return stream[method].apply(stream, arguments);\r\n                };\r\n              }(i);\r\n            }\r\n          }\r\n\r\n          // proxy certain important events.\r\n          for (var n = 0; n < kProxyEvents.length; n++) {\r\n            stream.on(kProxyEvents[n], this.emit.bind(this, kProxyEvents[n]));\r\n          }\r\n\r\n          // when we try to consume some more bytes, simply unpause the\r\n          // underlying stream.\r\n          this._read = function (n) {\r\n            debug('wrapped _read', n);\r\n            if (paused) {\r\n              paused = false;\r\n              stream.resume();\r\n            }\r\n          };\r\n\r\n          return this;\r\n        };\r\n\r\n        Object.defineProperty(Readable.prototype, 'readableHighWaterMark', {\r\n          // making it explicit this property is not enumerable\r\n          // because otherwise some prototype manipulation in\r\n          // userland will fail\r\n          enumerable: false,\r\n          get: function () {\r\n            return this._readableState.highWaterMark;\r\n          }\r\n        });\r\n\r\n        // exposed for testing purposes only.\r\n        Readable._fromList = fromList;\r\n\r\n        // Pluck off n bytes from an array of buffers.\r\n        // Length is the combined lengths of all the buffers in the list.\r\n        // This function is designed to be inlinable, so please take care when making\r\n        // changes to the function body.\r\n        function fromList(n, state) {\r\n          // nothing buffered\r\n          if (state.length === 0) return null;\r\n\r\n          var ret;\r\n          if (state.objectMode) ret = state.buffer.shift();\r\n          else if (!n || n >= state.length) {\r\n            // read it all, truncate the list\r\n            if (state.decoder) ret = state.buffer.join('');\r\n            else if (state.buffer.length === 1) ret = state.buffer.head.data;\r\n            else ret = state.buffer.concat(state.length);\r\n            state.buffer.clear();\r\n          } else {\r\n            // read part of list\r\n            ret = fromListPartial(n, state.buffer, state.decoder);\r\n          }\r\n\r\n          return ret;\r\n        }\r\n\r\n        // Extracts only enough buffered data to satisfy the amount requested.\r\n        // This function is designed to be inlinable, so please take care when making\r\n        // changes to the function body.\r\n        function fromListPartial(n, list, hasStrings) {\r\n          var ret;\r\n          if (n < list.head.data.length) {\r\n            // slice is the same for buffers and strings\r\n            ret = list.head.data.slice(0, n);\r\n            list.head.data = list.head.data.slice(n);\r\n          } else if (n === list.head.data.length) {\r\n            // first chunk is a perfect match\r\n            ret = list.shift();\r\n          } else {\r\n            // result spans more than one buffer\r\n            ret = hasStrings ? copyFromBufferString(n, list) : copyFromBuffer(n, list);\r\n          }\r\n          return ret;\r\n        }\r\n\r\n        // Copies a specified amount of characters from the list of buffered data\r\n        // chunks.\r\n        // This function is designed to be inlinable, so please take care when making\r\n        // changes to the function body.\r\n        function copyFromBufferString(n, list) {\r\n          var p = list.head;\r\n          var c = 1;\r\n          var ret = p.data;\r\n          n -= ret.length;\r\n          while (p = p.next) {\r\n            var str = p.data;\r\n            var nb = n > str.length ? str.length : n;\r\n            if (nb === str.length) ret += str;\r\n            else ret += str.slice(0, n);\r\n            n -= nb;\r\n            if (n === 0) {\r\n              if (nb === str.length) {\r\n                ++c;\r\n                if (p.next) list.head = p.next;\r\n                else list.head = list.tail = null;\r\n              } else {\r\n                list.head = p;\r\n                p.data = str.slice(nb);\r\n              }\r\n              break;\r\n            }\r\n            ++c;\r\n          }\r\n          list.length -= c;\r\n          return ret;\r\n        }\r\n\r\n        // Copies a specified amount of bytes from the list of buffered data chunks.\r\n        // This function is designed to be inlinable, so please take care when making\r\n        // changes to the function body.\r\n        function copyFromBuffer(n, list) {\r\n          var ret = Buffer.allocUnsafe(n);\r\n          var p = list.head;\r\n          var c = 1;\r\n          p.data.copy(ret);\r\n          n -= p.data.length;\r\n          while (p = p.next) {\r\n            var buf = p.data;\r\n            var nb = n > buf.length ? buf.length : n;\r\n            buf.copy(ret, ret.length - n, 0, nb);\r\n            n -= nb;\r\n            if (n === 0) {\r\n              if (nb === buf.length) {\r\n                ++c;\r\n                if (p.next) list.head = p.next;\r\n                else list.head = list.tail = null;\r\n              } else {\r\n                list.head = p;\r\n                p.data = buf.slice(nb);\r\n              }\r\n              break;\r\n            }\r\n            ++c;\r\n          }\r\n          list.length -= c;\r\n          return ret;\r\n        }\r\n\r\n        function endReadable(stream) {\r\n          var state = stream._readableState;\r\n\r\n          // If we get here before consuming all the bytes, then that is a\r\n          // bug in node.  Should never happen.\r\n          if (state.length > 0) throw new Error('\"endReadable()\" called on non-empty stream');\r\n\r\n          if (!state.endEmitted) {\r\n            state.ended = true;\r\n            pna.nextTick(endReadableNT, state, stream);\r\n          }\r\n        }\r\n\r\n        function endReadableNT(state, stream) {\r\n          // Check that we didn't get one last unshift.\r\n          if (!state.endEmitted && state.length === 0) {\r\n            state.endEmitted = true;\r\n            stream.readable = false;\r\n            stream.emit('end');\r\n          }\r\n        }\r\n\r\n        function indexOf(xs, x) {\r\n          for (var i = 0, l = xs.length; i < l; i++) {\r\n            if (xs[i] === x) return i;\r\n          }\r\n          return -1;\r\n        }\r\n      }).call(this, require('_process'), typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {})\r\n    }, {\r\n      \"./_stream_duplex\": 134,\r\n      \"./internal/streams/BufferList\": 139,\r\n      \"./internal/streams/destroy\": 140,\r\n      \"./internal/streams/stream\": 141,\r\n      \"_process\": 124,\r\n      \"core-util-is\": 56,\r\n      \"events\": 89,\r\n      \"inherits\": 106,\r\n      \"isarray\": 108,\r\n      \"process-nextick-args\": 123,\r\n      \"safe-buffer\": 147,\r\n      \"string_decoder/\": 157,\r\n      \"util\": 25\r\n    }],\r\n    137: [function (require, module, exports) {\r\n      // Copyright Joyent, Inc. and other Node contributors.\r\n      //\r\n      // Permission is hereby granted, free of charge, to any person obtaining a\r\n      // copy of this software and associated documentation files (the\r\n      // \"Software\"), to deal in the Software without restriction, including\r\n      // without limitation the rights to use, copy, modify, merge, publish,\r\n      // distribute, sublicense, and/or sell copies of the Software, and to permit\r\n      // persons to whom the Software is furnished to do so, subject to the\r\n      // following conditions:\r\n      //\r\n      // The above copyright notice and this permission notice shall be included\r\n      // in all copies or substantial portions of the Software.\r\n      //\r\n      // THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\r\n      // OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\r\n      // MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\r\n      // NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\r\n      // DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\r\n      // OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\r\n      // USE OR OTHER DEALINGS IN THE SOFTWARE.\r\n\r\n      // a transform stream is a readable/writable stream where you do\r\n      // something with the data.  Sometimes it's called a \"filter\",\r\n      // but that's not a great name for it, since that implies a thing where\r\n      // some bits pass through, and others are simply ignored.  (That would\r\n      // be a valid example of a transform, of course.)\r\n      //\r\n      // While the output is causally related to the input, it's not a\r\n      // necessarily symmetric or synchronous transformation.  For example,\r\n      // a zlib stream might take multiple plain-text writes(), and then\r\n      // emit a single compressed chunk some time in the future.\r\n      //\r\n      // Here's how this works:\r\n      //\r\n      // The Transform stream has all the aspects of the readable and writable\r\n      // stream classes.  When you write(chunk), that calls _write(chunk,cb)\r\n      // internally, and returns false if there's a lot of pending writes\r\n      // buffered up.  When you call read(), that calls _read(n) until\r\n      // there's enough pending readable data buffered up.\r\n      //\r\n      // In a transform stream, the written data is placed in a buffer.  When\r\n      // _read(n) is called, it transforms the queued up data, calling the\r\n      // buffered _write cb's as it consumes chunks.  If consuming a single\r\n      // written chunk would result in multiple output chunks, then the first\r\n      // outputted bit calls the readcb, and subsequent chunks just go into\r\n      // the read buffer, and will cause it to emit 'readable' if necessary.\r\n      //\r\n      // This way, back-pressure is actually determined by the reading side,\r\n      // since _read has to be called to start processing a new chunk.  However,\r\n      // a pathological inflate type of transform can cause excessive buffering\r\n      // here.  For example, imagine a stream where every byte of input is\r\n      // interpreted as an integer from 0-255, and then results in that many\r\n      // bytes of output.  Writing the 4 bytes {ff,ff,ff,ff} would result in\r\n      // 1kb of data being output.  In this case, you could write a very small\r\n      // amount of input, and end up with a very large amount of output.  In\r\n      // such a pathological inflating mechanism, there'd be no way to tell\r\n      // the system to stop doing the transform.  A single 4MB write could\r\n      // cause the system to run out of memory.\r\n      //\r\n      // However, even in such a pathological case, only a single written chunk\r\n      // would be consumed, and then the rest would wait (un-transformed) until\r\n      // the results of the previous transformed chunk were consumed.\r\n\r\n      'use strict';\r\n\r\n      module.exports = Transform;\r\n\r\n      var Duplex = require('./_stream_duplex');\r\n\r\n      /*<replacement>*/\r\n      var util = require('core-util-is');\r\n      util.inherits = require('inherits');\r\n      /*</replacement>*/\r\n\r\n      util.inherits(Transform, Duplex);\r\n\r\n      function afterTransform(er, data) {\r\n        var ts = this._transformState;\r\n        ts.transforming = false;\r\n\r\n        var cb = ts.writecb;\r\n\r\n        if (!cb) {\r\n          return this.emit('error', new Error('write callback called multiple times'));\r\n        }\r\n\r\n        ts.writechunk = null;\r\n        ts.writecb = null;\r\n\r\n        if (data != null) // single equals check for both `null` and `undefined`\r\n          this.push(data);\r\n\r\n        cb(er);\r\n\r\n        var rs = this._readableState;\r\n        rs.reading = false;\r\n        if (rs.needReadable || rs.length < rs.highWaterMark) {\r\n          this._read(rs.highWaterMark);\r\n        }\r\n      }\r\n\r\n      function Transform(options) {\r\n        if (!(this instanceof Transform)) return new Transform(options);\r\n\r\n        Duplex.call(this, options);\r\n\r\n        this._transformState = {\r\n          afterTransform: afterTransform.bind(this),\r\n          needTransform: false,\r\n          transforming: false,\r\n          writecb: null,\r\n          writechunk: null,\r\n          writeencoding: null\r\n        };\r\n\r\n        // start out asking for a readable event once data is transformed.\r\n        this._readableState.needReadable = true;\r\n\r\n        // we have implemented the _read method, and done the other things\r\n        // that Readable wants before the first _read call, so unset the\r\n        // sync guard flag.\r\n        this._readableState.sync = false;\r\n\r\n        if (options) {\r\n          if (typeof options.transform === 'function') this._transform = options.transform;\r\n\r\n          if (typeof options.flush === 'function') this._flush = options.flush;\r\n        }\r\n\r\n        // When the writable side finishes, then flush out anything remaining.\r\n        this.on('prefinish', prefinish);\r\n      }\r\n\r\n      function prefinish() {\r\n        var _this = this;\r\n\r\n        if (typeof this._flush === 'function') {\r\n          this._flush(function (er, data) {\r\n            done(_this, er, data);\r\n          });\r\n        } else {\r\n          done(this, null, null);\r\n        }\r\n      }\r\n\r\n      Transform.prototype.push = function (chunk, encoding) {\r\n        this._transformState.needTransform = false;\r\n        return Duplex.prototype.push.call(this, chunk, encoding);\r\n      };\r\n\r\n      // This is the part where you do stuff!\r\n      // override this function in implementation classes.\r\n      // 'chunk' is an input chunk.\r\n      //\r\n      // Call `push(newChunk)` to pass along transformed output\r\n      // to the readable side.  You may call 'push' zero or more times.\r\n      //\r\n      // Call `cb(err)` when you are done with this chunk.  If you pass\r\n      // an error, then that'll put the hurt on the whole operation.  If you\r\n      // never call cb(), then you'll never get another chunk.\r\n      Transform.prototype._transform = function (chunk, encoding, cb) {\r\n        throw new Error('_transform() is not implemented');\r\n      };\r\n\r\n      Transform.prototype._write = function (chunk, encoding, cb) {\r\n        var ts = this._transformState;\r\n        ts.writecb = cb;\r\n        ts.writechunk = chunk;\r\n        ts.writeencoding = encoding;\r\n        if (!ts.transforming) {\r\n          var rs = this._readableState;\r\n          if (ts.needTransform || rs.needReadable || rs.length < rs.highWaterMark) this._read(rs.highWaterMark);\r\n        }\r\n      };\r\n\r\n      // Doesn't matter what the args are here.\r\n      // _transform does all the work.\r\n      // That we got here means that the readable side wants more data.\r\n      Transform.prototype._read = function (n) {\r\n        var ts = this._transformState;\r\n\r\n        if (ts.writechunk !== null && ts.writecb && !ts.transforming) {\r\n          ts.transforming = true;\r\n          this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);\r\n        } else {\r\n          // mark that we need a transform, so that any data that comes in\r\n          // will get processed, now that we've asked for it.\r\n          ts.needTransform = true;\r\n        }\r\n      };\r\n\r\n      Transform.prototype._destroy = function (err, cb) {\r\n        var _this2 = this;\r\n\r\n        Duplex.prototype._destroy.call(this, err, function (err2) {\r\n          cb(err2);\r\n          _this2.emit('close');\r\n        });\r\n      };\r\n\r\n      function done(stream, er, data) {\r\n        if (er) return stream.emit('error', er);\r\n\r\n        if (data != null) // single equals check for both `null` and `undefined`\r\n          stream.push(data);\r\n\r\n        // if there's nothing in the write buffer, then that means\r\n        // that nothing more will ever be provided\r\n        if (stream._writableState.length) throw new Error('Calling transform done when ws.length != 0');\r\n\r\n        if (stream._transformState.transforming) throw new Error('Calling transform done when still transforming');\r\n\r\n        return stream.push(null);\r\n      }\r\n    }, {\r\n      \"./_stream_duplex\": 134,\r\n      \"core-util-is\": 56,\r\n      \"inherits\": 106\r\n    }],\r\n    138: [function (require, module, exports) {\r\n      (function (process, global, setImmediate) {\r\n        // Copyright Joyent, Inc. and other Node contributors.\r\n        //\r\n        // Permission is hereby granted, free of charge, to any person obtaining a\r\n        // copy of this software and associated documentation files (the\r\n        // \"Software\"), to deal in the Software without restriction, including\r\n        // without limitation the rights to use, copy, modify, merge, publish,\r\n        // distribute, sublicense, and/or sell copies of the Software, and to permit\r\n        // persons to whom the Software is furnished to do so, subject to the\r\n        // following conditions:\r\n        //\r\n        // The above copyright notice and this permission notice shall be included\r\n        // in all copies or substantial portions of the Software.\r\n        //\r\n        // THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\r\n        // OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\r\n        // MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\r\n        // NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\r\n        // DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\r\n        // OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\r\n        // USE OR OTHER DEALINGS IN THE SOFTWARE.\r\n\r\n        // A bit simpler than readable streams.\r\n        // Implement an async ._write(chunk, encoding, cb), and it'll handle all\r\n        // the drain event emission and buffering.\r\n\r\n        'use strict';\r\n\r\n        /*<replacement>*/\r\n\r\n        var pna = require('process-nextick-args');\r\n        /*</replacement>*/\r\n\r\n        module.exports = Writable;\r\n\r\n        /* <replacement> */\r\n        function WriteReq(chunk, encoding, cb) {\r\n          this.chunk = chunk;\r\n          this.encoding = encoding;\r\n          this.callback = cb;\r\n          this.next = null;\r\n        }\r\n\r\n        // It seems a linked list but it is not\r\n        // there will be only 2 of these for each stream\r\n        function CorkedRequest(state) {\r\n          var _this = this;\r\n\r\n          this.next = null;\r\n          this.entry = null;\r\n          this.finish = function () {\r\n            onCorkedFinish(_this, state);\r\n          };\r\n        }\r\n        /* </replacement> */\r\n\r\n        /*<replacement>*/\r\n        var asyncWrite = !process.browser && ['v0.10', 'v0.9.'].indexOf(process.version.slice(0, 5)) > -1 ? setImmediate : pna.nextTick;\r\n        /*</replacement>*/\r\n\r\n        /*<replacement>*/\r\n        var Duplex;\r\n        /*</replacement>*/\r\n\r\n        Writable.WritableState = WritableState;\r\n\r\n        /*<replacement>*/\r\n        var util = require('core-util-is');\r\n        util.inherits = require('inherits');\r\n        /*</replacement>*/\r\n\r\n        /*<replacement>*/\r\n        var internalUtil = {\r\n          deprecate: require('util-deprecate')\r\n        };\r\n        /*</replacement>*/\r\n\r\n        /*<replacement>*/\r\n        var Stream = require('./internal/streams/stream');\r\n        /*</replacement>*/\r\n\r\n        /*<replacement>*/\r\n\r\n        var Buffer = require('safe-buffer').Buffer;\r\n        var OurUint8Array = global.Uint8Array || function () {};\r\n\r\n        function _uint8ArrayToBuffer(chunk) {\r\n          return Buffer.from(chunk);\r\n        }\r\n\r\n        function _isUint8Array(obj) {\r\n          return Buffer.isBuffer(obj) || obj instanceof OurUint8Array;\r\n        }\r\n\r\n        /*</replacement>*/\r\n\r\n        var destroyImpl = require('./internal/streams/destroy');\r\n\r\n        util.inherits(Writable, Stream);\r\n\r\n        function nop() {}\r\n\r\n        function WritableState(options, stream) {\r\n          Duplex = Duplex || require('./_stream_duplex');\r\n\r\n          options = options || {};\r\n\r\n          // Duplex streams are both readable and writable, but share\r\n          // the same options object.\r\n          // However, some cases require setting options to different\r\n          // values for the readable and the writable sides of the duplex stream.\r\n          // These options can be provided separately as readableXXX and writableXXX.\r\n          var isDuplex = stream instanceof Duplex;\r\n\r\n          // object stream flag to indicate whether or not this stream\r\n          // contains buffers or objects.\r\n          this.objectMode = !!options.objectMode;\r\n\r\n          if (isDuplex) this.objectMode = this.objectMode || !!options.writableObjectMode;\r\n\r\n          // the point at which write() starts returning false\r\n          // Note: 0 is a valid value, means that we always return false if\r\n          // the entire buffer is not flushed immediately on write()\r\n          var hwm = options.highWaterMark;\r\n          var writableHwm = options.writableHighWaterMark;\r\n          var defaultHwm = this.objectMode ? 16 : 16 * 1024;\r\n\r\n          if (hwm || hwm === 0) this.highWaterMark = hwm;\r\n          else if (isDuplex && (writableHwm || writableHwm === 0)) this.highWaterMark = writableHwm;\r\n          else this.highWaterMark = defaultHwm;\r\n\r\n          // cast to ints.\r\n          this.highWaterMark = Math.floor(this.highWaterMark);\r\n\r\n          // if _final has been called\r\n          this.finalCalled = false;\r\n\r\n          // drain event flag.\r\n          this.needDrain = false;\r\n          // at the start of calling end()\r\n          this.ending = false;\r\n          // when end() has been called, and returned\r\n          this.ended = false;\r\n          // when 'finish' is emitted\r\n          this.finished = false;\r\n\r\n          // has it been destroyed\r\n          this.destroyed = false;\r\n\r\n          // should we decode strings into buffers before passing to _write?\r\n          // this is here so that some node-core streams can optimize string\r\n          // handling at a lower level.\r\n          var noDecode = options.decodeStrings === false;\r\n          this.decodeStrings = !noDecode;\r\n\r\n          // Crypto is kind of old and crusty.  Historically, its default string\r\n          // encoding is 'binary' so we have to make this configurable.\r\n          // Everything else in the universe uses 'utf8', though.\r\n          this.defaultEncoding = options.defaultEncoding || 'utf8';\r\n\r\n          // not an actual buffer we keep track of, but a measurement\r\n          // of how much we're waiting to get pushed to some underlying\r\n          // socket or file.\r\n          this.length = 0;\r\n\r\n          // a flag to see when we're in the middle of a write.\r\n          this.writing = false;\r\n\r\n          // when true all writes will be buffered until .uncork() call\r\n          this.corked = 0;\r\n\r\n          // a flag to be able to tell if the onwrite cb is called immediately,\r\n          // or on a later tick.  We set this to true at first, because any\r\n          // actions that shouldn't happen until \"later\" should generally also\r\n          // not happen before the first write call.\r\n          this.sync = true;\r\n\r\n          // a flag to know if we're processing previously buffered items, which\r\n          // may call the _write() callback in the same tick, so that we don't\r\n          // end up in an overlapped onwrite situation.\r\n          this.bufferProcessing = false;\r\n\r\n          // the callback that's passed to _write(chunk,cb)\r\n          this.onwrite = function (er) {\r\n            onwrite(stream, er);\r\n          };\r\n\r\n          // the callback that the user supplies to write(chunk,encoding,cb)\r\n          this.writecb = null;\r\n\r\n          // the amount that is being written when _write is called.\r\n          this.writelen = 0;\r\n\r\n          this.bufferedRequest = null;\r\n          this.lastBufferedRequest = null;\r\n\r\n          // number of pending user-supplied write callbacks\r\n          // this must be 0 before 'finish' can be emitted\r\n          this.pendingcb = 0;\r\n\r\n          // emit prefinish if the only thing we're waiting for is _write cbs\r\n          // This is relevant for synchronous Transform streams\r\n          this.prefinished = false;\r\n\r\n          // True if the error was already emitted and should not be thrown again\r\n          this.errorEmitted = false;\r\n\r\n          // count buffered requests\r\n          this.bufferedRequestCount = 0;\r\n\r\n          // allocate the first CorkedRequest, there is always\r\n          // one allocated and free to use, and we maintain at most two\r\n          this.corkedRequestsFree = new CorkedRequest(this);\r\n        }\r\n\r\n        WritableState.prototype.getBuffer = function getBuffer() {\r\n          var current = this.bufferedRequest;\r\n          var out = [];\r\n          while (current) {\r\n            out.push(current);\r\n            current = current.next;\r\n          }\r\n          return out;\r\n        };\r\n\r\n        (function () {\r\n          try {\r\n            Object.defineProperty(WritableState.prototype, 'buffer', {\r\n              get: internalUtil.deprecate(function () {\r\n                return this.getBuffer();\r\n              }, '_writableState.buffer is deprecated. Use _writableState.getBuffer ' + 'instead.', 'DEP0003')\r\n            });\r\n          } catch (_) {}\r\n        })();\r\n\r\n        // Test _writableState for inheritance to account for Duplex streams,\r\n        // whose prototype chain only points to Readable.\r\n        var realHasInstance;\r\n        if (typeof Symbol === 'function' && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] === 'function') {\r\n          realHasInstance = Function.prototype[Symbol.hasInstance];\r\n          Object.defineProperty(Writable, Symbol.hasInstance, {\r\n            value: function (object) {\r\n              if (realHasInstance.call(this, object)) return true;\r\n              if (this !== Writable) return false;\r\n\r\n              return object && object._writableState instanceof WritableState;\r\n            }\r\n          });\r\n        } else {\r\n          realHasInstance = function (object) {\r\n            return object instanceof this;\r\n          };\r\n        }\r\n\r\n        function Writable(options) {\r\n          Duplex = Duplex || require('./_stream_duplex');\r\n\r\n          // Writable ctor is applied to Duplexes, too.\r\n          // `realHasInstance` is necessary because using plain `instanceof`\r\n          // would return false, as no `_writableState` property is attached.\r\n\r\n          // Trying to use the custom `instanceof` for Writable here will also break the\r\n          // Node.js LazyTransform implementation, which has a non-trivial getter for\r\n          // `_writableState` that would lead to infinite recursion.\r\n          if (!realHasInstance.call(Writable, this) && !(this instanceof Duplex)) {\r\n            return new Writable(options);\r\n          }\r\n\r\n          this._writableState = new WritableState(options, this);\r\n\r\n          // legacy.\r\n          this.writable = true;\r\n\r\n          if (options) {\r\n            if (typeof options.write === 'function') this._write = options.write;\r\n\r\n            if (typeof options.writev === 'function') this._writev = options.writev;\r\n\r\n            if (typeof options.destroy === 'function') this._destroy = options.destroy;\r\n\r\n            if (typeof options.final === 'function') this._final = options.final;\r\n          }\r\n\r\n          Stream.call(this);\r\n        }\r\n\r\n        // Otherwise people can pipe Writable streams, which is just wrong.\r\n        Writable.prototype.pipe = function () {\r\n          this.emit('error', new Error('Cannot pipe, not readable'));\r\n        };\r\n\r\n        function writeAfterEnd(stream, cb) {\r\n          var er = new Error('write after end');\r\n          // TODO: defer error events consistently everywhere, not just the cb\r\n          stream.emit('error', er);\r\n          pna.nextTick(cb, er);\r\n        }\r\n\r\n        // Checks that a user-supplied chunk is valid, especially for the particular\r\n        // mode the stream is in. Currently this means that `null` is never accepted\r\n        // and undefined/non-string values are only allowed in object mode.\r\n        function validChunk(stream, state, chunk, cb) {\r\n          var valid = true;\r\n          var er = false;\r\n\r\n          if (chunk === null) {\r\n            er = new TypeError('May not write null values to stream');\r\n          } else if (typeof chunk !== 'string' && chunk !== undefined && !state.objectMode) {\r\n            er = new TypeError('Invalid non-string/buffer chunk');\r\n          }\r\n          if (er) {\r\n            stream.emit('error', er);\r\n            pna.nextTick(cb, er);\r\n            valid = false;\r\n          }\r\n          return valid;\r\n        }\r\n\r\n        Writable.prototype.write = function (chunk, encoding, cb) {\r\n          var state = this._writableState;\r\n          var ret = false;\r\n          var isBuf = !state.objectMode && _isUint8Array(chunk);\r\n\r\n          if (isBuf && !Buffer.isBuffer(chunk)) {\r\n            chunk = _uint8ArrayToBuffer(chunk);\r\n          }\r\n\r\n          if (typeof encoding === 'function') {\r\n            cb = encoding;\r\n            encoding = null;\r\n          }\r\n\r\n          if (isBuf) encoding = 'buffer';\r\n          else if (!encoding) encoding = state.defaultEncoding;\r\n\r\n          if (typeof cb !== 'function') cb = nop;\r\n\r\n          if (state.ended) writeAfterEnd(this, cb);\r\n          else if (isBuf || validChunk(this, state, chunk, cb)) {\r\n            state.pendingcb++;\r\n            ret = writeOrBuffer(this, state, isBuf, chunk, encoding, cb);\r\n          }\r\n\r\n          return ret;\r\n        };\r\n\r\n        Writable.prototype.cork = function () {\r\n          var state = this._writableState;\r\n\r\n          state.corked++;\r\n        };\r\n\r\n        Writable.prototype.uncork = function () {\r\n          var state = this._writableState;\r\n\r\n          if (state.corked) {\r\n            state.corked--;\r\n\r\n            if (!state.writing && !state.corked && !state.finished && !state.bufferProcessing && state.bufferedRequest) clearBuffer(this, state);\r\n          }\r\n        };\r\n\r\n        Writable.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {\r\n          // node::ParseEncoding() requires lower case.\r\n          if (typeof encoding === 'string') encoding = encoding.toLowerCase();\r\n          if (!(['hex', 'utf8', 'utf-8', 'ascii', 'binary', 'base64', 'ucs2', 'ucs-2', 'utf16le', 'utf-16le', 'raw'].indexOf((encoding + '').toLowerCase()) > -1)) throw new TypeError('Unknown encoding: ' + encoding);\r\n          this._writableState.defaultEncoding = encoding;\r\n          return this;\r\n        };\r\n\r\n        function decodeChunk(state, chunk, encoding) {\r\n          if (!state.objectMode && state.decodeStrings !== false && typeof chunk === 'string') {\r\n            chunk = Buffer.from(chunk, encoding);\r\n          }\r\n          return chunk;\r\n        }\r\n\r\n        Object.defineProperty(Writable.prototype, 'writableHighWaterMark', {\r\n          // making it explicit this property is not enumerable\r\n          // because otherwise some prototype manipulation in\r\n          // userland will fail\r\n          enumerable: false,\r\n          get: function () {\r\n            return this._writableState.highWaterMark;\r\n          }\r\n        });\r\n\r\n        // if we're already writing something, then just put this\r\n        // in the queue, and wait our turn.  Otherwise, call _write\r\n        // If we return false, then we need a drain event, so set that flag.\r\n        function writeOrBuffer(stream, state, isBuf, chunk, encoding, cb) {\r\n          if (!isBuf) {\r\n            var newChunk = decodeChunk(state, chunk, encoding);\r\n            if (chunk !== newChunk) {\r\n              isBuf = true;\r\n              encoding = 'buffer';\r\n              chunk = newChunk;\r\n            }\r\n          }\r\n          var len = state.objectMode ? 1 : chunk.length;\r\n\r\n          state.length += len;\r\n\r\n          var ret = state.length < state.highWaterMark;\r\n          // we must ensure that previous needDrain will not be reset to false.\r\n          if (!ret) state.needDrain = true;\r\n\r\n          if (state.writing || state.corked) {\r\n            var last = state.lastBufferedRequest;\r\n            state.lastBufferedRequest = {\r\n              chunk: chunk,\r\n              encoding: encoding,\r\n              isBuf: isBuf,\r\n              callback: cb,\r\n              next: null\r\n            };\r\n            if (last) {\r\n              last.next = state.lastBufferedRequest;\r\n            } else {\r\n              state.bufferedRequest = state.lastBufferedRequest;\r\n            }\r\n            state.bufferedRequestCount += 1;\r\n          } else {\r\n            doWrite(stream, state, false, len, chunk, encoding, cb);\r\n          }\r\n\r\n          return ret;\r\n        }\r\n\r\n        function doWrite(stream, state, writev, len, chunk, encoding, cb) {\r\n          state.writelen = len;\r\n          state.writecb = cb;\r\n          state.writing = true;\r\n          state.sync = true;\r\n          if (writev) stream._writev(chunk, state.onwrite);\r\n          else stream._write(chunk, encoding, state.onwrite);\r\n          state.sync = false;\r\n        }\r\n\r\n        function onwriteError(stream, state, sync, er, cb) {\r\n          --state.pendingcb;\r\n\r\n          if (sync) {\r\n            // defer the callback if we are being called synchronously\r\n            // to avoid piling up things on the stack\r\n            pna.nextTick(cb, er);\r\n            // this can emit finish, and it will always happen\r\n            // after error\r\n            pna.nextTick(finishMaybe, stream, state);\r\n            stream._writableState.errorEmitted = true;\r\n            stream.emit('error', er);\r\n          } else {\r\n            // the caller expect this to happen before if\r\n            // it is async\r\n            cb(er);\r\n            stream._writableState.errorEmitted = true;\r\n            stream.emit('error', er);\r\n            // this can emit finish, but finish must\r\n            // always follow error\r\n            finishMaybe(stream, state);\r\n          }\r\n        }\r\n\r\n        function onwriteStateUpdate(state) {\r\n          state.writing = false;\r\n          state.writecb = null;\r\n          state.length -= state.writelen;\r\n          state.writelen = 0;\r\n        }\r\n\r\n        function onwrite(stream, er) {\r\n          var state = stream._writableState;\r\n          var sync = state.sync;\r\n          var cb = state.writecb;\r\n\r\n          onwriteStateUpdate(state);\r\n\r\n          if (er) onwriteError(stream, state, sync, er, cb);\r\n          else {\r\n            // Check if we're actually ready to finish, but don't emit yet\r\n            var finished = needFinish(state);\r\n\r\n            if (!finished && !state.corked && !state.bufferProcessing && state.bufferedRequest) {\r\n              clearBuffer(stream, state);\r\n            }\r\n\r\n            if (sync) {\r\n              /*<replacement>*/\r\n              asyncWrite(afterWrite, stream, state, finished, cb);\r\n              /*</replacement>*/\r\n            } else {\r\n              afterWrite(stream, state, finished, cb);\r\n            }\r\n          }\r\n        }\r\n\r\n        function afterWrite(stream, state, finished, cb) {\r\n          if (!finished) onwriteDrain(stream, state);\r\n          state.pendingcb--;\r\n          cb();\r\n          finishMaybe(stream, state);\r\n        }\r\n\r\n        // Must force callback to be called on nextTick, so that we don't\r\n        // emit 'drain' before the write() consumer gets the 'false' return\r\n        // value, and has a chance to attach a 'drain' listener.\r\n        function onwriteDrain(stream, state) {\r\n          if (state.length === 0 && state.needDrain) {\r\n            state.needDrain = false;\r\n            stream.emit('drain');\r\n          }\r\n        }\r\n\r\n        // if there's something in the buffer waiting, then process it\r\n        function clearBuffer(stream, state) {\r\n          state.bufferProcessing = true;\r\n          var entry = state.bufferedRequest;\r\n\r\n          if (stream._writev && entry && entry.next) {\r\n            // Fast case, write everything using _writev()\r\n            var l = state.bufferedRequestCount;\r\n            var buffer = new Array(l);\r\n            var holder = state.corkedRequestsFree;\r\n            holder.entry = entry;\r\n\r\n            var count = 0;\r\n            var allBuffers = true;\r\n            while (entry) {\r\n              buffer[count] = entry;\r\n              if (!entry.isBuf) allBuffers = false;\r\n              entry = entry.next;\r\n              count += 1;\r\n            }\r\n            buffer.allBuffers = allBuffers;\r\n\r\n            doWrite(stream, state, true, state.length, buffer, '', holder.finish);\r\n\r\n            // doWrite is almost always async, defer these to save a bit of time\r\n            // as the hot path ends with doWrite\r\n            state.pendingcb++;\r\n            state.lastBufferedRequest = null;\r\n            if (holder.next) {\r\n              state.corkedRequestsFree = holder.next;\r\n              holder.next = null;\r\n            } else {\r\n              state.corkedRequestsFree = new CorkedRequest(state);\r\n            }\r\n            state.bufferedRequestCount = 0;\r\n          } else {\r\n            // Slow case, write chunks one-by-one\r\n            while (entry) {\r\n              var chunk = entry.chunk;\r\n              var encoding = entry.encoding;\r\n              var cb = entry.callback;\r\n              var len = state.objectMode ? 1 : chunk.length;\r\n\r\n              doWrite(stream, state, false, len, chunk, encoding, cb);\r\n              entry = entry.next;\r\n              state.bufferedRequestCount--;\r\n              // if we didn't call the onwrite immediately, then\r\n              // it means that we need to wait until it does.\r\n              // also, that means that the chunk and cb are currently\r\n              // being processed, so move the buffer counter past them.\r\n              if (state.writing) {\r\n                break;\r\n              }\r\n            }\r\n\r\n            if (entry === null) state.lastBufferedRequest = null;\r\n          }\r\n\r\n          state.bufferedRequest = entry;\r\n          state.bufferProcessing = false;\r\n        }\r\n\r\n        Writable.prototype._write = function (chunk, encoding, cb) {\r\n          cb(new Error('_write() is not implemented'));\r\n        };\r\n\r\n        Writable.prototype._writev = null;\r\n\r\n        Writable.prototype.end = function (chunk, encoding, cb) {\r\n          var state = this._writableState;\r\n\r\n          if (typeof chunk === 'function') {\r\n            cb = chunk;\r\n            chunk = null;\r\n            encoding = null;\r\n          } else if (typeof encoding === 'function') {\r\n            cb = encoding;\r\n            encoding = null;\r\n          }\r\n\r\n          if (chunk !== null && chunk !== undefined) this.write(chunk, encoding);\r\n\r\n          // .end() fully uncorks\r\n          if (state.corked) {\r\n            state.corked = 1;\r\n            this.uncork();\r\n          }\r\n\r\n          // ignore unnecessary end() calls.\r\n          if (!state.ending && !state.finished) endWritable(this, state, cb);\r\n        };\r\n\r\n        function needFinish(state) {\r\n          return state.ending && state.length === 0 && state.bufferedRequest === null && !state.finished && !state.writing;\r\n        }\r\n\r\n        function callFinal(stream, state) {\r\n          stream._final(function (err) {\r\n            state.pendingcb--;\r\n            if (err) {\r\n              stream.emit('error', err);\r\n            }\r\n            state.prefinished = true;\r\n            stream.emit('prefinish');\r\n            finishMaybe(stream, state);\r\n          });\r\n        }\r\n\r\n        function prefinish(stream, state) {\r\n          if (!state.prefinished && !state.finalCalled) {\r\n            if (typeof stream._final === 'function') {\r\n              state.pendingcb++;\r\n              state.finalCalled = true;\r\n              pna.nextTick(callFinal, stream, state);\r\n            } else {\r\n              state.prefinished = true;\r\n              stream.emit('prefinish');\r\n            }\r\n          }\r\n        }\r\n\r\n        function finishMaybe(stream, state) {\r\n          var need = needFinish(state);\r\n          if (need) {\r\n            prefinish(stream, state);\r\n            if (state.pendingcb === 0) {\r\n              state.finished = true;\r\n              stream.emit('finish');\r\n            }\r\n          }\r\n          return need;\r\n        }\r\n\r\n        function endWritable(stream, state, cb) {\r\n          state.ending = true;\r\n          finishMaybe(stream, state);\r\n          if (cb) {\r\n            if (state.finished) pna.nextTick(cb);\r\n            else stream.once('finish', cb);\r\n          }\r\n          state.ended = true;\r\n          stream.writable = false;\r\n        }\r\n\r\n        function onCorkedFinish(corkReq, state, err) {\r\n          var entry = corkReq.entry;\r\n          corkReq.entry = null;\r\n          while (entry) {\r\n            var cb = entry.callback;\r\n            state.pendingcb--;\r\n            cb(err);\r\n            entry = entry.next;\r\n          }\r\n          if (state.corkedRequestsFree) {\r\n            state.corkedRequestsFree.next = corkReq;\r\n          } else {\r\n            state.corkedRequestsFree = corkReq;\r\n          }\r\n        }\r\n\r\n        Object.defineProperty(Writable.prototype, 'destroyed', {\r\n          get: function () {\r\n            if (this._writableState === undefined) {\r\n              return false;\r\n            }\r\n            return this._writableState.destroyed;\r\n          },\r\n          set: function (value) {\r\n            // we ignore the value if the stream\r\n            // has not been initialized yet\r\n            if (!this._writableState) {\r\n              return;\r\n            }\r\n\r\n            // backward compatibility, the user is explicitly\r\n            // managing destroyed\r\n            this._writableState.destroyed = value;\r\n          }\r\n        });\r\n\r\n        Writable.prototype.destroy = destroyImpl.destroy;\r\n        Writable.prototype._undestroy = destroyImpl.undestroy;\r\n        Writable.prototype._destroy = function (err, cb) {\r\n          this.end();\r\n          cb(err);\r\n        };\r\n      }).call(this, require('_process'), typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {}, require(\"timers\").setImmediate)\r\n    }, {\r\n      \"./_stream_duplex\": 134,\r\n      \"./internal/streams/destroy\": 140,\r\n      \"./internal/streams/stream\": 141,\r\n      \"_process\": 124,\r\n      \"core-util-is\": 56,\r\n      \"inherits\": 106,\r\n      \"process-nextick-args\": 123,\r\n      \"safe-buffer\": 147,\r\n      \"timers\": 158,\r\n      \"util-deprecate\": 159\r\n    }],\r\n    139: [function (require, module, exports) {\r\n      'use strict';\r\n\r\n      function _classCallCheck(instance, Constructor) {\r\n        if (!(instance instanceof Constructor)) {\r\n          throw new TypeError(\"Cannot call a class as a function\");\r\n        }\r\n      }\r\n\r\n      var Buffer = require('safe-buffer').Buffer;\r\n      var util = require('util');\r\n\r\n      function copyBuffer(src, target, offset) {\r\n        src.copy(target, offset);\r\n      }\r\n\r\n      module.exports = function () {\r\n        function BufferList() {\r\n          _classCallCheck(this, BufferList);\r\n\r\n          this.head = null;\r\n          this.tail = null;\r\n          this.length = 0;\r\n        }\r\n\r\n        BufferList.prototype.push = function push(v) {\r\n          var entry = {\r\n            data: v,\r\n            next: null\r\n          };\r\n          if (this.length > 0) this.tail.next = entry;\r\n          else this.head = entry;\r\n          this.tail = entry;\r\n          ++this.length;\r\n        };\r\n\r\n        BufferList.prototype.unshift = function unshift(v) {\r\n          var entry = {\r\n            data: v,\r\n            next: this.head\r\n          };\r\n          if (this.length === 0) this.tail = entry;\r\n          this.head = entry;\r\n          ++this.length;\r\n        };\r\n\r\n        BufferList.prototype.shift = function shift() {\r\n          if (this.length === 0) return;\r\n          var ret = this.head.data;\r\n          if (this.length === 1) this.head = this.tail = null;\r\n          else this.head = this.head.next;\r\n          --this.length;\r\n          return ret;\r\n        };\r\n\r\n        BufferList.prototype.clear = function clear() {\r\n          this.head = this.tail = null;\r\n          this.length = 0;\r\n        };\r\n\r\n        BufferList.prototype.join = function join(s) {\r\n          if (this.length === 0) return '';\r\n          var p = this.head;\r\n          var ret = '' + p.data;\r\n          while (p = p.next) {\r\n            ret += s + p.data;\r\n          }\r\n          return ret;\r\n        };\r\n\r\n        BufferList.prototype.concat = function concat(n) {\r\n          if (this.length === 0) return Buffer.alloc(0);\r\n          if (this.length === 1) return this.head.data;\r\n          var ret = Buffer.allocUnsafe(n >>> 0);\r\n          var p = this.head;\r\n          var i = 0;\r\n          while (p) {\r\n            copyBuffer(p.data, ret, i);\r\n            i += p.data.length;\r\n            p = p.next;\r\n          }\r\n          return ret;\r\n        };\r\n\r\n        return BufferList;\r\n      }();\r\n\r\n      if (util && util.inspect && util.inspect.custom) {\r\n        module.exports.prototype[util.inspect.custom] = function () {\r\n          var obj = util.inspect({\r\n            length: this.length\r\n          });\r\n          return this.constructor.name + ' ' + obj;\r\n        };\r\n      }\r\n    }, {\r\n      \"safe-buffer\": 147,\r\n      \"util\": 25\r\n    }],\r\n    140: [function (require, module, exports) {\r\n      'use strict';\r\n\r\n      /*<replacement>*/\r\n\r\n      var pna = require('process-nextick-args');\r\n      /*</replacement>*/\r\n\r\n      // undocumented cb() API, needed for core, not for public API\r\n      function destroy(err, cb) {\r\n        var _this = this;\r\n\r\n        var readableDestroyed = this._readableState && this._readableState.destroyed;\r\n        var writableDestroyed = this._writableState && this._writableState.destroyed;\r\n\r\n        if (readableDestroyed || writableDestroyed) {\r\n          if (cb) {\r\n            cb(err);\r\n          } else if (err && (!this._writableState || !this._writableState.errorEmitted)) {\r\n            pna.nextTick(emitErrorNT, this, err);\r\n          }\r\n          return this;\r\n        }\r\n\r\n        // we set destroyed to true before firing error callbacks in order\r\n        // to make it re-entrance safe in case destroy() is called within callbacks\r\n\r\n        if (this._readableState) {\r\n          this._readableState.destroyed = true;\r\n        }\r\n\r\n        // if this is a duplex stream mark the writable part as destroyed as well\r\n        if (this._writableState) {\r\n          this._writableState.destroyed = true;\r\n        }\r\n\r\n        this._destroy(err || null, function (err) {\r\n          if (!cb && err) {\r\n            pna.nextTick(emitErrorNT, _this, err);\r\n            if (_this._writableState) {\r\n              _this._writableState.errorEmitted = true;\r\n            }\r\n          } else if (cb) {\r\n            cb(err);\r\n          }\r\n        });\r\n\r\n        return this;\r\n      }\r\n\r\n      function undestroy() {\r\n        if (this._readableState) {\r\n          this._readableState.destroyed = false;\r\n          this._readableState.reading = false;\r\n          this._readableState.ended = false;\r\n          this._readableState.endEmitted = false;\r\n        }\r\n\r\n        if (this._writableState) {\r\n          this._writableState.destroyed = false;\r\n          this._writableState.ended = false;\r\n          this._writableState.ending = false;\r\n          this._writableState.finished = false;\r\n          this._writableState.errorEmitted = false;\r\n        }\r\n      }\r\n\r\n      function emitErrorNT(self, err) {\r\n        self.emit('error', err);\r\n      }\r\n\r\n      module.exports = {\r\n        destroy: destroy,\r\n        undestroy: undestroy\r\n      };\r\n    }, {\r\n      \"process-nextick-args\": 123\r\n    }],\r\n    141: [function (require, module, exports) {\r\n      module.exports = require('events').EventEmitter;\r\n\r\n    }, {\r\n      \"events\": 89\r\n    }],\r\n    142: [function (require, module, exports) {\r\n      module.exports = require('./readable').PassThrough\r\n\r\n    }, {\r\n      \"./readable\": 143\r\n    }],\r\n    143: [function (require, module, exports) {\r\n      exports = module.exports = require('./lib/_stream_readable.js');\r\n      exports.Stream = exports;\r\n      exports.Readable = exports;\r\n      exports.Writable = require('./lib/_stream_writable.js');\r\n      exports.Duplex = require('./lib/_stream_duplex.js');\r\n      exports.Transform = require('./lib/_stream_transform.js');\r\n      exports.PassThrough = require('./lib/_stream_passthrough.js');\r\n\r\n    }, {\r\n      \"./lib/_stream_duplex.js\": 134,\r\n      \"./lib/_stream_passthrough.js\": 135,\r\n      \"./lib/_stream_readable.js\": 136,\r\n      \"./lib/_stream_transform.js\": 137,\r\n      \"./lib/_stream_writable.js\": 138\r\n    }],\r\n    144: [function (require, module, exports) {\r\n      module.exports = require('./readable').Transform\r\n\r\n    }, {\r\n      \"./readable\": 143\r\n    }],\r\n    145: [function (require, module, exports) {\r\n      module.exports = require('./lib/_stream_writable.js');\r\n\r\n    }, {\r\n      \"./lib/_stream_writable.js\": 138\r\n    }],\r\n    146: [function (require, module, exports) {\r\n      'use strict'\r\n      var Buffer = require('buffer').Buffer\r\n      var inherits = require('inherits')\r\n      var HashBase = require('hash-base')\r\n\r\n      var ARRAY16 = new Array(16)\r\n\r\n      var zl = [\r\n        0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15,\r\n        7, 4, 13, 1, 10, 6, 15, 3, 12, 0, 9, 5, 2, 14, 11, 8,\r\n        3, 10, 14, 4, 9, 15, 8, 1, 2, 7, 0, 6, 13, 11, 5, 12,\r\n        1, 9, 11, 10, 0, 8, 12, 4, 13, 3, 7, 15, 14, 5, 6, 2,\r\n        4, 0, 5, 9, 7, 12, 2, 10, 14, 1, 3, 8, 11, 6, 15, 13\r\n      ]\r\n\r\n      var zr = [\r\n        5, 14, 7, 0, 9, 2, 11, 4, 13, 6, 15, 8, 1, 10, 3, 12,\r\n        6, 11, 3, 7, 0, 13, 5, 10, 14, 15, 8, 12, 4, 9, 1, 2,\r\n        15, 5, 1, 3, 7, 14, 6, 9, 11, 8, 12, 2, 10, 0, 4, 13,\r\n        8, 6, 4, 1, 3, 11, 15, 0, 5, 12, 2, 13, 9, 7, 10, 14,\r\n        12, 15, 10, 4, 1, 5, 8, 7, 6, 2, 13, 14, 0, 3, 9, 11\r\n      ]\r\n\r\n      var sl = [\r\n        11, 14, 15, 12, 5, 8, 7, 9, 11, 13, 14, 15, 6, 7, 9, 8,\r\n        7, 6, 8, 13, 11, 9, 7, 15, 7, 12, 15, 9, 11, 7, 13, 12,\r\n        11, 13, 6, 7, 14, 9, 13, 15, 14, 8, 13, 6, 5, 12, 7, 5,\r\n        11, 12, 14, 15, 14, 15, 9, 8, 9, 14, 5, 6, 8, 6, 5, 12,\r\n        9, 15, 5, 11, 6, 8, 13, 12, 5, 12, 13, 14, 11, 8, 5, 6\r\n      ]\r\n\r\n      var sr = [\r\n        8, 9, 9, 11, 13, 15, 15, 5, 7, 7, 8, 11, 14, 14, 12, 6,\r\n        9, 13, 15, 7, 12, 8, 9, 11, 7, 7, 12, 7, 6, 15, 13, 11,\r\n        9, 7, 15, 11, 8, 6, 6, 14, 12, 13, 5, 14, 13, 13, 7, 5,\r\n        15, 5, 8, 11, 14, 14, 6, 14, 6, 9, 12, 9, 12, 5, 15, 8,\r\n        8, 5, 12, 9, 12, 5, 14, 6, 8, 13, 6, 5, 15, 13, 11, 11\r\n      ]\r\n\r\n      var hl = [0x00000000, 0x5a827999, 0x6ed9eba1, 0x8f1bbcdc, 0xa953fd4e]\r\n      var hr = [0x50a28be6, 0x5c4dd124, 0x6d703ef3, 0x7a6d76e9, 0x00000000]\r\n\r\n      function RIPEMD160() {\r\n        HashBase.call(this, 64)\r\n\r\n        // state\r\n        this._a = 0x67452301\r\n        this._b = 0xefcdab89\r\n        this._c = 0x98badcfe\r\n        this._d = 0x10325476\r\n        this._e = 0xc3d2e1f0\r\n      }\r\n\r\n      inherits(RIPEMD160, HashBase)\r\n\r\n      RIPEMD160.prototype._update = function () {\r\n        var words = ARRAY16\r\n        for (var j = 0; j < 16; ++j) words[j] = this._block.readInt32LE(j * 4)\r\n\r\n        var al = this._a | 0\r\n        var bl = this._b | 0\r\n        var cl = this._c | 0\r\n        var dl = this._d | 0\r\n        var el = this._e | 0\r\n\r\n        var ar = this._a | 0\r\n        var br = this._b | 0\r\n        var cr = this._c | 0\r\n        var dr = this._d | 0\r\n        var er = this._e | 0\r\n\r\n        // computation\r\n        for (var i = 0; i < 80; i += 1) {\r\n          var tl\r\n          var tr\r\n          if (i < 16) {\r\n            tl = fn1(al, bl, cl, dl, el, words[zl[i]], hl[0], sl[i])\r\n            tr = fn5(ar, br, cr, dr, er, words[zr[i]], hr[0], sr[i])\r\n          } else if (i < 32) {\r\n            tl = fn2(al, bl, cl, dl, el, words[zl[i]], hl[1], sl[i])\r\n            tr = fn4(ar, br, cr, dr, er, words[zr[i]], hr[1], sr[i])\r\n          } else if (i < 48) {\r\n            tl = fn3(al, bl, cl, dl, el, words[zl[i]], hl[2], sl[i])\r\n            tr = fn3(ar, br, cr, dr, er, words[zr[i]], hr[2], sr[i])\r\n          } else if (i < 64) {\r\n            tl = fn4(al, bl, cl, dl, el, words[zl[i]], hl[3], sl[i])\r\n            tr = fn2(ar, br, cr, dr, er, words[zr[i]], hr[3], sr[i])\r\n          } else { // if (i<80) {\r\n            tl = fn5(al, bl, cl, dl, el, words[zl[i]], hl[4], sl[i])\r\n            tr = fn1(ar, br, cr, dr, er, words[zr[i]], hr[4], sr[i])\r\n          }\r\n\r\n          al = el\r\n          el = dl\r\n          dl = rotl(cl, 10)\r\n          cl = bl\r\n          bl = tl\r\n\r\n          ar = er\r\n          er = dr\r\n          dr = rotl(cr, 10)\r\n          cr = br\r\n          br = tr\r\n        }\r\n\r\n        // update state\r\n        var t = (this._b + cl + dr) | 0\r\n        this._b = (this._c + dl + er) | 0\r\n        this._c = (this._d + el + ar) | 0\r\n        this._d = (this._e + al + br) | 0\r\n        this._e = (this._a + bl + cr) | 0\r\n        this._a = t\r\n      }\r\n\r\n      RIPEMD160.prototype._digest = function () {\r\n        // create padding and handle blocks\r\n        this._block[this._blockOffset++] = 0x80\r\n        if (this._blockOffset > 56) {\r\n          this._block.fill(0, this._blockOffset, 64)\r\n          this._update()\r\n          this._blockOffset = 0\r\n        }\r\n\r\n        this._block.fill(0, this._blockOffset, 56)\r\n        this._block.writeUInt32LE(this._length[0], 56)\r\n        this._block.writeUInt32LE(this._length[1], 60)\r\n        this._update()\r\n\r\n        // produce result\r\n        var buffer = Buffer.alloc ? Buffer.alloc(20) : new Buffer(20)\r\n        buffer.writeInt32LE(this._a, 0)\r\n        buffer.writeInt32LE(this._b, 4)\r\n        buffer.writeInt32LE(this._c, 8)\r\n        buffer.writeInt32LE(this._d, 12)\r\n        buffer.writeInt32LE(this._e, 16)\r\n        return buffer\r\n      }\r\n\r\n      function rotl(x, n) {\r\n        return (x << n) | (x >>> (32 - n))\r\n      }\r\n\r\n      function fn1(a, b, c, d, e, m, k, s) {\r\n        return (rotl((a + (b ^ c ^ d) + m + k) | 0, s) + e) | 0\r\n      }\r\n\r\n      function fn2(a, b, c, d, e, m, k, s) {\r\n        return (rotl((a + ((b & c) | ((~b) & d)) + m + k) | 0, s) + e) | 0\r\n      }\r\n\r\n      function fn3(a, b, c, d, e, m, k, s) {\r\n        return (rotl((a + ((b | (~c)) ^ d) + m + k) | 0, s) + e) | 0\r\n      }\r\n\r\n      function fn4(a, b, c, d, e, m, k, s) {\r\n        return (rotl((a + ((b & d) | (c & (~d))) + m + k) | 0, s) + e) | 0\r\n      }\r\n\r\n      function fn5(a, b, c, d, e, m, k, s) {\r\n        return (rotl((a + (b ^ (c | (~d))) + m + k) | 0, s) + e) | 0\r\n      }\r\n\r\n      module.exports = RIPEMD160\r\n\r\n    }, {\r\n      \"buffer\": 54,\r\n      \"hash-base\": 91,\r\n      \"inherits\": 106\r\n    }],\r\n    147: [function (require, module, exports) {\r\n      /* eslint-disable node/no-deprecated-api */\r\n      var buffer = require('buffer')\r\n      var Buffer = buffer.Buffer\r\n\r\n      // alternative to using Object.keys for old browsers\r\n      function copyProps(src, dst) {\r\n        for (var key in src) {\r\n          dst[key] = src[key]\r\n        }\r\n      }\r\n      if (Buffer.from && Buffer.alloc && Buffer.allocUnsafe && Buffer.allocUnsafeSlow) {\r\n        module.exports = buffer\r\n      } else {\r\n        // Copy properties from require('buffer')\r\n        copyProps(buffer, exports)\r\n        exports.Buffer = SafeBuffer\r\n      }\r\n\r\n      function SafeBuffer(arg, encodingOrOffset, length) {\r\n        return Buffer(arg, encodingOrOffset, length)\r\n      }\r\n\r\n      // Copy static methods from Buffer\r\n      copyProps(Buffer, SafeBuffer)\r\n\r\n      SafeBuffer.from = function (arg, encodingOrOffset, length) {\r\n        if (typeof arg === 'number') {\r\n          throw new TypeError('Argument must not be a number')\r\n        }\r\n        return Buffer(arg, encodingOrOffset, length)\r\n      }\r\n\r\n      SafeBuffer.alloc = function (size, fill, encoding) {\r\n        if (typeof size !== 'number') {\r\n          throw new TypeError('Argument must be a number')\r\n        }\r\n        var buf = Buffer(size)\r\n        if (fill !== undefined) {\r\n          if (typeof encoding === 'string') {\r\n            buf.fill(fill, encoding)\r\n          } else {\r\n            buf.fill(fill)\r\n          }\r\n        } else {\r\n          buf.fill(0)\r\n        }\r\n        return buf\r\n      }\r\n\r\n      SafeBuffer.allocUnsafe = function (size) {\r\n        if (typeof size !== 'number') {\r\n          throw new TypeError('Argument must be a number')\r\n        }\r\n        return Buffer(size)\r\n      }\r\n\r\n      SafeBuffer.allocUnsafeSlow = function (size) {\r\n        if (typeof size !== 'number') {\r\n          throw new TypeError('Argument must be a number')\r\n        }\r\n        return buffer.SlowBuffer(size)\r\n      }\r\n\r\n    }, {\r\n      \"buffer\": 54\r\n    }],\r\n    148: [function (require, module, exports) {\r\n      var Buffer = require('safe-buffer').Buffer\r\n\r\n      // prototype class for hash functions\r\n      function Hash(blockSize, finalSize) {\r\n        this._block = Buffer.alloc(blockSize)\r\n        this._finalSize = finalSize\r\n        this._blockSize = blockSize\r\n        this._len = 0\r\n      }\r\n\r\n      Hash.prototype.update = function (data, enc) {\r\n        if (typeof data === 'string') {\r\n          enc = enc || 'utf8'\r\n          data = Buffer.from(data, enc)\r\n        }\r\n\r\n        var block = this._block\r\n        var blockSize = this._blockSize\r\n        var length = data.length\r\n        var accum = this._len\r\n\r\n        for (var offset = 0; offset < length;) {\r\n          var assigned = accum % blockSize\r\n          var remainder = Math.min(length - offset, blockSize - assigned)\r\n\r\n          for (var i = 0; i < remainder; i++) {\r\n            block[assigned + i] = data[offset + i]\r\n          }\r\n\r\n          accum += remainder\r\n          offset += remainder\r\n\r\n          if ((accum % blockSize) === 0) {\r\n            this._update(block)\r\n          }\r\n        }\r\n\r\n        this._len += length\r\n        return this\r\n      }\r\n\r\n      Hash.prototype.digest = function (enc) {\r\n        var rem = this._len % this._blockSize\r\n\r\n        this._block[rem] = 0x80\r\n\r\n        // zero (rem + 1) trailing bits, where (rem + 1) is the smallest\r\n        // non-negative solution to the equation (length + 1 + (rem + 1)) === finalSize mod blockSize\r\n        this._block.fill(0, rem + 1)\r\n\r\n        if (rem >= this._finalSize) {\r\n          this._update(this._block)\r\n          this._block.fill(0)\r\n        }\r\n\r\n        var bits = this._len * 8\r\n\r\n        // uint32\r\n        if (bits <= 0xffffffff) {\r\n          this._block.writeUInt32BE(bits, this._blockSize - 4)\r\n\r\n          // uint64\r\n        } else {\r\n          var lowBits = (bits & 0xffffffff) >>> 0\r\n          var highBits = (bits - lowBits) / 0x100000000\r\n\r\n          this._block.writeUInt32BE(highBits, this._blockSize - 8)\r\n          this._block.writeUInt32BE(lowBits, this._blockSize - 4)\r\n        }\r\n\r\n        this._update(this._block)\r\n        var hash = this._hash()\r\n\r\n        return enc ? hash.toString(enc) : hash\r\n      }\r\n\r\n      Hash.prototype._update = function () {\r\n        throw new Error('_update must be implemented by subclass')\r\n      }\r\n\r\n      module.exports = Hash\r\n\r\n    }, {\r\n      \"safe-buffer\": 147\r\n    }],\r\n    149: [function (require, module, exports) {\r\n      var exports = module.exports = function SHA(algorithm) {\r\n        algorithm = algorithm.toLowerCase()\r\n\r\n        var Algorithm = exports[algorithm]\r\n        if (!Algorithm) throw new Error(algorithm + ' is not supported (we accept pull requests)')\r\n\r\n        return new Algorithm()\r\n      }\r\n\r\n      exports.sha = require('./sha')\r\n      exports.sha1 = require('./sha1')\r\n      exports.sha224 = require('./sha224')\r\n      exports.sha256 = require('./sha256')\r\n      exports.sha384 = require('./sha384')\r\n      exports.sha512 = require('./sha512')\r\n\r\n    }, {\r\n      \"./sha\": 150,\r\n      \"./sha1\": 151,\r\n      \"./sha224\": 152,\r\n      \"./sha256\": 153,\r\n      \"./sha384\": 154,\r\n      \"./sha512\": 155\r\n    }],\r\n    150: [function (require, module, exports) {\r\n      /*\r\n       * A JavaScript implementation of the Secure Hash Algorithm, SHA-0, as defined\r\n       * in FIPS PUB 180-1\r\n       * This source code is derived from sha1.js of the same repository.\r\n       * The difference between SHA-0 and SHA-1 is just a bitwise rotate left\r\n       * operation was added.\r\n       */\r\n\r\n      var inherits = require('inherits')\r\n      var Hash = require('./hash')\r\n      var Buffer = require('safe-buffer').Buffer\r\n\r\n      var K = [\r\n        0x5a827999, 0x6ed9eba1, 0x8f1bbcdc | 0, 0xca62c1d6 | 0\r\n      ]\r\n\r\n      var W = new Array(80)\r\n\r\n      function Sha() {\r\n        this.init()\r\n        this._w = W\r\n\r\n        Hash.call(this, 64, 56)\r\n      }\r\n\r\n      inherits(Sha, Hash)\r\n\r\n      Sha.prototype.init = function () {\r\n        this._a = 0x67452301\r\n        this._b = 0xefcdab89\r\n        this._c = 0x98badcfe\r\n        this._d = 0x10325476\r\n        this._e = 0xc3d2e1f0\r\n\r\n        return this\r\n      }\r\n\r\n      function rotl5(num) {\r\n        return (num << 5) | (num >>> 27)\r\n      }\r\n\r\n      function rotl30(num) {\r\n        return (num << 30) | (num >>> 2)\r\n      }\r\n\r\n      function ft(s, b, c, d) {\r\n        if (s === 0) return (b & c) | ((~b) & d)\r\n        if (s === 2) return (b & c) | (b & d) | (c & d)\r\n        return b ^ c ^ d\r\n      }\r\n\r\n      Sha.prototype._update = function (M) {\r\n        var W = this._w\r\n\r\n        var a = this._a | 0\r\n        var b = this._b | 0\r\n        var c = this._c | 0\r\n        var d = this._d | 0\r\n        var e = this._e | 0\r\n\r\n        for (var i = 0; i < 16; ++i) W[i] = M.readInt32BE(i * 4)\r\n        for (; i < 80; ++i) W[i] = W[i - 3] ^ W[i - 8] ^ W[i - 14] ^ W[i - 16]\r\n\r\n        for (var j = 0; j < 80; ++j) {\r\n          var s = ~~(j / 20)\r\n          var t = (rotl5(a) + ft(s, b, c, d) + e + W[j] + K[s]) | 0\r\n\r\n          e = d\r\n          d = c\r\n          c = rotl30(b)\r\n          b = a\r\n          a = t\r\n        }\r\n\r\n        this._a = (a + this._a) | 0\r\n        this._b = (b + this._b) | 0\r\n        this._c = (c + this._c) | 0\r\n        this._d = (d + this._d) | 0\r\n        this._e = (e + this._e) | 0\r\n      }\r\n\r\n      Sha.prototype._hash = function () {\r\n        var H = Buffer.allocUnsafe(20)\r\n\r\n        H.writeInt32BE(this._a | 0, 0)\r\n        H.writeInt32BE(this._b | 0, 4)\r\n        H.writeInt32BE(this._c | 0, 8)\r\n        H.writeInt32BE(this._d | 0, 12)\r\n        H.writeInt32BE(this._e | 0, 16)\r\n\r\n        return H\r\n      }\r\n\r\n      module.exports = Sha\r\n\r\n    }, {\r\n      \"./hash\": 148,\r\n      \"inherits\": 106,\r\n      \"safe-buffer\": 147\r\n    }],\r\n    151: [function (require, module, exports) {\r\n      /*\r\n       * A JavaScript implementation of the Secure Hash Algorithm, SHA-1, as defined\r\n       * in FIPS PUB 180-1\r\n       * Version 2.1a Copyright Paul Johnston 2000 - 2002.\r\n       * Other contributors: Greg Holt, Andrew Kepert, Ydnar, Lostinet\r\n       * Distributed under the BSD License\r\n       * See http://pajhome.org.uk/crypt/md5 for details.\r\n       */\r\n\r\n      var inherits = require('inherits')\r\n      var Hash = require('./hash')\r\n      var Buffer = require('safe-buffer').Buffer\r\n\r\n      var K = [\r\n        0x5a827999, 0x6ed9eba1, 0x8f1bbcdc | 0, 0xca62c1d6 | 0\r\n      ]\r\n\r\n      var W = new Array(80)\r\n\r\n      function Sha1() {\r\n        this.init()\r\n        this._w = W\r\n\r\n        Hash.call(this, 64, 56)\r\n      }\r\n\r\n      inherits(Sha1, Hash)\r\n\r\n      Sha1.prototype.init = function () {\r\n        this._a = 0x67452301\r\n        this._b = 0xefcdab89\r\n        this._c = 0x98badcfe\r\n        this._d = 0x10325476\r\n        this._e = 0xc3d2e1f0\r\n\r\n        return this\r\n      }\r\n\r\n      function rotl1(num) {\r\n        return (num << 1) | (num >>> 31)\r\n      }\r\n\r\n      function rotl5(num) {\r\n        return (num << 5) | (num >>> 27)\r\n      }\r\n\r\n      function rotl30(num) {\r\n        return (num << 30) | (num >>> 2)\r\n      }\r\n\r\n      function ft(s, b, c, d) {\r\n        if (s === 0) return (b & c) | ((~b) & d)\r\n        if (s === 2) return (b & c) | (b & d) | (c & d)\r\n        return b ^ c ^ d\r\n      }\r\n\r\n      Sha1.prototype._update = function (M) {\r\n        var W = this._w\r\n\r\n        var a = this._a | 0\r\n        var b = this._b | 0\r\n        var c = this._c | 0\r\n        var d = this._d | 0\r\n        var e = this._e | 0\r\n\r\n        for (var i = 0; i < 16; ++i) W[i] = M.readInt32BE(i * 4)\r\n        for (; i < 80; ++i) W[i] = rotl1(W[i - 3] ^ W[i - 8] ^ W[i - 14] ^ W[i - 16])\r\n\r\n        for (var j = 0; j < 80; ++j) {\r\n          var s = ~~(j / 20)\r\n          var t = (rotl5(a) + ft(s, b, c, d) + e + W[j] + K[s]) | 0\r\n\r\n          e = d\r\n          d = c\r\n          c = rotl30(b)\r\n          b = a\r\n          a = t\r\n        }\r\n\r\n        this._a = (a + this._a) | 0\r\n        this._b = (b + this._b) | 0\r\n        this._c = (c + this._c) | 0\r\n        this._d = (d + this._d) | 0\r\n        this._e = (e + this._e) | 0\r\n      }\r\n\r\n      Sha1.prototype._hash = function () {\r\n        var H = Buffer.allocUnsafe(20)\r\n\r\n        H.writeInt32BE(this._a | 0, 0)\r\n        H.writeInt32BE(this._b | 0, 4)\r\n        H.writeInt32BE(this._c | 0, 8)\r\n        H.writeInt32BE(this._d | 0, 12)\r\n        H.writeInt32BE(this._e | 0, 16)\r\n\r\n        return H\r\n      }\r\n\r\n      module.exports = Sha1\r\n\r\n    }, {\r\n      \"./hash\": 148,\r\n      \"inherits\": 106,\r\n      \"safe-buffer\": 147\r\n    }],\r\n    152: [function (require, module, exports) {\r\n      /**\r\n       * A JavaScript implementation of the Secure Hash Algorithm, SHA-256, as defined\r\n       * in FIPS 180-2\r\n       * Version 2.2-beta Copyright Angel Marin, Paul Johnston 2000 - 2009.\r\n       * Other contributors: Greg Holt, Andrew Kepert, Ydnar, Lostinet\r\n       *\r\n       */\r\n\r\n      var inherits = require('inherits')\r\n      var Sha256 = require('./sha256')\r\n      var Hash = require('./hash')\r\n      var Buffer = require('safe-buffer').Buffer\r\n\r\n      var W = new Array(64)\r\n\r\n      function Sha224() {\r\n        this.init()\r\n\r\n        this._w = W // new Array(64)\r\n\r\n        Hash.call(this, 64, 56)\r\n      }\r\n\r\n      inherits(Sha224, Sha256)\r\n\r\n      Sha224.prototype.init = function () {\r\n        this._a = 0xc1059ed8\r\n        this._b = 0x367cd507\r\n        this._c = 0x3070dd17\r\n        this._d = 0xf70e5939\r\n        this._e = 0xffc00b31\r\n        this._f = 0x68581511\r\n        this._g = 0x64f98fa7\r\n        this._h = 0xbefa4fa4\r\n\r\n        return this\r\n      }\r\n\r\n      Sha224.prototype._hash = function () {\r\n        var H = Buffer.allocUnsafe(28)\r\n\r\n        H.writeInt32BE(this._a, 0)\r\n        H.writeInt32BE(this._b, 4)\r\n        H.writeInt32BE(this._c, 8)\r\n        H.writeInt32BE(this._d, 12)\r\n        H.writeInt32BE(this._e, 16)\r\n        H.writeInt32BE(this._f, 20)\r\n        H.writeInt32BE(this._g, 24)\r\n\r\n        return H\r\n      }\r\n\r\n      module.exports = Sha224\r\n\r\n    }, {\r\n      \"./hash\": 148,\r\n      \"./sha256\": 153,\r\n      \"inherits\": 106,\r\n      \"safe-buffer\": 147\r\n    }],\r\n    153: [function (require, module, exports) {\r\n      /**\r\n       * A JavaScript implementation of the Secure Hash Algorithm, SHA-256, as defined\r\n       * in FIPS 180-2\r\n       * Version 2.2-beta Copyright Angel Marin, Paul Johnston 2000 - 2009.\r\n       * Other contributors: Greg Holt, Andrew Kepert, Ydnar, Lostinet\r\n       *\r\n       */\r\n\r\n      var inherits = require('inherits')\r\n      var Hash = require('./hash')\r\n      var Buffer = require('safe-buffer').Buffer\r\n\r\n      var K = [\r\n        0x428A2F98, 0x71374491, 0xB5C0FBCF, 0xE9B5DBA5,\r\n        0x3956C25B, 0x59F111F1, 0x923F82A4, 0xAB1C5ED5,\r\n        0xD807AA98, 0x12835B01, 0x243185BE, 0x550C7DC3,\r\n        0x72BE5D74, 0x80DEB1FE, 0x9BDC06A7, 0xC19BF174,\r\n        0xE49B69C1, 0xEFBE4786, 0x0FC19DC6, 0x240CA1CC,\r\n        0x2DE92C6F, 0x4A7484AA, 0x5CB0A9DC, 0x76F988DA,\r\n        0x983E5152, 0xA831C66D, 0xB00327C8, 0xBF597FC7,\r\n        0xC6E00BF3, 0xD5A79147, 0x06CA6351, 0x14292967,\r\n        0x27B70A85, 0x2E1B2138, 0x4D2C6DFC, 0x53380D13,\r\n        0x650A7354, 0x766A0ABB, 0x81C2C92E, 0x92722C85,\r\n        0xA2BFE8A1, 0xA81A664B, 0xC24B8B70, 0xC76C51A3,\r\n        0xD192E819, 0xD6990624, 0xF40E3585, 0x106AA070,\r\n        0x19A4C116, 0x1E376C08, 0x2748774C, 0x34B0BCB5,\r\n        0x391C0CB3, 0x4ED8AA4A, 0x5B9CCA4F, 0x682E6FF3,\r\n        0x748F82EE, 0x78A5636F, 0x84C87814, 0x8CC70208,\r\n        0x90BEFFFA, 0xA4506CEB, 0xBEF9A3F7, 0xC67178F2\r\n      ]\r\n\r\n      var W = new Array(64)\r\n\r\n      function Sha256() {\r\n        this.init()\r\n\r\n        this._w = W // new Array(64)\r\n\r\n        Hash.call(this, 64, 56)\r\n      }\r\n\r\n      inherits(Sha256, Hash)\r\n\r\n      Sha256.prototype.init = function () {\r\n        this._a = 0x6a09e667\r\n        this._b = 0xbb67ae85\r\n        this._c = 0x3c6ef372\r\n        this._d = 0xa54ff53a\r\n        this._e = 0x510e527f\r\n        this._f = 0x9b05688c\r\n        this._g = 0x1f83d9ab\r\n        this._h = 0x5be0cd19\r\n\r\n        return this\r\n      }\r\n\r\n      function ch(x, y, z) {\r\n        return z ^ (x & (y ^ z))\r\n      }\r\n\r\n      function maj(x, y, z) {\r\n        return (x & y) | (z & (x | y))\r\n      }\r\n\r\n      function sigma0(x) {\r\n        return (x >>> 2 | x << 30) ^ (x >>> 13 | x << 19) ^ (x >>> 22 | x << 10)\r\n      }\r\n\r\n      function sigma1(x) {\r\n        return (x >>> 6 | x << 26) ^ (x >>> 11 | x << 21) ^ (x >>> 25 | x << 7)\r\n      }\r\n\r\n      function gamma0(x) {\r\n        return (x >>> 7 | x << 25) ^ (x >>> 18 | x << 14) ^ (x >>> 3)\r\n      }\r\n\r\n      function gamma1(x) {\r\n        return (x >>> 17 | x << 15) ^ (x >>> 19 | x << 13) ^ (x >>> 10)\r\n      }\r\n\r\n      Sha256.prototype._update = function (M) {\r\n        var W = this._w\r\n\r\n        var a = this._a | 0\r\n        var b = this._b | 0\r\n        var c = this._c | 0\r\n        var d = this._d | 0\r\n        var e = this._e | 0\r\n        var f = this._f | 0\r\n        var g = this._g | 0\r\n        var h = this._h | 0\r\n\r\n        for (var i = 0; i < 16; ++i) W[i] = M.readInt32BE(i * 4)\r\n        for (; i < 64; ++i) W[i] = (gamma1(W[i - 2]) + W[i - 7] + gamma0(W[i - 15]) + W[i - 16]) | 0\r\n\r\n        for (var j = 0; j < 64; ++j) {\r\n          var T1 = (h + sigma1(e) + ch(e, f, g) + K[j] + W[j]) | 0\r\n          var T2 = (sigma0(a) + maj(a, b, c)) | 0\r\n\r\n          h = g\r\n          g = f\r\n          f = e\r\n          e = (d + T1) | 0\r\n          d = c\r\n          c = b\r\n          b = a\r\n          a = (T1 + T2) | 0\r\n        }\r\n\r\n        this._a = (a + this._a) | 0\r\n        this._b = (b + this._b) | 0\r\n        this._c = (c + this._c) | 0\r\n        this._d = (d + this._d) | 0\r\n        this._e = (e + this._e) | 0\r\n        this._f = (f + this._f) | 0\r\n        this._g = (g + this._g) | 0\r\n        this._h = (h + this._h) | 0\r\n      }\r\n\r\n      Sha256.prototype._hash = function () {\r\n        var H = Buffer.allocUnsafe(32)\r\n\r\n        H.writeInt32BE(this._a, 0)\r\n        H.writeInt32BE(this._b, 4)\r\n        H.writeInt32BE(this._c, 8)\r\n        H.writeInt32BE(this._d, 12)\r\n        H.writeInt32BE(this._e, 16)\r\n        H.writeInt32BE(this._f, 20)\r\n        H.writeInt32BE(this._g, 24)\r\n        H.writeInt32BE(this._h, 28)\r\n\r\n        return H\r\n      }\r\n\r\n      module.exports = Sha256\r\n\r\n    }, {\r\n      \"./hash\": 148,\r\n      \"inherits\": 106,\r\n      \"safe-buffer\": 147\r\n    }],\r\n    154: [function (require, module, exports) {\r\n      var inherits = require('inherits')\r\n      var SHA512 = require('./sha512')\r\n      var Hash = require('./hash')\r\n      var Buffer = require('safe-buffer').Buffer\r\n\r\n      var W = new Array(160)\r\n\r\n      function Sha384() {\r\n        this.init()\r\n        this._w = W\r\n\r\n        Hash.call(this, 128, 112)\r\n      }\r\n\r\n      inherits(Sha384, SHA512)\r\n\r\n      Sha384.prototype.init = function () {\r\n        this._ah = 0xcbbb9d5d\r\n        this._bh = 0x629a292a\r\n        this._ch = 0x9159015a\r\n        this._dh = 0x152fecd8\r\n        this._eh = 0x67332667\r\n        this._fh = 0x8eb44a87\r\n        this._gh = 0xdb0c2e0d\r\n        this._hh = 0x47b5481d\r\n\r\n        this._al = 0xc1059ed8\r\n        this._bl = 0x367cd507\r\n        this._cl = 0x3070dd17\r\n        this._dl = 0xf70e5939\r\n        this._el = 0xffc00b31\r\n        this._fl = 0x68581511\r\n        this._gl = 0x64f98fa7\r\n        this._hl = 0xbefa4fa4\r\n\r\n        return this\r\n      }\r\n\r\n      Sha384.prototype._hash = function () {\r\n        var H = Buffer.allocUnsafe(48)\r\n\r\n        function writeInt64BE(h, l, offset) {\r\n          H.writeInt32BE(h, offset)\r\n          H.writeInt32BE(l, offset + 4)\r\n        }\r\n\r\n        writeInt64BE(this._ah, this._al, 0)\r\n        writeInt64BE(this._bh, this._bl, 8)\r\n        writeInt64BE(this._ch, this._cl, 16)\r\n        writeInt64BE(this._dh, this._dl, 24)\r\n        writeInt64BE(this._eh, this._el, 32)\r\n        writeInt64BE(this._fh, this._fl, 40)\r\n\r\n        return H\r\n      }\r\n\r\n      module.exports = Sha384\r\n\r\n    }, {\r\n      \"./hash\": 148,\r\n      \"./sha512\": 155,\r\n      \"inherits\": 106,\r\n      \"safe-buffer\": 147\r\n    }],\r\n    155: [function (require, module, exports) {\r\n      var inherits = require('inherits')\r\n      var Hash = require('./hash')\r\n      var Buffer = require('safe-buffer').Buffer\r\n\r\n      var K = [\r\n        0x428a2f98, 0xd728ae22, 0x71374491, 0x23ef65cd,\r\n        0xb5c0fbcf, 0xec4d3b2f, 0xe9b5dba5, 0x8189dbbc,\r\n        0x3956c25b, 0xf348b538, 0x59f111f1, 0xb605d019,\r\n        0x923f82a4, 0xaf194f9b, 0xab1c5ed5, 0xda6d8118,\r\n        0xd807aa98, 0xa3030242, 0x12835b01, 0x45706fbe,\r\n        0x243185be, 0x4ee4b28c, 0x550c7dc3, 0xd5ffb4e2,\r\n        0x72be5d74, 0xf27b896f, 0x80deb1fe, 0x3b1696b1,\r\n        0x9bdc06a7, 0x25c71235, 0xc19bf174, 0xcf692694,\r\n        0xe49b69c1, 0x9ef14ad2, 0xefbe4786, 0x384f25e3,\r\n        0x0fc19dc6, 0x8b8cd5b5, 0x240ca1cc, 0x77ac9c65,\r\n        0x2de92c6f, 0x592b0275, 0x4a7484aa, 0x6ea6e483,\r\n        0x5cb0a9dc, 0xbd41fbd4, 0x76f988da, 0x831153b5,\r\n        0x983e5152, 0xee66dfab, 0xa831c66d, 0x2db43210,\r\n        0xb00327c8, 0x98fb213f, 0xbf597fc7, 0xbeef0ee4,\r\n        0xc6e00bf3, 0x3da88fc2, 0xd5a79147, 0x930aa725,\r\n        0x06ca6351, 0xe003826f, 0x14292967, 0x0a0e6e70,\r\n        0x27b70a85, 0x46d22ffc, 0x2e1b2138, 0x5c26c926,\r\n        0x4d2c6dfc, 0x5ac42aed, 0x53380d13, 0x9d95b3df,\r\n        0x650a7354, 0x8baf63de, 0x766a0abb, 0x3c77b2a8,\r\n        0x81c2c92e, 0x47edaee6, 0x92722c85, 0x1482353b,\r\n        0xa2bfe8a1, 0x4cf10364, 0xa81a664b, 0xbc423001,\r\n        0xc24b8b70, 0xd0f89791, 0xc76c51a3, 0x0654be30,\r\n        0xd192e819, 0xd6ef5218, 0xd6990624, 0x5565a910,\r\n        0xf40e3585, 0x5771202a, 0x106aa070, 0x32bbd1b8,\r\n        0x19a4c116, 0xb8d2d0c8, 0x1e376c08, 0x5141ab53,\r\n        0x2748774c, 0xdf8eeb99, 0x34b0bcb5, 0xe19b48a8,\r\n        0x391c0cb3, 0xc5c95a63, 0x4ed8aa4a, 0xe3418acb,\r\n        0x5b9cca4f, 0x7763e373, 0x682e6ff3, 0xd6b2b8a3,\r\n        0x748f82ee, 0x5defb2fc, 0x78a5636f, 0x43172f60,\r\n        0x84c87814, 0xa1f0ab72, 0x8cc70208, 0x1a6439ec,\r\n        0x90befffa, 0x23631e28, 0xa4506ceb, 0xde82bde9,\r\n        0xbef9a3f7, 0xb2c67915, 0xc67178f2, 0xe372532b,\r\n        0xca273ece, 0xea26619c, 0xd186b8c7, 0x21c0c207,\r\n        0xeada7dd6, 0xcde0eb1e, 0xf57d4f7f, 0xee6ed178,\r\n        0x06f067aa, 0x72176fba, 0x0a637dc5, 0xa2c898a6,\r\n        0x113f9804, 0xbef90dae, 0x1b710b35, 0x131c471b,\r\n        0x28db77f5, 0x23047d84, 0x32caab7b, 0x40c72493,\r\n        0x3c9ebe0a, 0x15c9bebc, 0x431d67c4, 0x9c100d4c,\r\n        0x4cc5d4be, 0xcb3e42b6, 0x597f299c, 0xfc657e2a,\r\n        0x5fcb6fab, 0x3ad6faec, 0x6c44198c, 0x4a475817\r\n      ]\r\n\r\n      var W = new Array(160)\r\n\r\n      function Sha512() {\r\n        this.init()\r\n        this._w = W\r\n\r\n        Hash.call(this, 128, 112)\r\n      }\r\n\r\n      inherits(Sha512, Hash)\r\n\r\n      Sha512.prototype.init = function () {\r\n        this._ah = 0x6a09e667\r\n        this._bh = 0xbb67ae85\r\n        this._ch = 0x3c6ef372\r\n        this._dh = 0xa54ff53a\r\n        this._eh = 0x510e527f\r\n        this._fh = 0x9b05688c\r\n        this._gh = 0x1f83d9ab\r\n        this._hh = 0x5be0cd19\r\n\r\n        this._al = 0xf3bcc908\r\n        this._bl = 0x84caa73b\r\n        this._cl = 0xfe94f82b\r\n        this._dl = 0x5f1d36f1\r\n        this._el = 0xade682d1\r\n        this._fl = 0x2b3e6c1f\r\n        this._gl = 0xfb41bd6b\r\n        this._hl = 0x137e2179\r\n\r\n        return this\r\n      }\r\n\r\n      function Ch(x, y, z) {\r\n        return z ^ (x & (y ^ z))\r\n      }\r\n\r\n      function maj(x, y, z) {\r\n        return (x & y) | (z & (x | y))\r\n      }\r\n\r\n      function sigma0(x, xl) {\r\n        return (x >>> 28 | xl << 4) ^ (xl >>> 2 | x << 30) ^ (xl >>> 7 | x << 25)\r\n      }\r\n\r\n      function sigma1(x, xl) {\r\n        return (x >>> 14 | xl << 18) ^ (x >>> 18 | xl << 14) ^ (xl >>> 9 | x << 23)\r\n      }\r\n\r\n      function Gamma0(x, xl) {\r\n        return (x >>> 1 | xl << 31) ^ (x >>> 8 | xl << 24) ^ (x >>> 7)\r\n      }\r\n\r\n      function Gamma0l(x, xl) {\r\n        return (x >>> 1 | xl << 31) ^ (x >>> 8 | xl << 24) ^ (x >>> 7 | xl << 25)\r\n      }\r\n\r\n      function Gamma1(x, xl) {\r\n        return (x >>> 19 | xl << 13) ^ (xl >>> 29 | x << 3) ^ (x >>> 6)\r\n      }\r\n\r\n      function Gamma1l(x, xl) {\r\n        return (x >>> 19 | xl << 13) ^ (xl >>> 29 | x << 3) ^ (x >>> 6 | xl << 26)\r\n      }\r\n\r\n      function getCarry(a, b) {\r\n        return (a >>> 0) < (b >>> 0) ? 1 : 0\r\n      }\r\n\r\n      Sha512.prototype._update = function (M) {\r\n        var W = this._w\r\n\r\n        var ah = this._ah | 0\r\n        var bh = this._bh | 0\r\n        var ch = this._ch | 0\r\n        var dh = this._dh | 0\r\n        var eh = this._eh | 0\r\n        var fh = this._fh | 0\r\n        var gh = this._gh | 0\r\n        var hh = this._hh | 0\r\n\r\n        var al = this._al | 0\r\n        var bl = this._bl | 0\r\n        var cl = this._cl | 0\r\n        var dl = this._dl | 0\r\n        var el = this._el | 0\r\n        var fl = this._fl | 0\r\n        var gl = this._gl | 0\r\n        var hl = this._hl | 0\r\n\r\n        for (var i = 0; i < 32; i += 2) {\r\n          W[i] = M.readInt32BE(i * 4)\r\n          W[i + 1] = M.readInt32BE(i * 4 + 4)\r\n        }\r\n        for (; i < 160; i += 2) {\r\n          var xh = W[i - 15 * 2]\r\n          var xl = W[i - 15 * 2 + 1]\r\n          var gamma0 = Gamma0(xh, xl)\r\n          var gamma0l = Gamma0l(xl, xh)\r\n\r\n          xh = W[i - 2 * 2]\r\n          xl = W[i - 2 * 2 + 1]\r\n          var gamma1 = Gamma1(xh, xl)\r\n          var gamma1l = Gamma1l(xl, xh)\r\n\r\n          // W[i] = gamma0 + W[i - 7] + gamma1 + W[i - 16]\r\n          var Wi7h = W[i - 7 * 2]\r\n          var Wi7l = W[i - 7 * 2 + 1]\r\n\r\n          var Wi16h = W[i - 16 * 2]\r\n          var Wi16l = W[i - 16 * 2 + 1]\r\n\r\n          var Wil = (gamma0l + Wi7l) | 0\r\n          var Wih = (gamma0 + Wi7h + getCarry(Wil, gamma0l)) | 0\r\n          Wil = (Wil + gamma1l) | 0\r\n          Wih = (Wih + gamma1 + getCarry(Wil, gamma1l)) | 0\r\n          Wil = (Wil + Wi16l) | 0\r\n          Wih = (Wih + Wi16h + getCarry(Wil, Wi16l)) | 0\r\n\r\n          W[i] = Wih\r\n          W[i + 1] = Wil\r\n        }\r\n\r\n        for (var j = 0; j < 160; j += 2) {\r\n          Wih = W[j]\r\n          Wil = W[j + 1]\r\n\r\n          var majh = maj(ah, bh, ch)\r\n          var majl = maj(al, bl, cl)\r\n\r\n          var sigma0h = sigma0(ah, al)\r\n          var sigma0l = sigma0(al, ah)\r\n          var sigma1h = sigma1(eh, el)\r\n          var sigma1l = sigma1(el, eh)\r\n\r\n          // t1 = h + sigma1 + ch + K[j] + W[j]\r\n          var Kih = K[j]\r\n          var Kil = K[j + 1]\r\n\r\n          var chh = Ch(eh, fh, gh)\r\n          var chl = Ch(el, fl, gl)\r\n\r\n          var t1l = (hl + sigma1l) | 0\r\n          var t1h = (hh + sigma1h + getCarry(t1l, hl)) | 0\r\n          t1l = (t1l + chl) | 0\r\n          t1h = (t1h + chh + getCarry(t1l, chl)) | 0\r\n          t1l = (t1l + Kil) | 0\r\n          t1h = (t1h + Kih + getCarry(t1l, Kil)) | 0\r\n          t1l = (t1l + Wil) | 0\r\n          t1h = (t1h + Wih + getCarry(t1l, Wil)) | 0\r\n\r\n          // t2 = sigma0 + maj\r\n          var t2l = (sigma0l + majl) | 0\r\n          var t2h = (sigma0h + majh + getCarry(t2l, sigma0l)) | 0\r\n\r\n          hh = gh\r\n          hl = gl\r\n          gh = fh\r\n          gl = fl\r\n          fh = eh\r\n          fl = el\r\n          el = (dl + t1l) | 0\r\n          eh = (dh + t1h + getCarry(el, dl)) | 0\r\n          dh = ch\r\n          dl = cl\r\n          ch = bh\r\n          cl = bl\r\n          bh = ah\r\n          bl = al\r\n          al = (t1l + t2l) | 0\r\n          ah = (t1h + t2h + getCarry(al, t1l)) | 0\r\n        }\r\n\r\n        this._al = (this._al + al) | 0\r\n        this._bl = (this._bl + bl) | 0\r\n        this._cl = (this._cl + cl) | 0\r\n        this._dl = (this._dl + dl) | 0\r\n        this._el = (this._el + el) | 0\r\n        this._fl = (this._fl + fl) | 0\r\n        this._gl = (this._gl + gl) | 0\r\n        this._hl = (this._hl + hl) | 0\r\n\r\n        this._ah = (this._ah + ah + getCarry(this._al, al)) | 0\r\n        this._bh = (this._bh + bh + getCarry(this._bl, bl)) | 0\r\n        this._ch = (this._ch + ch + getCarry(this._cl, cl)) | 0\r\n        this._dh = (this._dh + dh + getCarry(this._dl, dl)) | 0\r\n        this._eh = (this._eh + eh + getCarry(this._el, el)) | 0\r\n        this._fh = (this._fh + fh + getCarry(this._fl, fl)) | 0\r\n        this._gh = (this._gh + gh + getCarry(this._gl, gl)) | 0\r\n        this._hh = (this._hh + hh + getCarry(this._hl, hl)) | 0\r\n      }\r\n\r\n      Sha512.prototype._hash = function () {\r\n        var H = Buffer.allocUnsafe(64)\r\n\r\n        function writeInt64BE(h, l, offset) {\r\n          H.writeInt32BE(h, offset)\r\n          H.writeInt32BE(l, offset + 4)\r\n        }\r\n\r\n        writeInt64BE(this._ah, this._al, 0)\r\n        writeInt64BE(this._bh, this._bl, 8)\r\n        writeInt64BE(this._ch, this._cl, 16)\r\n        writeInt64BE(this._dh, this._dl, 24)\r\n        writeInt64BE(this._eh, this._el, 32)\r\n        writeInt64BE(this._fh, this._fl, 40)\r\n        writeInt64BE(this._gh, this._gl, 48)\r\n        writeInt64BE(this._hh, this._hl, 56)\r\n\r\n        return H\r\n      }\r\n\r\n      module.exports = Sha512\r\n\r\n    }, {\r\n      \"./hash\": 148,\r\n      \"inherits\": 106,\r\n      \"safe-buffer\": 147\r\n    }],\r\n    156: [function (require, module, exports) {\r\n      // Copyright Joyent, Inc. and other Node contributors.\r\n      //\r\n      // Permission is hereby granted, free of charge, to any person obtaining a\r\n      // copy of this software and associated documentation files (the\r\n      // \"Software\"), to deal in the Software without restriction, including\r\n      // without limitation the rights to use, copy, modify, merge, publish,\r\n      // distribute, sublicense, and/or sell copies of the Software, and to permit\r\n      // persons to whom the Software is furnished to do so, subject to the\r\n      // following conditions:\r\n      //\r\n      // The above copyright notice and this permission notice shall be included\r\n      // in all copies or substantial portions of the Software.\r\n      //\r\n      // THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\r\n      // OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\r\n      // MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\r\n      // NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\r\n      // DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\r\n      // OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\r\n      // USE OR OTHER DEALINGS IN THE SOFTWARE.\r\n\r\n      module.exports = Stream;\r\n\r\n      var EE = require('events').EventEmitter;\r\n      var inherits = require('inherits');\r\n\r\n      inherits(Stream, EE);\r\n      Stream.Readable = require('readable-stream/readable.js');\r\n      Stream.Writable = require('readable-stream/writable.js');\r\n      Stream.Duplex = require('readable-stream/duplex.js');\r\n      Stream.Transform = require('readable-stream/transform.js');\r\n      Stream.PassThrough = require('readable-stream/passthrough.js');\r\n\r\n      // Backwards-compat with node 0.4.x\r\n      Stream.Stream = Stream;\r\n\r\n\r\n\r\n      // old-style streams.  Note that the pipe method (the only relevant\r\n      // part of this class) is overridden in the Readable class.\r\n\r\n      function Stream() {\r\n        EE.call(this);\r\n      }\r\n\r\n      Stream.prototype.pipe = function (dest, options) {\r\n        var source = this;\r\n\r\n        function ondata(chunk) {\r\n          if (dest.writable) {\r\n            if (false === dest.write(chunk) && source.pause) {\r\n              source.pause();\r\n            }\r\n          }\r\n        }\r\n\r\n        source.on('data', ondata);\r\n\r\n        function ondrain() {\r\n          if (source.readable && source.resume) {\r\n            source.resume();\r\n          }\r\n        }\r\n\r\n        dest.on('drain', ondrain);\r\n\r\n        // If the 'end' option is not supplied, dest.end() will be called when\r\n        // source gets the 'end' or 'close' events.  Only dest.end() once.\r\n        if (!dest._isStdio && (!options || options.end !== false)) {\r\n          source.on('end', onend);\r\n          source.on('close', onclose);\r\n        }\r\n\r\n        var didOnEnd = false;\r\n\r\n        function onend() {\r\n          if (didOnEnd) return;\r\n          didOnEnd = true;\r\n\r\n          dest.end();\r\n        }\r\n\r\n\r\n        function onclose() {\r\n          if (didOnEnd) return;\r\n          didOnEnd = true;\r\n\r\n          if (typeof dest.destroy === 'function') dest.destroy();\r\n        }\r\n\r\n        // don't leave dangling pipes when there are errors.\r\n        function onerror(er) {\r\n          cleanup();\r\n          if (EE.listenerCount(this, 'error') === 0) {\r\n            throw er; // Unhandled stream error in pipe.\r\n          }\r\n        }\r\n\r\n        source.on('error', onerror);\r\n        dest.on('error', onerror);\r\n\r\n        // remove all the event listeners that were added.\r\n        function cleanup() {\r\n          source.removeListener('data', ondata);\r\n          dest.removeListener('drain', ondrain);\r\n\r\n          source.removeListener('end', onend);\r\n          source.removeListener('close', onclose);\r\n\r\n          source.removeListener('error', onerror);\r\n          dest.removeListener('error', onerror);\r\n\r\n          source.removeListener('end', cleanup);\r\n          source.removeListener('close', cleanup);\r\n\r\n          dest.removeListener('close', cleanup);\r\n        }\r\n\r\n        source.on('end', cleanup);\r\n        source.on('close', cleanup);\r\n\r\n        dest.on('close', cleanup);\r\n\r\n        dest.emit('pipe', source);\r\n\r\n        // Allow for unix-like usage: A.pipe(B).pipe(C)\r\n        return dest;\r\n      };\r\n\r\n    }, {\r\n      \"events\": 89,\r\n      \"inherits\": 106,\r\n      \"readable-stream/duplex.js\": 133,\r\n      \"readable-stream/passthrough.js\": 142,\r\n      \"readable-stream/readable.js\": 143,\r\n      \"readable-stream/transform.js\": 144,\r\n      \"readable-stream/writable.js\": 145\r\n    }],\r\n    157: [function (require, module, exports) {\r\n      // Copyright Joyent, Inc. and other Node contributors.\r\n      //\r\n      // Permission is hereby granted, free of charge, to any person obtaining a\r\n      // copy of this software and associated documentation files (the\r\n      // \"Software\"), to deal in the Software without restriction, including\r\n      // without limitation the rights to use, copy, modify, merge, publish,\r\n      // distribute, sublicense, and/or sell copies of the Software, and to permit\r\n      // persons to whom the Software is furnished to do so, subject to the\r\n      // following conditions:\r\n      //\r\n      // The above copyright notice and this permission notice shall be included\r\n      // in all copies or substantial portions of the Software.\r\n      //\r\n      // THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\r\n      // OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\r\n      // MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\r\n      // NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\r\n      // DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\r\n      // OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\r\n      // USE OR OTHER DEALINGS IN THE SOFTWARE.\r\n\r\n      'use strict';\r\n\r\n      /*<replacement>*/\r\n\r\n      var Buffer = require('safe-buffer').Buffer;\r\n      /*</replacement>*/\r\n\r\n      var isEncoding = Buffer.isEncoding || function (encoding) {\r\n        encoding = '' + encoding;\r\n        switch (encoding && encoding.toLowerCase()) {\r\n          case 'hex':\r\n          case 'utf8':\r\n          case 'utf-8':\r\n          case 'ascii':\r\n          case 'binary':\r\n          case 'base64':\r\n          case 'ucs2':\r\n          case 'ucs-2':\r\n          case 'utf16le':\r\n          case 'utf-16le':\r\n          case 'raw':\r\n            return true;\r\n          default:\r\n            return false;\r\n        }\r\n      };\r\n\r\n      function _normalizeEncoding(enc) {\r\n        if (!enc) return 'utf8';\r\n        var retried;\r\n        while (true) {\r\n          switch (enc) {\r\n            case 'utf8':\r\n            case 'utf-8':\r\n              return 'utf8';\r\n            case 'ucs2':\r\n            case 'ucs-2':\r\n            case 'utf16le':\r\n            case 'utf-16le':\r\n              return 'utf16le';\r\n            case 'latin1':\r\n            case 'binary':\r\n              return 'latin1';\r\n            case 'base64':\r\n            case 'ascii':\r\n            case 'hex':\r\n              return enc;\r\n            default:\r\n              if (retried) return; // undefined\r\n              enc = ('' + enc).toLowerCase();\r\n              retried = true;\r\n          }\r\n        }\r\n      };\r\n\r\n      // Do not cache `Buffer.isEncoding` when checking encoding names as some\r\n      // modules monkey-patch it to support additional encodings\r\n      function normalizeEncoding(enc) {\r\n        var nenc = _normalizeEncoding(enc);\r\n        if (typeof nenc !== 'string' && (Buffer.isEncoding === isEncoding || !isEncoding(enc))) throw new Error('Unknown encoding: ' + enc);\r\n        return nenc || enc;\r\n      }\r\n\r\n      // StringDecoder provides an interface for efficiently splitting a series of\r\n      // buffers into a series of JS strings without breaking apart multi-byte\r\n      // characters.\r\n      exports.StringDecoder = StringDecoder;\r\n\r\n      function StringDecoder(encoding) {\r\n        this.encoding = normalizeEncoding(encoding);\r\n        var nb;\r\n        switch (this.encoding) {\r\n          case 'utf16le':\r\n            this.text = utf16Text;\r\n            this.end = utf16End;\r\n            nb = 4;\r\n            break;\r\n          case 'utf8':\r\n            this.fillLast = utf8FillLast;\r\n            nb = 4;\r\n            break;\r\n          case 'base64':\r\n            this.text = base64Text;\r\n            this.end = base64End;\r\n            nb = 3;\r\n            break;\r\n          default:\r\n            this.write = simpleWrite;\r\n            this.end = simpleEnd;\r\n            return;\r\n        }\r\n        this.lastNeed = 0;\r\n        this.lastTotal = 0;\r\n        this.lastChar = Buffer.allocUnsafe(nb);\r\n      }\r\n\r\n      StringDecoder.prototype.write = function (buf) {\r\n        if (buf.length === 0) return '';\r\n        var r;\r\n        var i;\r\n        if (this.lastNeed) {\r\n          r = this.fillLast(buf);\r\n          if (r === undefined) return '';\r\n          i = this.lastNeed;\r\n          this.lastNeed = 0;\r\n        } else {\r\n          i = 0;\r\n        }\r\n        if (i < buf.length) return r ? r + this.text(buf, i) : this.text(buf, i);\r\n        return r || '';\r\n      };\r\n\r\n      StringDecoder.prototype.end = utf8End;\r\n\r\n      // Returns only complete characters in a Buffer\r\n      StringDecoder.prototype.text = utf8Text;\r\n\r\n      // Attempts to complete a partial non-UTF-8 character using bytes from a Buffer\r\n      StringDecoder.prototype.fillLast = function (buf) {\r\n        if (this.lastNeed <= buf.length) {\r\n          buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed);\r\n          return this.lastChar.toString(this.encoding, 0, this.lastTotal);\r\n        }\r\n        buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, buf.length);\r\n        this.lastNeed -= buf.length;\r\n      };\r\n\r\n      // Checks the type of a UTF-8 byte, whether it's ASCII, a leading byte, or a\r\n      // continuation byte. If an invalid byte is detected, -2 is returned.\r\n      function utf8CheckByte(byte) {\r\n        if (byte <= 0x7F) return 0;\r\n        else if (byte >> 5 === 0x06) return 2;\r\n        else if (byte >> 4 === 0x0E) return 3;\r\n        else if (byte >> 3 === 0x1E) return 4;\r\n        return byte >> 6 === 0x02 ? -1 : -2;\r\n      }\r\n\r\n      // Checks at most 3 bytes at the end of a Buffer in order to detect an\r\n      // incomplete multi-byte UTF-8 character. The total number of bytes (2, 3, or 4)\r\n      // needed to complete the UTF-8 character (if applicable) are returned.\r\n      function utf8CheckIncomplete(self, buf, i) {\r\n        var j = buf.length - 1;\r\n        if (j < i) return 0;\r\n        var nb = utf8CheckByte(buf[j]);\r\n        if (nb >= 0) {\r\n          if (nb > 0) self.lastNeed = nb - 1;\r\n          return nb;\r\n        }\r\n        if (--j < i || nb === -2) return 0;\r\n        nb = utf8CheckByte(buf[j]);\r\n        if (nb >= 0) {\r\n          if (nb > 0) self.lastNeed = nb - 2;\r\n          return nb;\r\n        }\r\n        if (--j < i || nb === -2) return 0;\r\n        nb = utf8CheckByte(buf[j]);\r\n        if (nb >= 0) {\r\n          if (nb > 0) {\r\n            if (nb === 2) nb = 0;\r\n            else self.lastNeed = nb - 3;\r\n          }\r\n          return nb;\r\n        }\r\n        return 0;\r\n      }\r\n\r\n      // Validates as many continuation bytes for a multi-byte UTF-8 character as\r\n      // needed or are available. If we see a non-continuation byte where we expect\r\n      // one, we \"replace\" the validated continuation bytes we've seen so far with\r\n      // a single UTF-8 replacement character ('\\ufffd'), to match v8's UTF-8 decoding\r\n      // behavior. The continuation byte check is included three times in the case\r\n      // where all of the continuation bytes for a character exist in the same buffer.\r\n      // It is also done this way as a slight performance increase instead of using a\r\n      // loop.\r\n      function utf8CheckExtraBytes(self, buf, p) {\r\n        if ((buf[0] & 0xC0) !== 0x80) {\r\n          self.lastNeed = 0;\r\n          return '\\ufffd';\r\n        }\r\n        if (self.lastNeed > 1 && buf.length > 1) {\r\n          if ((buf[1] & 0xC0) !== 0x80) {\r\n            self.lastNeed = 1;\r\n            return '\\ufffd';\r\n          }\r\n          if (self.lastNeed > 2 && buf.length > 2) {\r\n            if ((buf[2] & 0xC0) !== 0x80) {\r\n              self.lastNeed = 2;\r\n              return '\\ufffd';\r\n            }\r\n          }\r\n        }\r\n      }\r\n\r\n      // Attempts to complete a multi-byte UTF-8 character using bytes from a Buffer.\r\n      function utf8FillLast(buf) {\r\n        var p = this.lastTotal - this.lastNeed;\r\n        var r = utf8CheckExtraBytes(this, buf, p);\r\n        if (r !== undefined) return r;\r\n        if (this.lastNeed <= buf.length) {\r\n          buf.copy(this.lastChar, p, 0, this.lastNeed);\r\n          return this.lastChar.toString(this.encoding, 0, this.lastTotal);\r\n        }\r\n        buf.copy(this.lastChar, p, 0, buf.length);\r\n        this.lastNeed -= buf.length;\r\n      }\r\n\r\n      // Returns all complete UTF-8 characters in a Buffer. If the Buffer ended on a\r\n      // partial character, the character's bytes are buffered until the required\r\n      // number of bytes are available.\r\n      function utf8Text(buf, i) {\r\n        var total = utf8CheckIncomplete(this, buf, i);\r\n        if (!this.lastNeed) return buf.toString('utf8', i);\r\n        this.lastTotal = total;\r\n        var end = buf.length - (total - this.lastNeed);\r\n        buf.copy(this.lastChar, 0, end);\r\n        return buf.toString('utf8', i, end);\r\n      }\r\n\r\n      // For UTF-8, a replacement character is added when ending on a partial\r\n      // character.\r\n      function utf8End(buf) {\r\n        var r = buf && buf.length ? this.write(buf) : '';\r\n        if (this.lastNeed) return r + '\\ufffd';\r\n        return r;\r\n      }\r\n\r\n      // UTF-16LE typically needs two bytes per character, but even if we have an even\r\n      // number of bytes available, we need to check if we end on a leading/high\r\n      // surrogate. In that case, we need to wait for the next two bytes in order to\r\n      // decode the last character properly.\r\n      function utf16Text(buf, i) {\r\n        if ((buf.length - i) % 2 === 0) {\r\n          var r = buf.toString('utf16le', i);\r\n          if (r) {\r\n            var c = r.charCodeAt(r.length - 1);\r\n            if (c >= 0xD800 && c <= 0xDBFF) {\r\n              this.lastNeed = 2;\r\n              this.lastTotal = 4;\r\n              this.lastChar[0] = buf[buf.length - 2];\r\n              this.lastChar[1] = buf[buf.length - 1];\r\n              return r.slice(0, -1);\r\n            }\r\n          }\r\n          return r;\r\n        }\r\n        this.lastNeed = 1;\r\n        this.lastTotal = 2;\r\n        this.lastChar[0] = buf[buf.length - 1];\r\n        return buf.toString('utf16le', i, buf.length - 1);\r\n      }\r\n\r\n      // For UTF-16LE we do not explicitly append special replacement characters if we\r\n      // end on a partial character, we simply let v8 handle that.\r\n      function utf16End(buf) {\r\n        var r = buf && buf.length ? this.write(buf) : '';\r\n        if (this.lastNeed) {\r\n          var end = this.lastTotal - this.lastNeed;\r\n          return r + this.lastChar.toString('utf16le', 0, end);\r\n        }\r\n        return r;\r\n      }\r\n\r\n      function base64Text(buf, i) {\r\n        var n = (buf.length - i) % 3;\r\n        if (n === 0) return buf.toString('base64', i);\r\n        this.lastNeed = 3 - n;\r\n        this.lastTotal = 3;\r\n        if (n === 1) {\r\n          this.lastChar[0] = buf[buf.length - 1];\r\n        } else {\r\n          this.lastChar[0] = buf[buf.length - 2];\r\n          this.lastChar[1] = buf[buf.length - 1];\r\n        }\r\n        return buf.toString('base64', i, buf.length - n);\r\n      }\r\n\r\n      function base64End(buf) {\r\n        var r = buf && buf.length ? this.write(buf) : '';\r\n        if (this.lastNeed) return r + this.lastChar.toString('base64', 0, 3 - this.lastNeed);\r\n        return r;\r\n      }\r\n\r\n      // Pass bytes on through for single-byte encodings (e.g. ascii, latin1, hex)\r\n      function simpleWrite(buf) {\r\n        return buf.toString(this.encoding);\r\n      }\r\n\r\n      function simpleEnd(buf) {\r\n        return buf && buf.length ? this.write(buf) : '';\r\n      }\r\n    }, {\r\n      \"safe-buffer\": 147\r\n    }],\r\n    158: [function (require, module, exports) {\r\n      (function (setImmediate, clearImmediate) {\r\n        var nextTick = require('process/browser.js').nextTick;\r\n        var apply = Function.prototype.apply;\r\n        var slice = Array.prototype.slice;\r\n        var immediateIds = {};\r\n        var nextImmediateId = 0;\r\n\r\n        // DOM APIs, for completeness\r\n\r\n        exports.setTimeout = function () {\r\n          return new Timeout(apply.call(setTimeout, window, arguments), clearTimeout);\r\n        };\r\n        exports.setInterval = function () {\r\n          return new Timeout(apply.call(setInterval, window, arguments), clearInterval);\r\n        };\r\n        exports.clearTimeout =\r\n          exports.clearInterval = function (timeout) {\r\n            timeout.close();\r\n          };\r\n\r\n        function Timeout(id, clearFn) {\r\n          this._id = id;\r\n          this._clearFn = clearFn;\r\n        }\r\n        Timeout.prototype.unref = Timeout.prototype.ref = function () {};\r\n        Timeout.prototype.close = function () {\r\n          this._clearFn.call(window, this._id);\r\n        };\r\n\r\n        // Does not start the time, just sets up the members needed.\r\n        exports.enroll = function (item, msecs) {\r\n          clearTimeout(item._idleTimeoutId);\r\n          item._idleTimeout = msecs;\r\n        };\r\n\r\n        exports.unenroll = function (item) {\r\n          clearTimeout(item._idleTimeoutId);\r\n          item._idleTimeout = -1;\r\n        };\r\n\r\n        exports._unrefActive = exports.active = function (item) {\r\n          clearTimeout(item._idleTimeoutId);\r\n\r\n          var msecs = item._idleTimeout;\r\n          if (msecs >= 0) {\r\n            item._idleTimeoutId = setTimeout(function onTimeout() {\r\n              if (item._onTimeout)\r\n                item._onTimeout();\r\n            }, msecs);\r\n          }\r\n        };\r\n\r\n        // That's not how node.js implements it but the exposed api is the same.\r\n        exports.setImmediate = typeof setImmediate === \"function\" ? setImmediate : function (fn) {\r\n          var id = nextImmediateId++;\r\n          var args = arguments.length < 2 ? false : slice.call(arguments, 1);\r\n\r\n          immediateIds[id] = true;\r\n\r\n          nextTick(function onNextTick() {\r\n            if (immediateIds[id]) {\r\n              // fn.call() is faster so we optimize for the common use-case\r\n              // @see http://jsperf.com/call-apply-segu\r\n              if (args) {\r\n                fn.apply(null, args);\r\n              } else {\r\n                fn.call(null);\r\n              }\r\n              // Prevent ids from leaking\r\n              exports.clearImmediate(id);\r\n            }\r\n          });\r\n\r\n          return id;\r\n        };\r\n\r\n        exports.clearImmediate = typeof clearImmediate === \"function\" ? clearImmediate : function (id) {\r\n          delete immediateIds[id];\r\n        };\r\n      }).call(this, require(\"timers\").setImmediate, require(\"timers\").clearImmediate)\r\n    }, {\r\n      \"process/browser.js\": 124,\r\n      \"timers\": 158\r\n    }],\r\n    159: [function (require, module, exports) {\r\n      (function (global) {\r\n\r\n        /**\r\n         * Module exports.\r\n         */\r\n\r\n        module.exports = deprecate;\r\n\r\n        /**\r\n         * Mark that a method should not be used.\r\n         * Returns a modified function which warns once by default.\r\n         *\r\n         * If `localStorage.noDeprecation = true` is set, then it is a no-op.\r\n         *\r\n         * If `localStorage.throwDeprecation = true` is set, then deprecated functions\r\n         * will throw an Error when invoked.\r\n         *\r\n         * If `localStorage.traceDeprecation = true` is set, then deprecated functions\r\n         * will invoke `console.trace()` instead of `console.error()`.\r\n         *\r\n         * @param {Function} fn - the function to deprecate\r\n         * @param {String} msg - the string to print to the console when `fn` is invoked\r\n         * @returns {Function} a new \"deprecated\" version of `fn`\r\n         * @api public\r\n         */\r\n\r\n        function deprecate(fn, msg) {\r\n          if (config('noDeprecation')) {\r\n            return fn;\r\n          }\r\n\r\n          var warned = false;\r\n\r\n          function deprecated() {\r\n            if (!warned) {\r\n              if (config('throwDeprecation')) {\r\n                throw new Error(msg);\r\n              } else if (config('traceDeprecation')) {\r\n                console.trace(msg);\r\n              } else {\r\n                console.warn(msg);\r\n              }\r\n              warned = true;\r\n            }\r\n            return fn.apply(this, arguments);\r\n          }\r\n\r\n          return deprecated;\r\n        }\r\n\r\n        /**\r\n         * Checks `localStorage` for boolean values for the given `name`.\r\n         *\r\n         * @param {String} name\r\n         * @returns {Boolean}\r\n         * @api private\r\n         */\r\n\r\n        function config(name) {\r\n          // accessing global.localStorage can trigger a DOMException in sandboxed iframes\r\n          try {\r\n            if (!global.localStorage) return false;\r\n          } catch (_) {\r\n            return false;\r\n          }\r\n          var val = global.localStorage[name];\r\n          if (null == val) return false;\r\n          return String(val).toLowerCase() === 'true';\r\n        }\r\n\r\n      }).call(this, typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {})\r\n    }, {}],\r\n    160: [function (require, module, exports) {\r\n      var indexOf = function (xs, item) {\r\n        if (xs.indexOf) return xs.indexOf(item);\r\n        else\r\n          for (var i = 0; i < xs.length; i++) {\r\n            if (xs[i] === item) return i;\r\n          }\r\n        return -1;\r\n      };\r\n      var Object_keys = function (obj) {\r\n        if (Object.keys) return Object.keys(obj)\r\n        else {\r\n          var res = [];\r\n          for (var key in obj) res.push(key)\r\n          return res;\r\n        }\r\n      };\r\n\r\n      var forEach = function (xs, fn) {\r\n        if (xs.forEach) return xs.forEach(fn)\r\n        else\r\n          for (var i = 0; i < xs.length; i++) {\r\n            fn(xs[i], i, xs);\r\n          }\r\n      };\r\n\r\n      var defineProp = (function () {\r\n        try {\r\n          Object.defineProperty({}, '_', {});\r\n          return function (obj, name, value) {\r\n            Object.defineProperty(obj, name, {\r\n              writable: true,\r\n              enumerable: false,\r\n              configurable: true,\r\n              value: value\r\n            })\r\n          };\r\n        } catch (e) {\r\n          return function (obj, name, value) {\r\n            obj[name] = value;\r\n          };\r\n        }\r\n      }());\r\n\r\n      var globals = ['Array', 'Boolean', 'Date', 'Error', 'EvalError', 'Function',\r\n        'Infinity', 'JSON', 'Math', 'NaN', 'Number', 'Object', 'RangeError',\r\n        'ReferenceError', 'RegExp', 'String', 'SyntaxError', 'TypeError', 'URIError',\r\n        'decodeURI', 'decodeURIComponent', 'encodeURI', 'encodeURIComponent', 'escape',\r\n        'eval', 'isFinite', 'isNaN', 'parseFloat', 'parseInt', 'undefined', 'unescape'\r\n      ];\r\n\r\n      function Context() {}\r\n      Context.prototype = {};\r\n\r\n      var Script = exports.Script = function NodeScript(code) {\r\n        if (!(this instanceof Script)) return new Script(code);\r\n        this.code = code;\r\n      };\r\n\r\n      Script.prototype.runInContext = function (context) {\r\n        if (!(context instanceof Context)) {\r\n          throw new TypeError(\"needs a 'context' argument.\");\r\n        }\r\n\r\n        var iframe = document.createElement('iframe');\r\n        if (!iframe.style) iframe.style = {};\r\n        iframe.style.display = 'none';\r\n\r\n        document.body.appendChild(iframe);\r\n\r\n        var win = iframe.contentWindow;\r\n        var wEval = win.eval,\r\n          wExecScript = win.execScript;\r\n\r\n        if (!wEval && wExecScript) {\r\n          // win.eval() magically appears when this is called in IE:\r\n          wExecScript.call(win, 'null');\r\n          wEval = win.eval;\r\n        }\r\n\r\n        forEach(Object_keys(context), function (key) {\r\n          win[key] = context[key];\r\n        });\r\n        forEach(globals, function (key) {\r\n          if (context[key]) {\r\n            win[key] = context[key];\r\n          }\r\n        });\r\n\r\n        var winKeys = Object_keys(win);\r\n\r\n        var res = wEval.call(win, this.code);\r\n\r\n        forEach(Object_keys(win), function (key) {\r\n          // Avoid copying circular objects like `top` and `window` by only\r\n          // updating existing context properties or new properties in the `win`\r\n          // that was only introduced after the eval.\r\n          if (key in context || indexOf(winKeys, key) === -1) {\r\n            context[key] = win[key];\r\n          }\r\n        });\r\n\r\n        forEach(globals, function (key) {\r\n          if (!(key in context)) {\r\n            defineProp(context, key, win[key]);\r\n          }\r\n        });\r\n\r\n        document.body.removeChild(iframe);\r\n\r\n        return res;\r\n      };\r\n\r\n      Script.prototype.runInThisContext = function () {\r\n        return eval(this.code); // maybe...\r\n      };\r\n\r\n      Script.prototype.runInNewContext = function (context) {\r\n        var ctx = Script.createContext(context);\r\n        var res = this.runInContext(ctx);\r\n\r\n        if (context) {\r\n          forEach(Object_keys(ctx), function (key) {\r\n            context[key] = ctx[key];\r\n          });\r\n        }\r\n\r\n        return res;\r\n      };\r\n\r\n      forEach(Object_keys(Script.prototype), function (name) {\r\n        exports[name] = Script[name] = function (code) {\r\n          var s = Script(code);\r\n          return s[name].apply(s, [].slice.call(arguments, 1));\r\n        };\r\n      });\r\n\r\n      exports.isContext = function (context) {\r\n        return context instanceof Context;\r\n      };\r\n\r\n      exports.createScript = function (code) {\r\n        return exports.Script(code);\r\n      };\r\n\r\n      exports.createContext = Script.createContext = function (context) {\r\n        var copy = new Context();\r\n        if (typeof context === 'object') {\r\n          forEach(Object_keys(context), function (key) {\r\n            copy[key] = context[key];\r\n          });\r\n        }\r\n        return copy;\r\n      };\r\n\r\n    }, {}],\r\n    161: [function (require, module, exports) {\r\n      (function (Buffer) {\r\n        \"use strict\";\r\n\r\n        Object.defineProperty(exports, \"__esModule\", {\r\n          value: true\r\n        });\r\n        exports.default = void 0;\r\n\r\n        var _assert = _interopRequireDefault(require(\"assert\"));\r\n\r\n        var _utils = _interopRequireWildcard(require(\"./utils.js\"));\r\n\r\n        var _secretShare = _interopRequireDefault(require(\"./secretShare.js\"));\r\n\r\n        function _interopRequireWildcard(obj) {\r\n          if (obj && obj.__esModule) {\r\n            return obj;\r\n          } else {\r\n            var newObj = {};\r\n            if (obj != null) {\r\n              for (var key in obj) {\r\n                if (Object.prototype.hasOwnProperty.call(obj, key)) {\r\n                  var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {};\r\n                  if (desc.get || desc.set) {\r\n                    Object.defineProperty(newObj, key, desc);\r\n                  } else {\r\n                    newObj[key] = obj[key];\r\n                  }\r\n                }\r\n              }\r\n            }\r\n            newObj.default = obj;\r\n            return newObj;\r\n          }\r\n        }\r\n\r\n        function _interopRequireDefault(obj) {\r\n          return obj && obj.__esModule ? obj : {\r\n            default: obj\r\n          };\r\n        }\r\n\r\n        function _classCallCheck(instance, Constructor) {\r\n          if (!(instance instanceof Constructor)) {\r\n            throw new TypeError(\"Cannot call a class as a function\");\r\n          }\r\n        }\r\n\r\n        function _defineProperties(target, props) {\r\n          for (var i = 0; i < props.length; i++) {\r\n            var descriptor = props[i];\r\n            descriptor.enumerable = descriptor.enumerable || false;\r\n            descriptor.configurable = true;\r\n            if (\"value\" in descriptor) descriptor.writable = true;\r\n            Object.defineProperty(target, descriptor.key, descriptor);\r\n          }\r\n        }\r\n\r\n        function _createClass(Constructor, protoProps, staticProps) {\r\n          if (protoProps) _defineProperties(Constructor.prototype, protoProps);\r\n          if (staticProps) _defineProperties(Constructor, staticProps);\r\n          return Constructor;\r\n        }\r\n\r\n        var ElGamal =\r\n          /*#__PURE__*/\r\n          function () {\r\n            function ElGamal() {\r\n              _classCallCheck(this, ElGamal);\r\n            }\r\n\r\n            _createClass(ElGamal, null, [{\r\n              key: \"encrypt\",\r\n              value: function encrypt(data, pub) {\r\n                return ElGamal.encryptBuffer(data, pub).toString('base64');\r\n              }\r\n            }, {\r\n              key: \"encryptBuffer\",\r\n              value: function encryptBuffer(data, pub) {\r\n                var chunks = _utils.default.decode(data, pub.size, 'utf8');\r\n\r\n                var numbers = [];\r\n\r\n                for (var i = 0; i < chunks.length; i++) {\r\n                  var r = _utils.default.random(_utils.constants.zero, pub.p.subtract(_utils.constants.one));\r\n\r\n                  numbers.push(pub.g.modPow(r, pub.p)); //C1\r\n\r\n                  numbers.push(pub.key.modPow(r, pub.p).multiply(chunks[i]).mod(pub.p)); //C2\r\n                }\r\n\r\n                return Buffer.from(_utils.default.encodeByteArray(numbers, pub.size, true));\r\n              }\r\n            }, {\r\n              key: \"decrypt\",\r\n              value: function decrypt(cypher, prv) {\r\n                try {\r\n                  return ElGamal.decryptBuffer(cypher, prv).toString('utf8');\r\n                } catch (_unused) {\r\n                  return \"\";\r\n                }\r\n              }\r\n            }, {\r\n              key: \"decryptBuffer\",\r\n              value: function decryptBuffer(cypher, prv) {\r\n                var bytes = !_utils.default.isBuffer(cypher) ? Buffer.from(cypher, 'base64') : cypher;\r\n                (0, _assert.default)(bytes.length % (prv.size / 8 * 2) === 0, 'Malformed Cipher Text');\r\n\r\n                var chunks = _utils.default.decode(bytes, prv.size);\r\n\r\n                var numbers = [];\r\n\r\n                for (var i = 0; i < chunks.length; i += 2) {\r\n                  var c1 = chunks[i];\r\n                  var c2 = chunks[i + 1];\r\n                  numbers.push(c1.modPow(prv.key, prv.p).modInv(prv.p).multiply(c2).mod(prv.p));\r\n                }\r\n\r\n                return Buffer.from(_utils.default.encodeByteArray(numbers, prv.size));\r\n              }\r\n            }, {\r\n              key: \"decryptPartial\",\r\n              value: function decryptPartial(cypher, prv) {\r\n                return ElGamal.decryptPartialBuffer(cypher, prv).toString('base64');\r\n              }\r\n            }, {\r\n              key: \"decryptPartialBuffer\",\r\n              value: function decryptPartialBuffer(cypher, prv) {\r\n                var bytes = !_utils.default.isBuffer(cypher) ? Buffer.from(cypher, 'base64') : cypher;\r\n                (0, _assert.default)(bytes.length % (prv.size / 8 * 2) === 0, 'Malformed Cipher Text');\r\n\r\n                var chunks = _utils.default.decode(bytes, prv.size);\r\n\r\n                var numbers = [prv.id];\r\n\r\n                for (var i = 0; i < chunks.length; i += 2) {\r\n                  numbers.push(chunks[i].modPow(prv.key, prv.p)); //C1 ^ X'\r\n\r\n                  numbers.push(chunks[i + 1]); //C2\r\n                }\r\n\r\n                return Buffer.from(_utils.default.encodeByteArray(numbers, prv.size, true));\r\n              }\r\n            }, {\r\n              key: \"combinePartial\",\r\n              value: function combinePartial(partials, pub) {\r\n                try {\r\n                  return ElGamal.combinePartialBuffer(partials, pub).toString('utf8');\r\n                } catch (_unused2) {\r\n                  return \"\";\r\n                }\r\n              }\r\n            }, {\r\n              key: \"combinePartialBuffer\",\r\n              value: function combinePartialBuffer(partials, pub) {\r\n                //TODO: Data validation\r\n                var shares = partials.map(function (p) {\r\n                  return _utils.default.decode(p, pub.size, 'base64');\r\n                });\r\n                var ids = shares.map(function (sh) {\r\n                  return sh[0];\r\n                });\r\n                var first = shares[0];\r\n                var numbers = [];\r\n\r\n                var _loop = function _loop(i) {\r\n                  var ss = shares.map(function (sh) {\r\n                    return sh[i];\r\n                  });\r\n\r\n                  var s = _secretShare.default.interpolatePartial(ids, ss, pub.p, pub.q);\r\n\r\n                  var c2 = first[i + 1];\r\n                  numbers.push(s.modInv(pub.p).multiply(c2).mod(pub.p));\r\n                };\r\n\r\n                for (var i = 1; i < first.length; i += 2) {\r\n                  _loop(i);\r\n                }\r\n\r\n                return Buffer.from(_utils.default.encodeByteArray(numbers, pub.size));\r\n              }\r\n            }]);\r\n\r\n            return ElGamal;\r\n          }();\r\n\r\n        exports.default = ElGamal;\r\n\r\n      }).call(this, require(\"buffer\").Buffer)\r\n    }, {\r\n      \"./secretShare.js\": 164,\r\n      \"./utils.js\": 165,\r\n      \"assert\": 17,\r\n      \"buffer\": 54\r\n    }],\r\n    162: [function (require, module, exports) {\r\n      (function (Buffer) {\r\n        \"use strict\";\r\n\r\n        Object.defineProperty(exports, \"__esModule\", {\r\n          value: true\r\n        });\r\n        exports.default = void 0;\r\n\r\n        var _assert = _interopRequireDefault(require(\"assert\"));\r\n\r\n        var _bigInteger = _interopRequireDefault(require(\"big-integer\"));\r\n\r\n        var _createHash = _interopRequireDefault(require(\"create-hash\"));\r\n\r\n        var _secretShare = _interopRequireDefault(require(\"./secretShare.js\"));\r\n\r\n        var _utils = _interopRequireWildcard(require(\"./utils.js\"));\r\n\r\n        function _interopRequireWildcard(obj) {\r\n          if (obj && obj.__esModule) {\r\n            return obj;\r\n          } else {\r\n            var newObj = {};\r\n            if (obj != null) {\r\n              for (var key in obj) {\r\n                if (Object.prototype.hasOwnProperty.call(obj, key)) {\r\n                  var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {};\r\n                  if (desc.get || desc.set) {\r\n                    Object.defineProperty(newObj, key, desc);\r\n                  } else {\r\n                    newObj[key] = obj[key];\r\n                  }\r\n                }\r\n              }\r\n            }\r\n            newObj.default = obj;\r\n            return newObj;\r\n          }\r\n        }\r\n\r\n        function _interopRequireDefault(obj) {\r\n          return obj && obj.__esModule ? obj : {\r\n            default: obj\r\n          };\r\n        }\r\n\r\n        function _toArray(arr) {\r\n          return _arrayWithHoles(arr) || _iterableToArray(arr) || _nonIterableRest();\r\n        }\r\n\r\n        function _iterableToArray(iter) {\r\n          if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === \"[object Arguments]\") return Array.from(iter);\r\n        }\r\n\r\n        function _slicedToArray(arr, i) {\r\n          return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest();\r\n        }\r\n\r\n        function _nonIterableRest() {\r\n          throw new TypeError(\"Invalid attempt to destructure non-iterable instance\");\r\n        }\r\n\r\n        function _iterableToArrayLimit(arr, i) {\r\n          var _arr = [];\r\n          var _n = true;\r\n          var _d = false;\r\n          var _e = undefined;\r\n          try {\r\n            for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {\r\n              _arr.push(_s.value);\r\n              if (i && _arr.length === i) break;\r\n            }\r\n          } catch (err) {\r\n            _d = true;\r\n            _e = err;\r\n          } finally {\r\n            try {\r\n              if (!_n && _i[\"return\"] != null) _i[\"return\"]();\r\n            } finally {\r\n              if (_d) throw _e;\r\n            }\r\n          }\r\n          return _arr;\r\n        }\r\n\r\n        function _arrayWithHoles(arr) {\r\n          if (Array.isArray(arr)) return arr;\r\n        }\r\n\r\n        function _classCallCheck(instance, Constructor) {\r\n          if (!(instance instanceof Constructor)) {\r\n            throw new TypeError(\"Cannot call a class as a function\");\r\n          }\r\n        }\r\n\r\n        function _defineProperties(target, props) {\r\n          for (var i = 0; i < props.length; i++) {\r\n            var descriptor = props[i];\r\n            descriptor.enumerable = descriptor.enumerable || false;\r\n            descriptor.configurable = true;\r\n            if (\"value\" in descriptor) descriptor.writable = true;\r\n            Object.defineProperty(target, descriptor.key, descriptor);\r\n          }\r\n        }\r\n\r\n        function _createClass(Constructor, protoProps, staticProps) {\r\n          if (protoProps) _defineProperties(Constructor.prototype, protoProps);\r\n          if (staticProps) _defineProperties(Constructor, staticProps);\r\n          return Constructor;\r\n        }\r\n\r\n        var ElGamalKey =\r\n          /*#__PURE__*/\r\n          function () {\r\n            function ElGamalKey(privated, p, q, g, key, id) {\r\n              _classCallCheck(this, ElGamalKey);\r\n\r\n              this.privated = privated;\r\n              this.p = p;\r\n              this.q = q;\r\n              this.g = g;\r\n              this.key = key; //represent the secret in elgammal and the y in secret sharing\r\n\r\n              this.id = id; //represent the x value in secret sharing\r\n            }\r\n\r\n            _createClass(ElGamalKey, [{\r\n              key: \"createPublic\",\r\n              value: function createPublic() {\r\n                var key = this.g.modPow(this.key, this.p);\r\n                return new ElGamalKey(false, this.p, this.q, this.g, key);\r\n              }\r\n            }, {\r\n              key: \"toString\",\r\n              value: function toString() {\r\n                var values = [this.p, this.g, this.key];\r\n                if (this.id) values.push(this.id);\r\n\r\n                var bytes = _utils.default.encodeByteArray(values, this.p.bitLength(), true);\r\n\r\n                var falgs = (this.privated ? 1 : 0) << 1 | (this.id ? 1 : 0);\r\n                bytes.unshift(falgs);\r\n                return Buffer.from(bytes).toString('base64');\r\n              }\r\n            }, {\r\n              key: \"share\",\r\n              value: function share(number, threshold) {\r\n                var _this = this;\r\n\r\n                var _secretShare$share = _secretShare.default.share(this.key, number, threshold, this.q),\r\n                  _secretShare$share2 = _slicedToArray(_secretShare$share, 2),\r\n                  xs = _secretShare$share2[0],\r\n                  ys = _secretShare$share2[1];\r\n\r\n                return ys.map(function (yi, i) {\r\n                  return new ElGamalKey(_this.privated, _this.p, _this.q, _this.g, yi, xs[i]);\r\n                });\r\n              }\r\n            }, {\r\n              key: \"size\",\r\n              get: function get() {\r\n                return this.p.bitLength().value;\r\n              }\r\n            }], [{\r\n              key: \"combine\",\r\n              value: function combine(shares) {\r\n                var first = shares[0];\r\n                var _ref = [shares.map(function (sh) {\r\n                    return sh.id;\r\n                  }), shares.map(function (sh) {\r\n                    return sh.key;\r\n                  })],\r\n                  ids = _ref[0],\r\n                  keys = _ref[1];\r\n\r\n                var key = _secretShare.default.interpolate(ids, keys, first.q);\r\n\r\n                return new ElGamalKey(first.privated, first.p, first.q, first.g, key);\r\n              }\r\n            }, {\r\n              key: \"from\",\r\n              value: function from(text) {\r\n                var _Buffer$from = Buffer.from(text, 'base64'),\r\n                  _Buffer$from2 = _toArray(_Buffer$from),\r\n                  flags = _Buffer$from2[0],\r\n                  bytes = _Buffer$from2.slice(1);\r\n\r\n                var numbers = flags & 1 ? 4 : 3;\r\n                var privated = (flags & 2) > 0;\r\n                (0, _assert.default)(bytes.length % numbers === 0, 'Malformed Key');\r\n\r\n                var _utils$decode = _utils.default.decode(bytes, bytes.length * 8 / numbers),\r\n                  _utils$decode2 = _slicedToArray(_utils$decode, 4),\r\n                  p = _utils$decode2[0],\r\n                  g = _utils$decode2[1],\r\n                  key = _utils$decode2[2],\r\n                  id = _utils$decode2[3];\r\n\r\n                var q = p.minus(_utils.constants.one).divide(_utils.constants.two);\r\n                return new ElGamalKey(privated, p, q, g, key, id);\r\n              }\r\n            }, {\r\n              key: \"generate\",\r\n              value: function generate() {\r\n                var bits = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 256;\r\n                var confidence = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 32;\r\n\r\n                var _utils$randomPrime = _utils.default.randomPrime(bits, confidence),\r\n                  _utils$randomPrime2 = _slicedToArray(_utils$randomPrime, 2),\r\n                  p = _utils$randomPrime2[0],\r\n                  q = _utils$randomPrime2[1];\r\n\r\n                var g = _utils.default.getPrimitiveRoot(p).modPow(_utils.constants.two, p);\r\n\r\n                var x = _utils.default.random(_utils.constants.one, q.subtract(_utils.constants.one));\r\n\r\n                var y = g.modPow(x, p);\r\n                return [new ElGamalKey(true, p, q, g, x), new ElGamalKey(false, p, q, g, y)];\r\n              } //TODO: Improve this\r\n\r\n            }, {\r\n              key: \"seed\",\r\n              value: function seed(pwd) {\r\n                var g = (0, _bigInteger.default)('f3e5bf98c73a188850b10f5c7525f4336e81b361db4a92bf43c4404c32b7e7a', 16);\r\n                var p = (0, _bigInteger.default)('8cec1ccc497f729aa968af8b379a61e967591301b60d0a5b05504f301c93db97', 16);\r\n                var q = p.minus(_utils.constants.one).divide(_utils.constants.two);\r\n                var bytes = Math.ceil(p.bitLength().value / 8);\r\n                var x = seedPrivate(pwd, bytes);\r\n                var y = g.modPow(x, p);\r\n                return [new ElGamalKey(true, p, q, g, x), new ElGamalKey(false, p, q, g, y)];\r\n              }\r\n            }]);\r\n\r\n            return ElGamalKey;\r\n          }();\r\n\r\n        exports.default = ElGamalKey;\r\n\r\n        function seedPrivate(pwd, bytes) {\r\n          var hashes = Array(Math.ceil(bytes / 32));\r\n\r\n          for (var i = 0; i < hashes.length; i++) {\r\n            var data = i ? hashes[i - 1] : pwd;\r\n            hashes[i] = (0, _createHash.default)('sha256').update(data).digest();\r\n          }\r\n\r\n          var hash = Buffer.concat(hashes).slice(-bytes);\r\n          return hash.reduce(function (rtn, num) {\r\n            return rtn.shiftLeft(8).or(num);\r\n          }, _bigInteger.default.zero);\r\n        }\r\n\r\n      }).call(this, require(\"buffer\").Buffer)\r\n    }, {\r\n      \"./secretShare.js\": 164,\r\n      \"./utils.js\": 165,\r\n      \"assert\": 17,\r\n      \"big-integer\": 22,\r\n      \"buffer\": 54,\r\n      \"create-hash\": 58\r\n    }],\r\n    163: [function (require, module, exports) {\r\n      (function (Buffer) {\r\n        \"use strict\";\r\n\r\n        Object.defineProperty(exports, \"__esModule\", {\r\n          value: true\r\n        });\r\n        exports.default = void 0;\r\n\r\n        var _argon2Browser = require(\"argon2-browser\");\r\n\r\n        var _createHash = _interopRequireDefault(require(\"create-hash\"));\r\n\r\n        var _createHmac = _interopRequireDefault(require(\"create-hmac\"));\r\n\r\n        var _utils = _interopRequireDefault(require(\"./utils.js\"));\r\n\r\n        function _interopRequireDefault(obj) {\r\n          return obj && obj.__esModule ? obj : {\r\n            default: obj\r\n          };\r\n        }\r\n\r\n        function _classCallCheck(instance, Constructor) {\r\n          if (!(instance instanceof Constructor)) {\r\n            throw new TypeError(\"Cannot call a class as a function\");\r\n          }\r\n        }\r\n\r\n        function _defineProperties(target, props) {\r\n          for (var i = 0; i < props.length; i++) {\r\n            var descriptor = props[i];\r\n            descriptor.enumerable = descriptor.enumerable || false;\r\n            descriptor.configurable = true;\r\n            if (\"value\" in descriptor) descriptor.writable = true;\r\n            Object.defineProperty(target, descriptor.key, descriptor);\r\n          }\r\n        }\r\n\r\n        function _createClass(Constructor, protoProps, staticProps) {\r\n          if (protoProps) _defineProperties(Constructor.prototype, protoProps);\r\n          if (staticProps) _defineProperties(Constructor, staticProps);\r\n          return Constructor;\r\n        }\r\n\r\n        function getCurrentUrl() {\r\n          if (!document) return null;\r\n          var scripts = document.getElementsByTagName(\"script\");\r\n          var script = scripts[scripts.length - 1].src;\r\n          return script.slice(0, script.lastIndexOf(\"/\"));\r\n        }\r\n\r\n        var asmUrl = getCurrentUrl();\r\n\r\n        var Hash =\r\n          /*#__PURE__*/\r\n          function () {\r\n            function Hash() {\r\n              _classCallCheck(this, Hash);\r\n            }\r\n\r\n            _createClass(Hash, null, [{\r\n              key: \"passwords\",\r\n              value: function passwords(pass, salt, servers) {\r\n                return Hash.argon2Buffer(pass, salt).then(function (hash) {\r\n                  return servers.map(function (server) {\r\n                    return {\r\n                      server: server,\r\n                      hash: Hash.hmacBuffer(pass + server, hash).slice(-1)\r\n                    };\r\n                  });\r\n                }).then(function (hashes) {\r\n                  return hashes.map(function (item) {\r\n                    return {\r\n                      server: item.server,\r\n                      pass: Buffer.from(item.hash).toString(\"base64\").slice(0, 2)\r\n                    };\r\n                  });\r\n                });\r\n              }\r\n            }, {\r\n              key: \"argon2\",\r\n              value: function argon2(pass, salt) {\r\n                return Hash.argon2Buffer(pass, salt).then(function (hash) {\r\n                  return hash.toString('base64');\r\n                });\r\n              }\r\n            }, {\r\n              key: \"argon2Buffer\",\r\n              value: function argon2Buffer(pass, salt) {\r\n                return _argon2Browser.argon2.hash({\r\n                  pass: pass,\r\n                  salt: salt,\r\n                  time: 4,\r\n                  // the number of iterations\r\n                  mem: 5120,\r\n                  // used memory, in KiB\r\n                  hashLen: 32,\r\n                  // desired hash length\r\n                  parallelism: 4,\r\n                  // desired parallelism (will be computed in parallel only for PNaCl)\r\n                  type: _argon2Browser.argon2.ArgonType.Argon2,\r\n                  // or argon2.ArgonType.Argon2i\r\n                  distPath: asmUrl // asm.js script location, without trailing slash\r\n\r\n                }).then(function (data) {\r\n                  return Buffer.from(data.hash);\r\n                });\r\n              }\r\n            }, {\r\n              key: \"sha\",\r\n              value: function sha(message) {\r\n                return Hash.shaBuffer(message).toString('base64');\r\n              }\r\n            }, {\r\n              key: \"shaBuffer\",\r\n              value: function shaBuffer(message) {\r\n                return (0, _createHash.default)('sha256').update(message).digest();\r\n              }\r\n            }, {\r\n              key: \"hmac\",\r\n              value: function hmac(data, secret) {\r\n                return Hash.hmacBuffer(data, secret).toString('base64');\r\n              }\r\n            }, {\r\n              key: \"hmacBuffer\",\r\n              value: function hmacBuffer(data, secret) {\r\n                secret = !_utils.default.isBuffer(secret) ? Buffer.from(secret) : secret;\r\n                return (0, _createHmac.default)('sha256', secret).update(data).digest();\r\n              }\r\n            }, {\r\n              key: \"asmUrl\",\r\n              get: function get() {\r\n                return asmUrl;\r\n              },\r\n              set: function set(value) {\r\n                asmUrl = value;\r\n              }\r\n            }]);\r\n\r\n            return Hash;\r\n          }();\r\n\r\n        exports.default = Hash;\r\n\r\n      }).call(this, require(\"buffer\").Buffer)\r\n    }, {\r\n      \"./utils.js\": 165,\r\n      \"argon2-browser\": 2,\r\n      \"buffer\": 54,\r\n      \"create-hash\": 58,\r\n      \"create-hmac\": 60\r\n    }],\r\n    164: [function (require, module, exports) {\r\n      (function (Buffer) {\r\n        \"use strict\";\r\n\r\n        Object.defineProperty(exports, \"__esModule\", {\r\n          value: true\r\n        });\r\n        exports.default = void 0;\r\n\r\n        var _utils = _interopRequireWildcard(require(\"./utils.js\"));\r\n\r\n        var _bigInteger = _interopRequireDefault(require(\"big-integer\"));\r\n\r\n        function _interopRequireDefault(obj) {\r\n          return obj && obj.__esModule ? obj : {\r\n            default: obj\r\n          };\r\n        }\r\n\r\n        function _interopRequireWildcard(obj) {\r\n          if (obj && obj.__esModule) {\r\n            return obj;\r\n          } else {\r\n            var newObj = {};\r\n            if (obj != null) {\r\n              for (var key in obj) {\r\n                if (Object.prototype.hasOwnProperty.call(obj, key)) {\r\n                  var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {};\r\n                  if (desc.get || desc.set) {\r\n                    Object.defineProperty(newObj, key, desc);\r\n                  } else {\r\n                    newObj[key] = obj[key];\r\n                  }\r\n                }\r\n              }\r\n            }\r\n            newObj.default = obj;\r\n            return newObj;\r\n          }\r\n        }\r\n\r\n        function _classCallCheck(instance, Constructor) {\r\n          if (!(instance instanceof Constructor)) {\r\n            throw new TypeError(\"Cannot call a class as a function\");\r\n          }\r\n        }\r\n\r\n        function _defineProperties(target, props) {\r\n          for (var i = 0; i < props.length; i++) {\r\n            var descriptor = props[i];\r\n            descriptor.enumerable = descriptor.enumerable || false;\r\n            descriptor.configurable = true;\r\n            if (\"value\" in descriptor) descriptor.writable = true;\r\n            Object.defineProperty(target, descriptor.key, descriptor);\r\n          }\r\n        }\r\n\r\n        function _createClass(Constructor, protoProps, staticProps) {\r\n          if (protoProps) _defineProperties(Constructor.prototype, protoProps);\r\n          if (staticProps) _defineProperties(Constructor, staticProps);\r\n          return Constructor;\r\n        }\r\n\r\n        var SecretShare =\r\n          /*#__PURE__*/\r\n          function () {\r\n            function SecretShare() {\r\n              _classCallCheck(this, SecretShare);\r\n            }\r\n\r\n            _createClass(SecretShare, null, [{\r\n              key: \"interpolatePartial\",\r\n              value: function interpolatePartial(xs, ys, p, q) {\r\n                return xs.map(function (xi, i) {\r\n                  return ys[i].modPow(basisPoly(xi, xs, q), p);\r\n                }).reduce(function (secret, num) {\r\n                  return secret.times(num).mod(p);\r\n                });\r\n              }\r\n            }, {\r\n              key: \"interpolate\",\r\n              value: function interpolate(xs, ys, m) {\r\n                return xs.map(function (xi, i) {\r\n                  return basisPoly(xi, xs, m).times(ys[i]).mod(m);\r\n                }).reduce(function (secret, num) {\r\n                  return secret.plus(num).mod(m);\r\n                });\r\n              }\r\n            }, {\r\n              key: \"share\",\r\n              value: function share(secret, number, threshold, m) {\r\n                var xs = randoms(number, m);\r\n                var coeffs = [secret].concat(randoms(threshold - 1, m));\r\n                return [xs, xs.map(function (x) {\r\n                  return evalPoly(coeffs, x, m);\r\n                })];\r\n              }\r\n            }, {\r\n              key: \"interpolateText\",\r\n              value: function interpolateText(shares, m) {\r\n                try {\r\n                  return SecretShare.interpolateBuffer(shares, m).toString('utf8');\r\n                } catch (_unused) {\r\n                  return \"\";\r\n                }\r\n              } //TODO: Verify the input\r\n\r\n            }, {\r\n              key: \"interpolateBuffer\",\r\n              value: function interpolateBuffer(shares, m) {\r\n                var size = m.bitLength().value;\r\n                var bytes = Math.ceil(size / 8);\r\n                shares = shares.map(function (shr) {\r\n                  return Buffer.from(shr, 'base64');\r\n                });\r\n                var xs = shares.map(function (shr) {\r\n                  return _utils.default.decode(shr.slice(0, bytes), size)[0];\r\n                });\r\n                var chunks = shares.map(function (shr) {\r\n                  return _utils.default.decode(shr.slice(bytes), size);\r\n                });\r\n                var numbers = [];\r\n\r\n                var _loop = function _loop(i) {\r\n                  var ys = chunks.map(function (ch) {\r\n                    return ch[i];\r\n                  });\r\n                  numbers.push(SecretShare.interpolate(xs, ys, m));\r\n                };\r\n\r\n                for (var i = 0; i < chunks[0].length; i++) {\r\n                  _loop(i);\r\n                }\r\n\r\n                return Buffer.from(_utils.default.encodeByteArray(numbers, size));\r\n              }\r\n            }, {\r\n              key: \"shareText\",\r\n              value: function shareText(data, number, threshold, m) {\r\n                return SecretShare.shareBuffer(data, number, threshold, m).map(function (sh) {\r\n                  return sh.toString('base64');\r\n                });\r\n              }\r\n            }, {\r\n              key: \"shareBuffer\",\r\n              value: function shareBuffer(data, number, threshold, m) {\r\n                var size = m.bitLength().value;\r\n\r\n                var chunks = _utils.default.decode(data, size, 'utf8');\r\n\r\n                var shares = randoms(number, m).map(function (xi) {\r\n                  return {\r\n                    xi: xi,\r\n                    ys: []\r\n                  };\r\n                });\r\n\r\n                for (var i = 0; i < chunks.length; i++) {\r\n                  var coeffs = [chunks[i]].concat(randoms(threshold - 1, m));\r\n\r\n                  for (var j = 0; j < shares.length; j++) {\r\n                    shares[j].ys.push(evalPoly(coeffs, shares[j].xi, m));\r\n                  }\r\n                }\r\n\r\n                return shares.map(function (sh) {\r\n                  return [_utils.default.encodeByteArray([sh.xi], size, true), _utils.default.encodeByteArray(sh.ys, size, true)];\r\n                }).map(function (sh) {\r\n                  return Buffer.from(Array.prototype.concat.apply([], sh));\r\n                });\r\n              }\r\n            }]);\r\n\r\n            return SecretShare;\r\n          }();\r\n\r\n        exports.default = SecretShare;\r\n\r\n        function basisPoly(xi, xs, m) {\r\n          var li = xs.filter(function (xj) {\r\n            return !xj.equals(xi);\r\n          }).map(function (xj) {\r\n            return xj.minus(xi).modInv(m).times(xj).mod(m);\r\n          }).reduce(function (li, num) {\r\n            return li.times(num).mod(m);\r\n          });\r\n          return li.sign ? m.plus(li) : li; //library does not support unsigned mod ()\r\n        }\r\n\r\n        function randoms(count, m) {\r\n          var numbers = [];\r\n\r\n          while (numbers.length < count) {\r\n            var rdm = _utils.default.random(_utils.constants.one, m.minus(_utils.constants.one));\r\n\r\n            if (numbers.every(function (num) {\r\n                return !rdm.equals(num);\r\n              })) numbers.push(rdm);\r\n          }\r\n\r\n          return numbers;\r\n        }\r\n\r\n        function evalPoly(coeffs, x, m) {\r\n          var y = coeffs[coeffs.length - 1];\r\n\r\n          for (var i = coeffs.length - 2; i >= 0; i--) {\r\n            y = y.times(x).mod(m).plus(coeffs[i]).mod(m);\r\n          }\r\n\r\n          return y;\r\n        }\r\n\r\n      }).call(this, require(\"buffer\").Buffer)\r\n    }, {\r\n      \"./utils.js\": 165,\r\n      \"big-integer\": 22,\r\n      \"buffer\": 54\r\n    }],\r\n    165: [function (require, module, exports) {\r\n      (function (Buffer) {\r\n        \"use strict\";\r\n\r\n        Object.defineProperty(exports, \"__esModule\", {\r\n          value: true\r\n        });\r\n        exports.default = exports.constants = void 0;\r\n\r\n        var _bigInteger = _interopRequireDefault(require(\"big-integer\"));\r\n\r\n        var _crypto = require(\"crypto\");\r\n\r\n        function _interopRequireDefault(obj) {\r\n          return obj && obj.__esModule ? obj : {\r\n            default: obj\r\n          };\r\n        }\r\n\r\n        function _classCallCheck(instance, Constructor) {\r\n          if (!(instance instanceof Constructor)) {\r\n            throw new TypeError(\"Cannot call a class as a function\");\r\n          }\r\n        }\r\n\r\n        function _defineProperties(target, props) {\r\n          for (var i = 0; i < props.length; i++) {\r\n            var descriptor = props[i];\r\n            descriptor.enumerable = descriptor.enumerable || false;\r\n            descriptor.configurable = true;\r\n            if (\"value\" in descriptor) descriptor.writable = true;\r\n            Object.defineProperty(target, descriptor.key, descriptor);\r\n          }\r\n        }\r\n\r\n        function _createClass(Constructor, protoProps, staticProps) {\r\n          if (protoProps) _defineProperties(Constructor.prototype, protoProps);\r\n          if (staticProps) _defineProperties(Constructor, staticProps);\r\n          return Constructor;\r\n        }\r\n\r\n        var constants = {\r\n          zero: new _bigInteger.default(0),\r\n          one: new _bigInteger.default(1),\r\n          two: new _bigInteger.default(2)\r\n        };\r\n        exports.constants = constants;\r\n\r\n        var Utils =\r\n          /*#__PURE__*/\r\n          function () {\r\n            function Utils() {\r\n              _classCallCheck(this, Utils);\r\n            }\r\n\r\n            _createClass(Utils, null, [{\r\n              key: \"encode\",\r\n              value: function encode(numbers, bits) {\r\n                var encoding = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : undefined;\r\n                var fill = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\r\n                var bytes = Utils.encodeByteArray(numbers, bits, fill);\r\n                return Buffer.from(bytes).toString(encoding);\r\n              } //TODO: Improve this to use Uint32Array and not waste to much memory\r\n\r\n            }, {\r\n              key: \"encodeByteArray\",\r\n              value: function encodeByteArray(numbers, bits) {\r\n                var fill = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\r\n                var blockSize = Math.ceil(bits / 8);\r\n                var arrayBuffer = [];\r\n\r\n                for (var i = 0; i < numbers.length; i++) {\r\n                  var bytes = numbers[i].toArray(256).value;\r\n\r\n                  if (fill) {\r\n                    //fill the empty bits\r\n                    var diff = blockSize - bytes.length;\r\n\r\n                    for (var j = 0; j < diff; j++) {\r\n                      bytes.unshift(0);\r\n                    }\r\n                  }\r\n\r\n                  arrayBuffer.push(bytes);\r\n                }\r\n\r\n                return Array.prototype.concat.apply([], arrayBuffer);\r\n              } //TODO: Doesn't work with chinese characters, like text = \"I'm , and my dad's   \";\r\n\r\n            }, {\r\n              key: \"decode\",\r\n              value: function decode(data, bits) {\r\n                var encoding = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : undefined;\r\n                if (!Utils.isBuffer(data)) data = Buffer.from(data, encoding);\r\n                var blockSize = bits / 8;\r\n                var numbers = [];\r\n                var j = -1;\r\n\r\n                for (var i = 0; i < data.length; i++) {\r\n                  if (i % blockSize === 0) {\r\n                    j++;\r\n                    numbers.push(constants.zero);\r\n                  }\r\n\r\n                  numbers[j] = numbers[j].shiftLeft(8).or(new _bigInteger.default(data[i].toString()));\r\n                }\r\n\r\n                return numbers;\r\n              }\r\n            }, {\r\n              key: \"getPrimitiveRoot\",\r\n              value: function getPrimitiveRoot(p) {\r\n                if (p.equals(constants.two)) return constants.one;\r\n                var min = new _bigInteger.default(3); // Avoid g=2 because of Bleichenbacher's attack\r\n\r\n                var max = p.subtract(constants.one);\r\n                var p1 = constants.two; // The prime divisors of p-1 are 2 and (p-1)/2\r\n\r\n                var p2 = max.divide(p1); // Because: p = 2q + 1 where q is a prime\r\n\r\n                while (true) {\r\n                  var g = this.random(min, max);\r\n                  if (!g.modPow(p1, p).equals(constants.one) && !g.modPow(p2, p).equals(constants.one) && !p.subtract(constants.one).mod(g).equals(constants.zero) && // g|p-1\r\n                    !p.subtract(constants.one).mod(g.modInv(p)).equals(constants.zero)) // g^(-1)|p-1 (evades Khadir's attack)\r\n                    return g;\r\n                }\r\n              }\r\n            }, {\r\n              key: \"random\",\r\n              value: function random(min, max) {\r\n                var rang = max.subtract(min);\r\n                var rdmLen = Math.ceil(rang.bitLength() / 8);\r\n                var diff = rdmLen * 8 - rang.bitLength();\r\n                var rdm;\r\n\r\n                do {\r\n                  rdm = new _bigInteger.default((0, _crypto.randomBytes)(rdmLen).toString('hex'), 16);\r\n                  rdm = rdm.shiftRight(diff).add(min);\r\n                } while (rdm.compareTo(max) > 0);\r\n\r\n                return rdm;\r\n              } //min == 2 ^ (bits-2) == 1 << bits-2 that is, 1 and bits-2 zeros to the right\r\n              //max == ((2 ^ bits) -2)/2 that is, all the bits in 1 with bits-1 length\r\n              //because q = (p -1) / 2 and p <= (2 ^ bits) -1 that is, all the bits in 1\r\n\r\n            }, {\r\n              key: \"randomPrime\",\r\n              value: function randomPrime(bits, confidence) {\r\n                var maxLen = bits - 2;\r\n                var rdmLen = Math.ceil(maxLen / 8);\r\n                var diff = rdmLen * 8 - maxLen;\r\n                var min = constants.one.shiftLeft(bits - 2);\r\n\r\n                while (true) {\r\n                  var rdm = new _bigInteger.default((0, _crypto.randomBytes)(rdmLen).toString('hex'), 16); //trunk to bits, add minimum range and the number has to be odd\r\n\r\n                  var q = rdm.shiftRight(diff).add(min).or(constants.one);\r\n                  if (!q.isProbablePrime(confidence)) continue; // p = (q * 2) + 1\r\n\r\n                  var p = q.shiftLeft(1).add(constants.one);\r\n                  if (!p.isProbablePrime(confidence)) continue;\r\n                  return [p, q];\r\n                }\r\n              }\r\n            }, {\r\n              key: \"isBuffer\",\r\n              value: function isBuffer(data) {\r\n                return Buffer.isBuffer(data) || ArrayBuffer.isView(data);\r\n              }\r\n            }]);\r\n\r\n            return Utils;\r\n          }();\r\n\r\n        exports.default = Utils;\r\n\r\n      }).call(this, require(\"buffer\").Buffer)\r\n    }, {\r\n      \"big-integer\": 22,\r\n      \"buffer\": 54,\r\n      \"crypto\": 62\r\n    }]\r\n  }, {}, [1])(1)\r\n});\r\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../webpack/buildin/global.js */ \"./node_modules/webpack/buildin/global.js\")))\n\n//# sourceURL=webpack:///./node_modules/tide-js/src/cryptide.js?");

/***/ }),

/***/ "./node_modules/webpack/buildin/global.js":
/*!***********************************!*\
  !*** (webpack)/buildin/global.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("var g;\n\n// This works in non-strict mode\ng = (function() {\n\treturn this;\n})();\n\ntry {\n\t// This works if eval is allowed (see CSP)\n\tg = g || new Function(\"return this\")();\n} catch (e) {\n\t// This works if the window reference is available\n\tif (typeof window === \"object\") g = window;\n}\n\n// g can still be undefined, but nothing to do about it...\n// We return undefined, instead of nothing here, so it's\n// easier to handle this case. if(!global) { ...}\n\nmodule.exports = g;\n\n\n//# sourceURL=webpack:///(webpack)/buildin/global.js?");

/***/ }),

/***/ "./src/assets/js/config.js":
/*!*********************************!*\
  !*** ./src/assets/js/config.js ***!
  \*********************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* \r\n * Tide Protocol - Infrastructure for the Personal Data economy\r\n * Copyright (C) 2019 Tide Foundation Ltd\r\n * \r\n * This program is free software and is subject to the terms of \r\n * the Tide Community Open Source License as published by the \r\n * Tide Foundation Limited. You may modify it and redistribute \r\n * it in accordance with and subject to the terms of that License.\r\n * This program is distributed WITHOUT WARRANTY of any kind, \r\n * including without any implied warranty of MERCHANTABILITY or \r\n * FITNESS FOR A PARTICULAR PURPOSE.\r\n * See the Tide Community Open Source License for more details.\r\n * You should have received a copy of the Tide Community Open \r\n * Source License along with this program.\r\n * If not, see https://tide.org/licenses_tcosl-1-0-en\r\n */\r\n\r\n/* harmony default export */ __webpack_exports__[\"default\"] = ({\r\n    nodes: [\"https://raziel-ork-test-1.azurewebsites.net\", \"https://raziel-ork-test-2.azurewebsites.net\", \"https://raziel-ork-test-3.azurewebsites.net\"]\r\n});\r\n\r\ndocument.addEventListener(\"tide-log\", (e) => console.log(e.detail.msg));\n\n//# sourceURL=webpack:///./src/assets/js/config.js?");

/***/ })

/******/ });